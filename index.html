<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mobile 5000 VR Sequencer v5.4 - Latest Updates</title>
  
<script defer src="https://progressier.app/NOLokP3x5p8eNJFfP22U/script.js"></script>
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<script src="fm-script.js"></script>
  <style>
 :root { --purple:#9b5cff; }
  html,body{margin:0;overflow:hidden;background:#0a0a1a;font-family:monospace;}
  *{-webkit-tap-highlight-color:transparent;}
 
  /* ADD THIS CSS ANIMATION */
  /* Power button pulse animation - MORE DRAMATIC */
@keyframes powerPulse {
  0% {
    filter: brightness(0.3);
    transform: scale(1);
  }
  50% {
    filter: brightness(1.5);
    transform: scale(1.05);
  }
  100% {
    filter: brightness(0.3);
    transform: scale(1);
  }
}

.power-button-pulse {
  animation: powerPulse 1s ease-in-out infinite;
}
    :root { --purple:#9b5cff; }
    html,body{margin:0;overflow:hidden;background:#0a0a1a;font-family:monospace;}
    *{-webkit-tap-highlight-color:transparent;}
    #startScreen {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 9999; font-family: monospace;
    }
    #startScreen h1 { color: #9b5cff; font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 20px #9b5cff; }
    #startScreen p { color: #00FFFF; font-size: 18px; margin-bottom: 40px; }
    .mode-button {
      padding: 20px 60px; margin: 15px; font-size: 24px; font-family: monospace;
      border: 3px solid #9b5cff; background: #1a1a3a; color: #9b5cff; cursor: pointer;
      transition: all 0.3s; text-shadow: 0 0 10px #9b5cff; box-shadow: 0 0 20px rgba(155, 92, 255, 0.3);
    }
    .mode-button:hover {
      background: #9b5cff; color: #0a0a1a; transform: scale(1.1); box-shadow: 0 0 30px rgba(155, 92, 255, 0.6);
    }
#oscilloscope {
  position: relative;
}

.scope-frame {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

.scope-glass {
  position: absolute;
  width: calc(100% - 0.02);
  height: calc(100% - 0.02);
  left: 0.01;
  top: 0.01;
  background: rgba(100, 150, 200, 0.05);
  pointer-events: none;
}
#drumButtons {
  display: none !important;
}

.drum-page #drumButtons {
  display: none !important;
}
@keyframes pulse {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 1.0; }
}



  </style>
</head>
<body>
  <div id="startScreen">
    <h1>MOBILE 5000 VR SEQUENCER</h1>
    <p>SELECT YOUR MODE</p>
    <button class="mode-button" id="desktopBtn">üñ•Ô∏è DESKTOP MODE</button>
    <button class="mode-button" id="vrBtn">ü•Ω VR MODE</button>
  </div>

  <input type="file" id="loadFile" style="display:none" accept=".json" onchange="loadFromFile(event)" />

<a-scene id="mainScene" sequencer-loop style="display:none"
         renderer="antialias:true;colorManagement:true;physicallyCorrectLights:true">

    <a-entity id="rig" position="0 1.7 0.2">
      <a-camera id="mainCamera" wasd-controls="enabled: false" look-controls="pointerLockEnabled:false;mouseEnabled:false" position="0 0 0" raycaster="objects:.clickable;far:5" cursor="rayOrigin:mouse"></a-camera>
      <a-entity id="leftController" laser-controls="hand: left" raycaster="objects: .clickable; far: 3" line="color: #ff69b4; opacity: 0.75" vr-controller-handler="hand: left"></a-entity>
      <a-entity id="rightController" laser-controls="hand: right" raycaster="objects: .clickable; far: 3" line="color: #00ffff; opacity: 0.75" vr-controller-handler="hand: right"></a-entity>
      <a-entity id="leftHand" hand-tracking-controls="hand: left; modelColor: #ff69b4" hand-fingertip-touch="hand: left"></a-entity>
      <a-entity id="rightHand" hand-tracking-controls="hand: right; modelColor: #00ffff" hand-fingertip-touch="hand: right"></a-entity>
    </a-entity>
<a-sky id="skybox" visible="false" rotation="0 0 0" radius="5000"></a-sky>

    <a-light type="ambient" intensity="0.2" color="#ffffff"></a-light>
    <a-light type="directional" position="0 4 2" intensity="1.2" color="#ffffff" cast-shadow="true"></a-light>
    <a-light type="point" position="-1.5 3 -0.5" intensity="0.6" color="#FF00FF" distance="4"></a-light>
    <a-light type="point" position="1.5 3 -0.5" intensity="0.6" color="#00FFFF" distance="4"></a-light>

 <a-entity id="synthWorkstation" position="0 2.6 -0.42" rotation="0 0 0" scale="0.2 0.2 0.2">
   
     
     
      <!-- Version indicator at bottom -->
     
     <a-entity id="velocityLane" position="-0.145 -0.40 0.05"></a-entity>
      <a-box id="synthBody" width="3.7" height="1.05" depth="0.08" position="-0.20 -0.28 -0.05" color="#2a2a4e" material="metalness:0.5;roughness:0.3;opacity:0.85;transparent:true" shadow="cast:true;receive:true"></a-box>
// Add the power button in buildUI() function (around line 2100):
// Add this RIGHT AFTER the left speaker code in the HTML:

<!-- Power Button below Left Speaker -->
<!-- Power Button below Left Speaker - SQUARE VERSION -->
<a-entity id="powerButton" position="-1.75 -0.1 0.05">
  <!-- Button Housing (square base) -->
  <a-box id="powerButtonHousing"
         width="0.08"
         height="0.08"
         depth="0.03"
         color="#1a1a1a"
         material="metalness:0.8;roughness:0.2"
         shadow="cast:true;receive:true"></a-box>
 
  <!-- Button Cap (the part you press - square) -->
  <a-box id="powerButtonCap"
         class="clickable power-button-pulse"
         width="0.07"
         height="0.07"
         depth="0.015"
         position="0 0 0.02"
         color="#FF0000"
         material="metalness:0.6;roughness:0.4;emissive:#FF0000;emissiveIntensity:2.5"
         shadow="cast:true"></a-box>
 
  <!-- Power Symbol (I/O) -->
  <a-text value="‚èª"
          position="0 0 0.04"
          align="center"
          color="#FFFFFF"
          scale="0.10 0.10 0.10"></a-text>
</a-entity>

      <a-entity id="pageButtons" position="0.10 0.08 0.05"></a-entity>
      <a-entity id="globalUndo" position="-1.41 0.10 0.05"></a-entity>
      <a-entity id="demoButton" position="-1.41 -0.05 0.05"></a-entity>
      <!-- Left Speaker - Realistic Concentric Rings -->
      <a-entity id="leftSpeaker" position="-1.80 0.10 -0.05">
        <!-- Speaker box -->
        <a-box width="0.25" height="0.25" depth="0.25" color="#1a1a2a" material="metalness:0.6;roughness:0.4" shadow="cast:true;receive:true"></a-box>
        <!-- Outer rim - dark gray -->
        <a-ring id="leftSpeakerRim" radius-inner="0.10" radius-outer="0.115" position="0 0 0.126" color="#2a2a3a" material="metalness:0.7;roughness:0.3;side:double"></a-ring>
        <!-- Ring 1 - outer -->
        <a-ring id="leftSpeakerRing1" radius-inner="0.088" radius-outer="0.098" position="0 0 0.127" color="#3a3a4a" material="metalness:0.6;roughness:0.4;side:double"></a-ring>
        <!-- Ring 2 -->
        <a-ring id="leftSpeakerRing2" radius-inner="0.076" radius-outer="0.086" position="0 0 0.128" color="#4a4a5a" material="metalness:0.5;roughness:0.5;side:double"></a-ring>
        <!-- Ring 3 -->
        <a-ring id="leftSpeakerRing3" radius-inner="0.064" radius-outer="0.074" position="0 0 0.129" color="#5a5a6a" material="metalness:0.4;roughness:0.6;side:double"></a-ring>
        <!-- Ring 4 -->
        <a-ring id="leftSpeakerRing4" radius-inner="0.052" radius-outer="0.062" position="0 0 0.130" color="#6a6a7a" material="metalness:0.3;roughness:0.7;side:double"></a-ring>
        <!-- Ring 5 - inner -->
        <a-ring id="leftSpeakerRing5" radius-inner="0.040" radius-outer="0.050" position="0 0 0.131" color="#7a7a8a" material="metalness:0.2;roughness:0.8;side:double"></a-ring>
        <!-- Center dome - purple glow -->
        <a-circle id="leftSpeakerDome" radius="0.038" position="0 0 0.132" color="#AA55DD" material="metalness:0.8;roughness:0.2;emissive:#AA55DD;emissiveIntensity:1.0;side:double"></a-circle>
      </a-entity>
      <!-- Right Speaker - Realistic Concentric Rings -->
      <a-entity id="rightSpeaker" position="1.45 0.10 -0.05">
        <!-- Speaker box -->
        <a-box width="0.25" height="0.25" depth="0.25" color="#1a1a2a" material="metalness:0.6;roughness:0.4" shadow="cast:true;receive:true"></a-box>
        <!-- Outer rim - dark gray -->
        <a-ring id="rightSpeakerRim" radius-inner="0.10" radius-outer="0.115" position="0 0 0.126" color="#2a2a3a" material="metalness:0.7;roughness:0.3;side:double"></a-ring>
        <!-- Ring 1 - outer -->
        <a-ring id="rightSpeakerRing1" radius-inner="0.088" radius-outer="0.098" position="0 0 0.127" color="#3a3a4a" material="metalness:0.6;roughness:0.4;side:double"></a-ring>
        <!-- Ring 2 -->
        <a-ring id="rightSpeakerRing2" radius-inner="0.076" radius-outer="0.086" position="0 0 0.128" color="#4a4a5a" material="metalness:0.5;roughness:0.5;side:double"></a-ring>
        <!-- Ring 3 -->
        <a-ring id="rightSpeakerRing3" radius-inner="0.064" radius-outer="0.074" position="0 0 0.129" color="#5a5a6a" material="metalness:0.4;roughness:0.6;side:double"></a-ring>
        <!-- Ring 4 -->
        <a-ring id="rightSpeakerRing4" radius-inner="0.052" radius-outer="0.062" position="0 0 0.130" color="#6a6a7a" material="metalness:0.3;roughness:0.7;side:double"></a-ring>
        <!-- Ring 5 - inner -->
        <a-ring id="rightSpeakerRing5" radius-inner="0.040" radius-outer="0.050" position="0 0 0.131" color="#7a7a8a" material="metalness:0.2;roughness:0.8;side:double"></a-ring>
        <!-- Center dome - cyan glow -->
        <a-circle id="rightSpeakerDome" radius="0.038" position="0 0 0.132" color="#33AADD" material="metalness:0.8;roughness:0.2;emissive:#33AADD;emissiveIntensity:1.0;side:double"></a-circle>
      </a-entity>
      <a-entity id="bpmButtons" position="-1.75 -0.15 0.05"></a-entity>
      <a-entity id="patternButtons" position="1.2 -0.45 0.05"></a-entity>
      <a-entity id="viewButtons" position="0 0 0"></a-entity>
      <a-entity id="octaveButtons" position="1.20 -0.63 0.05"></a-entity>
      <a-entity id="oscilloscope" position="-0.13 -0.20 0.05"></a-entity>
      <a-text id="buttonFunctionDisplay" position="-0.14 -0.25 0.06" value="" align="center" color="#FFFF00" width="2.4" scale="0.55 0.55 0.55"></a-text>
  <a-text id="infoDisplay" position="-0.1 -0.07 0.06" value="" align="center" color="#00FFAA" width="6.0" scale="0.30 0.30 0.30"></a-text>
    <a-entity id="stepButtons" position="0 -0.65 0.05"></a-entity>
      <a-entity id="transport" position="-1.75 -0.39 0.05"></a-entity>
      <a-entity id="leftButtons" position="-1.30 -0.55 0.05"></a-entity>
      <a-entity id="drumButtons" position="-0.85 -0.36 0.05"></a-entity>


<!-- Piano Plinth (colored base matching track) -->
<!-- Piano Plinth (colored base matching track) - COUNTER-ROTATED -->
<a-box id="pianoPlinth"
       position="-0.2 -1.1 0.31"
       width="3.45"
       height="0.13"
       depth="0.50"
       rotation="30 0 0"
       color="#2a2a4e"
       material="metalness:0.5;roughness:0.3;opacity:1.0;transparent:false"
       shadow="cast:true;receive:true"></a-box>

<!-- Piano Keys (raised up) -->
<a-entity id="pianoKeys" position="-1.82 -0.9 0.15" rotation="0 0 0"></a-entity>
     
      <a-entity id="soundSelector" position="0.76 0.12 0.05"></a-entity>
    </a-entity>

    <a-entity id="glassTable" position="-0.04 2.42 -0.38">
  <!-- Glass tabletop -->
  <a-box width="0.9" height="0.04" depth="0.4" position="0 0 0" color="#888888" material="metalness:0.95;roughness:0.1;transparent:true;opacity:0.8" shadow="receive:true"></a-box>
 
  <!-- Table legs -->
  <a-cylinder radius="0.035" height="0.45" position="-0.41 -0.225 0.17" color="#333333" material="metalness:0.8;roughness:0.2" shadow="cast:true"></a-cylinder>
  <a-cylinder radius="0.035" height="0.45" position="0.41 -0.225 0.17" color="#333333" material="metalness:0.8;roughness:0.2" shadow="cast:true"></a-cylinder>
  <a-cylinder radius="0.035" height="0.45" position="-0.41 -0.225 -0.17" color="#333333" material="metalness:0.8;roughness:0.2" shadow="cast:true"></a-cylinder>
  <a-cylinder radius="0.035" height="0.45" position="0.41 -0.225 -0.17" color="#333333" material="metalness:0.8;roughness:0.2" shadow="cast:true"></a-cylinder>
 
  <!-- Fake shadows under each leg -->
 
 
  <!-- Main shadow plane under entire table -->
  <a-plane width="1.0" height="0.5" position="0 -0.45 0" rotation="-90 0 0" color="#000000" material="opacity:0.7;transparent:true;shader:flat"></a-plane>
</a-entity>
  </a-scene>

<script>
// ============================================================================
// MOBILE 5000 VR SEQUENCER v5.4 - LATEST UPDATES
// ============================================================================
console.log('');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('  üéπ MOBILE 5000 VR SEQUENCER v5.4');
console.log('  üìÖ Updated: January 2026');
console.log('  ‚ú® New: HUD repositioned, drum buttons resized');
console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
console.log('');
console.log('‚úÖ Mobile 5000 VR Sequencer v5.4 - Loading...');

// ============================================================================
// SECTION 1: CONFIGURATION & CONSTANTS
// ============================================================================
const SYNTH_TILT = -30;
let currentMode = 'desktop';

const skyboxUrls = [
  'https://raw.githubusercontent.com/pixelblip/robot/main/1%20(1).jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/2.jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/3%20(1).jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/4%20(1).jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/5%20(1).jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/6.jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/7.jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/8.jpg',
  'https://raw.githubusercontent.com/pixelblip/robot/main/9.jpg'
];


const GH_RAW_BASE = 'https://raw.githubusercontent.com/pixelblip/vrsequencer/main/';

const SOUNDSETS = [
  {
    name: 'M5000 V1',
    folder: 'bank1',
    baseUrl: `${GH_RAW_BASE}/bank1`
  },
  {
    name: 'M5000 V2',
    folder: 'bank2',
    baseUrl: `${GH_RAW_BASE}/bank2`
  },
  {
    name: 'G.M',
    folder: 'bank3',
    baseUrl: `${GH_RAW_BASE}/bank3`
  },
  {
    name: 'CASIO',
    folder: 'bank4',
    baseUrl: `${GH_RAW_BASE}/bank4`
  },
  {
    name: 'PSR',
    folder: 'bank5',
    baseUrl: `${GH_RAW_BASE}/bank5`
  },
  {
    name: 'MAUDIO',
    folder: 'bank6',
    baseUrl: `${GH_RAW_BASE}/bank6`
  },
  {
    name: 'AMBIENT',
    folder: 'bank7',
    baseUrl: `${GH_RAW_BASE}/bank7`
  },
  {
    name: 'CASIO',
    folder: 'bank8',
    baseUrl: `${GH_RAW_BASE}/bank8`
  }
];



const trackNames = ['DRUMS', 'BASS', 'LEAD', 'PAD', 'ARP'];
const trackColors = ['#DD3333', '#CC3333', '#CC8822', '#33CC55', '#3399DD'];
//                    DRUMS     BASS      LEAD      PAD       ARP
//                    RED       RED       ORANGE    GREEN     CYAN
//                    DRUMS     BASS      LEAD      PAD       ARP
//                    RED       BLUE      ORANGE    GREEN     YELLOW
//                    DRUMS     BASS      LEAD      PAD       ARP
const trackBodyColors = ['#4a2a2a', '#4a1a1a', '#4a3a2a', '#2a4a3a', '#1a3a4a'];
//                        DRUMS     BASS      LEAD      PAD       ARP
//                        DRK RED   DRK RED   DRK ORA   DRK GRN   DRK CYAN
//                        DRUMS     BASS      LEAD      PAD       ARP
const drumColors = ['#DD3333', '#DD8833', '#33AADD', '#AA55DD'];
const purple = '#9b5cff';
const rainbow = ['#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#0000FF', '#4B0082', '#9400D3'];

const chordRoots = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
const chordTypes = ['MAJ', 'MIN', 'DIM', 'AUG', '7TH', 'M7', 'SUS2', 'SUS4'];
const arpPatterns = ['UP', 'DOWN', 'U/D', 'RAND', 'RHY1', 'RHY2', 'RHY3', 'RHY4'];

const chordIntervals = {
  MAJ: [0, 4, 7], MIN: [0, 3, 7], DIM: [0, 3, 6], AUG: [0, 4, 8],
  '7TH': [0, 4, 7, 10], M7: [0, 3, 7, 10], SUS2: [0, 2, 7], SUS4: [0, 5, 7]
};

const chordColors = [
  '#FF6666', '#FF9966', '#FFCC66', '#FFFF66', '#CCFF66', '#99FF66',
  '#66FF99', '#66FFCC', '#66FFFF', '#66CCFF', '#6699FF', '#6666FF'
];

const patternColors = [
  '#334455', '#FF5555', '#55FF55', '#5555FF', '#FFFF55', '#FF55FF',
  '#55FFFF', '#FF8855', '#88FF55', '#5588FF', '#FF5588', '#88FF88',
  '#8888FF', '#FFAA55', '#55FFAA', '#AA55FF', '#FFAAAA'
];
const arpTimeSubdivisions = ['1/32', '1/16T', '1/16', '1/8T', '1/8', '1/4'];
const genreNames = ['ROCK 8', 'ROCK 16', 'DISCO', 'FUNK', 'REGGAE', 'BOSSA', 'TECHNO', 'GOSPEL'];
const strumPatterns = [
  'DOWN', 'UP', 'D-DU', 'D-DUDU', 'FOLK', 'LATIN', 'FLAM', 'RAND',
  'CALYPSO', 'WALTZ', 'SWING', 'TRIPLET', 'GALLOP', 'BOUNCE', 'ARPTREM', 'REGGAE'
];
// ============================================================================
// SECTION 2: GLOBAL STATE & DATA STRUCTURES
// ============================================================================

let audioContext, masterGain, analyser, dataArray;
let mediaRecorder = null;
let recordedChunks = [];
let audioDestination = null;
let audioInitialized = false;
let oscilloscopeBars = [];
let velocityBars = [];
let activeSources = [];
let scheduleAheadTime = 0.1;
let nextNoteTime = 0;
let timerWorker = null;
let demoSongs = [];
let keyboardEnabled = true;
window.midiAccess = null;  // ‚Üê Changed to window.midiAccess so console can access it
window.midiInputs = [];  // ‚Üê Also expose to window
window.midiInitialized = false;

const state = {
  powered: false,
  tempo: 85,
  currentBankNumber: 1,
  currentPattern: 0,
  currentTrack: 1,
  currentStepView: 0,
  highlightedStep: 0,
  selectedDrum: 'kick',
  octave: 3,
  isPlaying: false,
  isRecording: false,
  currentStep: 0,
    quantize: 0,
  stepTimer: 0,
  trackVolumes: [0.8, 1.0, 0.9, 0.9, 0.3],
  trackPans: [0, 0, 0, 0, 0],
  drumVolumes: [0.81, 0.81, 0.05, 0.225],
  drumPans: [0, 0, 0, 0],
  arrangementMode: false,
  songArrangement: new Array(64).fill(0),
  currentArrangementIndex: 0,
  playSinglePattern: false,
  soundIndex: { bass: 0, lead: 0, pad: 0, arp: 0 },
  skin: { synthBody: '#2a2a4e', skyboxUrl: '' },
  arp: {
  pattern: 0,
  enabled: false,
  currentArpIndex: 0,
  mode: 0,  // 0=single note, 1=chord, 2=strum
  randomInversions: false,
  strumPattern: 0,
  timeSubdivision: 2  // Default to 1/16
},
  mixerMode: false,
  mixerSelectedTrack: 0,
  masterVolume: 0.85,
trackDecay: [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],
  mute: [false, false, false, false, false, false, false, false, false],
  solo: [false, false, false, false, false, false, false, false, false],
  tieMode: false,
  restMode: false,
  clearStepMode: false,
  copyStepMode: false,
  bassGenMode: false,
  autoBassFollow: false,
  chordMode: false,
  chordSelectedRoot: 0,
  chordSelectionRoot: null,
  chordSelectionType: null,
  chordSelectedType: 0,
  chordPattern: new Array(64).fill(null),
  playBlockMode: false,
 // patternLength: 64,
  genre: 0,
  drumSeqMode: false,
  drumSeqSelectedDrum: 0,
  echoEnabled: false,
  echoDelay: 0,
  currentDemoIndex: 0,
  currentPage: 'seq'
 
};

// ‚Üê ADD THIS LINE HERE
window.state = state;

const patterns = [];
for (let p = 0; p < 16; p++) {
  patterns.push({
      length: 64,  // ‚Üê ADD THIS LINE
    drums: {
      kick: new Array(64).fill(false),
      snare: new Array(64).fill(false),
      hihat: new Array(64).fill(false),
      open: new Array(64).fill(false)
    },
    drumVelocity: {
      kick: new Array(64).fill(1.0),
      snare: new Array(64).fill(1.0),
      hihat: new Array(64).fill(1.0),
      open: new Array(64).fill(1.0)
    },
    bass: new Array(64).fill(''),
    lead: new Array(64).fill(''),
    pad: new Array(64).fill(''),
    arp: new Array(64).fill(''),
    arpChords: new Array(64).fill(null),
    mix: new Array(64).fill(null),
    velocity: {
      bass: new Array(64).fill(0.8),
      lead: new Array(64).fill(0.8),
      pad: new Array(64).fill(0.8),
      arp: new Array(64).fill(0.8)
    }
  });
}

const GH_API_URL = 'https://api.github.com/repos/pixelblip/sequencer/contents';


// ============================================================================
// UPDATED SAMPLE BANKS - LOADING FROM LOCAL PROJECT ROOT
// ============================================================================

const SAMPLE_BANKS = {
  drums: {
    // These load from your root 'bank1' folder
    kick: './bank1/Kick.wav',
    snare: './bank1/Snare.wav',
    hihat: './bank1/hihat.wav',
    open: './bank1/Perc.wav'
  },
  bass: [
    { name: 'Bass 1', url: './bank1/Bass.wav', base: 'C4' },
    { name: 'Bass 2', url: './bank1/BASS2.wav', base: 'C4' },
    { name: 'Bass 3', url: './bank1/BASS3.wav', base: 'C4' },
    { name: 'Bass 4', url: './bank1/BASS4.wav', base: 'C4' },
    // Adding bank2 variants
    { name: 'Bass B2', url: './bank2/Bass.wav', base: 'C4' },
    { name: 'Bass 2 B2', url: './bank2/BASS2.wav', base: 'C4' }
  ],
  lead: [
    { name: 'Lead 1', url: './bank1/Lead.wav', base: 'C4' },
    { name: 'Lead 2', url: './bank1/lead2.wav', base: 'C4' },
    { name: 'Lead 3', url: './bank1/LEAD3.wav', base: 'C4' },
    { name: 'Lead 4', url: './bank1/LEAD4.wav', base: 'C4' },
    // bank2 variants
    { name: 'Lead B2', url: './bank2/Lead.wav', base: 'C4' },
    { name: 'Lead 2 B2', url: './bank2/lead2.wav', base: 'C4' }
  ],
  pad: [
    { name: 'Pad 1', url: './bank1/Pad.wav', base: 'C4' },
    { name: 'Pad 2', url: './bank1/PAD2.wav', base: 'C4' },
    { name: 'Strings 2', url: './bank1/STRINGS2.wav', base: 'C4' },
    // bank2 variants
    { name: 'Pad B2', url: './bank2/Pad.wav', base: 'C4' },
    { name: 'Strings B2', url: './bank2/STRINGS2.wav', base: 'C4' }
  ],
  arp: [
    { name: 'Arp 1', url: './bank1/Lead.wav', base: 'C4' },
    { name: 'Arp 2', url: './bank1/ARP2.wav', base: 'C4' },
    { name: 'Arp 3', url: './bank1/lead2.wav', base: 'C4' },
    // bank2 variants
    { name: 'Arp B2', url: './bank2/Lead.wav', base: 'C4' },
    { name: 'Arp 2 B2', url: './bank2/ARP2.wav', base: 'C4' }
  ]
};

let buffers = {
  drums: { kick: null, snare: null, hihat: null, open: null },
  bass: [], lead: [], pad: [], arp: []
};

let clipboard = { drums: null, track: null, block: null, songSlot: null, pattern: null, step: null, chordBlock: null, chordPattern: null };

const ui = {
  stepButtons: [],
  viewButtons: [],
  drumButtons: [],
  trackButtons: [],
  pianoKeys: [],
  allButtons: [],
  arpButtons: [],
  songSlotButtons: [],
  selectedSongSlot: 0,
  chordStepButtons: [],
  chordRootButtons: [],
  chordTypeButtons: [],
  chordPaletteButtons: [],
  chordViewButtons: [],
  drumSeqStepButtons: [[], [], [], []],
  drumSeqViewButtons: [],
  mixStepButtons: []
};

let undoStack = [];
const MAX_UNDO = 20;

const mix2State = {
  stepHasMixData: new Array(64).fill(false),
  mixData: new Array(64).fill(null)
};
// ============================================================================
// SECTION 3: AUDIO INITIALIZATION & PLAYBACK
// ============================================================================

function startMode(mode) {
  currentMode = mode;
  const startScreen = document.getElementById('startScreen');
  const scene = document.getElementById('mainScene');
  const rig = document.getElementById('rig');
  const camera = document.getElementById('mainCamera');
 
  startScreen.style.display = 'none';
  scene.style.display = 'block';
 
  if (scene.renderer) scene.resize();
  window.dispatchEvent(new Event('resize'));

  if (mode === 'vr') {
     rig.setAttribute('position', '0 2.1 0.1');
    camera.setAttribute('wasd-controls', 'enabled: true');
    camera.setAttribute('look-controls', 'enabled: true; pointerLockEnabled:true; mouseEnabled:true');
  } else {
    // Desktop mode - higher view
    rig.setAttribute('position', '0 2.7 0.1');
    camera.setAttribute('wasd-controls', 'enabled: false');
    camera.setAttribute('look-controls', 'enabled: false');
  }
 
  setTimeout(() => {
    if (!audioInitialized) initAudio();
  }, 500);
}

// ============================================================================
// MIDI INPUT SYSTEM
// ============================================================================

async function initMIDI() {
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  console.log('üéπ MIDI INIT - STARTING DIAGNOSTIC');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
 
  // Check 1: Browser support
  console.log('1Ô∏è‚É£ Checking browser support...');
  console.log('   navigator.requestMIDIAccess exists?', !!navigator.requestMIDIAccess);
 
  if (!navigator.requestMIDIAccess) {
    console.error('‚ùå CRITICAL: Web MIDI API not supported in this browser');
    console.log('   ‚ö†Ô∏è You MUST use Chrome or Edge - Firefox does NOT support MIDI');
    showMessage('‚ùå USE CHROME/EDGE FOR MIDI');
    return;
  }
 
  console.log('   ‚úÖ Browser supports Web MIDI API');
 
  // Check 2: Request access
  console.log('2Ô∏è‚É£ Requesting MIDI access from browser...');
 
  try {
window.midiAccess = await navigator.requestMIDIAccess();
    console.log('   ‚úÖ MIDI Access GRANTED by browser');
    console.log('   Access object:', midiAccess);
   
    // Check 3: Find inputs
    console.log('3Ô∏è‚É£ Scanning for MIDI input devices...');
    const inputs = midiAccess.inputs.values();
    let deviceCount = 0;
   
    for (let input of inputs) {
      deviceCount++;
      console.log(`   üì• FOUND DEVICE #${deviceCount}:`);
      console.log(`      Name: ${input.name}`);
      console.log(`      Manufacturer: ${input.manufacturer}`);
      console.log(`      ID: ${input.id}`);
      console.log(`      State: ${input.state}`);
      console.log(`      Connection: ${input.connection}`);
     
      // Attach message handler
      input.onmidimessage = handleMIDIMessage;
      midiInputs.push(input);
     
      console.log(`      ‚úÖ Message handler attached`);
    }
   
    if (deviceCount === 0) {
      console.warn('‚ö†Ô∏è NO MIDI DEVICES FOUND!');
      console.log('   Troubleshooting:');
      console.log('   1. Is your MIDI keyboard plugged in via USB?');
      console.log('   2. Is it powered on?');
      console.log('   3. Try unplugging and replugging it');
      console.log('   4. Check Windows Device Manager / macOS Audio MIDI Setup');
      showMessage('‚ö†Ô∏è NO MIDI DEVICES FOUND');
    } else {
      console.log(`   ‚úÖ Found ${deviceCount} MIDI input device(s)`);
      showMessage(`üéπ ${deviceCount} MIDI DEVICE(S) READY`);
    }
   
    // Check 4: Listen for hot-plug
    console.log('4Ô∏è‚É£ Setting up hot-plug detection...');
    midiAccess.onstatechange = (e) => {
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
      console.log(`üîå MIDI DEVICE ${e.port.state.toUpperCase()}`);
      console.log(`   Name: ${e.port.name}`);
      console.log(`   Type: ${e.port.type}`);
      console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
     
      if (e.port.type === 'input' && e.port.state === 'connected') {
        e.port.onmidimessage = handleMIDIMessage;
        if (!midiInputs.includes(e.port)) {
          midiInputs.push(e.port);
        }
        showMessage(`üéπ ${e.port.name} CONNECTED`);
      }
    };
    console.log('   ‚úÖ Hot-plug detection active');
   
    midiInitialized = true;
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('‚úÖ MIDI INITIALIZATION COMPLETE');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
   
  } catch (err) {
    console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.error('‚ùå MIDI INIT FAILED');
    console.error('   Error:', err);
    console.error('   Error name:', err.name);
    console.error('   Error message:', err.message);
    console.error('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    showMessage('‚ùå MIDI INIT FAILED');
  }
state.tableVisible = true;
state.synthShadowVisible = false;
}



function handleMIDIMessage(message) {
  const [status, note, velocity] = message.data;
  const command = status & 0xf0;
  const channel = status & 0x0f;
 
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  console.log('üéπ MIDI MESSAGE RECEIVED');
  console.log(`   Raw data: [${message.data.join(', ')}]`);
  console.log(`   Status: ${status} (0x${status.toString(16)})`);
  console.log(`   Command: ${command} (0x${command.toString(16)})`);
  console.log(`   Channel: ${channel + 1}`);
  console.log(`   Note: ${note}`);
  console.log(`   Velocity: ${velocity}`);
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
 
  // Note On (144-159)
  if (command === 144 && velocity > 0) {
    console.log('‚úÖ Processing as NOTE ON');
    handleMIDINoteOn(note, velocity);
  }
  // Note Off (128-143) or Note On with velocity 0
  else if (command === 128 || (command === 144 && velocity === 0)) {
    console.log('‚úÖ Processing as NOTE OFF');
    handleMIDINoteOff(note);
  } else {
    console.log('‚ö†Ô∏è Ignoring (not a note message)');
  }
}

function handleMIDINoteOn(midiNote, velocity) {
  const noteName = midiToNote(midiNote);
  console.log(`üéπ MIDI Note On: ${noteName} (${midiNote}) vel: ${velocity}`);
 
  // Play the note immediately
  if (state.currentTrack === 0) {
    // Map MIDI notes to drums
    const drumMap = {
      36: 'kick',  // C1
      38: 'snare', // D1
      42: 'hihat', // F#1
      46: 'open'   // A#1
    };
    const drum = drumMap[midiNote];
    if (drum) {
      playDrum(drum);
      if (state.isRecording && !state.isPlaying) {
        saveUndoState();
        patterns[state.currentPattern].drums[drum][state.highlightedStep] = true;
        state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
        updateSteps();
      }
    }
  } else {
    // Play melodic instrument
    const trackIdx = state.currentTrack - 1;
    playInstrument(trackIdx, noteName);
    flashPianoKeyByNote(noteName, state.currentTrack);
   
    // Record if recording mode is on
    if (state.isRecording && !state.isPlaying) {
      saveUndoState();
      const trackKey = ['bass', 'lead', 'pad', 'arp'][trackIdx];
      patterns[state.currentPattern][trackKey][state.highlightedStep] = noteName;
      patterns[state.currentPattern].velocity[trackKey][state.highlightedStep] = velocity / 127;
      state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
      const newView = Math.floor(state.highlightedStep / 16);
      if (newView !== state.currentStepView) state.currentStepView = newView;
      updateSteps();
    }
  }
}

function handleMIDINoteOff(midiNote) {
  // Note off handling (if needed for held notes)
  console.log(`üéπ MIDI Note Off: ${midiToNote(midiNote)}`);
}

function rateFor(note, baseNote = 'C4') {
  const noteToMidi = (n) => {
    const noteMap = { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 };
    const match = n.match(/^([A-G]#?)(-?\d+)$/);
    if (!match) return 60;
    const [, noteName, octave] = match;
    return (parseInt(octave) + 1) * 12 + noteMap[noteName];
  };
  const targetMidi = noteToMidi(note);
  const baseMidi = noteToMidi(baseNote);
  const semitones = targetMidi - baseMidi;
  return Math.pow(2, semitones / 12);
}

function midiOf(note) {
  const noteMap = { 'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5, 'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11 };
  const match = note.match(/^([A-G]#?)(-?\d+)$/);
  if (!match) return 60;
  const [, noteName, octave] = match;
  return (parseInt(octave) + 1) * 12 + noteMap[noteName];
}




function midiToNote(midiNum) {
  const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const octave = Math.floor(midiNum / 12) - 1;
  const noteName = noteNames[midiNum % 12];
  return noteName + octave;
}

function transposeNote(note, semitones) {
  if (!note || note === '-' || note === '^' || note === '/' || note === 'REST' || note === 'TIE') return note;
  const midi = midiOf(note);
  const newMidi = Math.max(0, Math.min(127, midi + semitones));
  return midiToNote(newMidi);
}

// MIDI Export Function
function exportToMIDI() {
  try {
    console.log('üéπ Exporting to MIDI...');
   
    // Simple MIDI file builder
    const ppq = 480; // Pulses per quarter note
    const tempo = state.tempo;
    const microsecondsPerBeat = Math.floor(60000000 / tempo);
   
    // MIDI header
    const header = [
      0x4D, 0x54, 0x68, 0x64, // "MThd"
      0x00, 0x00, 0x00, 0x06, // Header length
      0x00, 0x01, // Format 1 (multiple tracks)
      0x00, 0x05, // 5 tracks (drums + 4 instruments)
      (ppq >> 8) & 0xFF, ppq & 0xFF // Ticks per quarter note
    ];
   
    const tracks = [];
   
    // Helper to create variable length value
    const varLen = (val) => {
      if (val < 128) return [val];
      const bytes = [];
      bytes.unshift(val & 0x7F);
      val >>= 7;
      while (val > 0) {
        bytes.unshift((val & 0x7F) | 0x80);
        val >>= 7;
      }
      return bytes;
    };
   
    // Create track for each instrument
    const trackNames = ['Drums', 'Bass', 'Lead', 'Pad', 'Arp'];
    const channels = [9, 0, 1, 2, 3]; // Channel 9 is drums
   
    for (let trackIdx = 0; trackIdx < 5; trackIdx++) {
      const trackEvents = [];
     
      // Track name
      const name = trackNames[trackIdx];
      trackEvents.push(...[0x00, 0xFF, 0x03, name.length, ...name.split('').map(c => c.charCodeAt(0))]);
     
      // Tempo (only in first track)
      if (trackIdx === 0) {
        trackEvents.push(...[
          0x00, 0xFF, 0x51, 0x03,
          (microsecondsPerBeat >> 16) & 0xFF,
          (microsecondsPerBeat >> 8) & 0xFF,
          microsecondsPerBeat & 0xFF
        ]);
      }
     
      // Add notes from all patterns in song arrangement
      let currentTick = 0;
      const ticksPerStep = ppq / 4; // 16th notes
     
      for (let arrIdx = 0; arrIdx < 64; arrIdx++) {
        const patNum = state.songArrangement[arrIdx];
        if (patNum === 0) break;
       
        const pat = patterns[patNum - 1];
       
        for (let step = 0; step < 64; step++) {
          const deltaTime = varLen(step === 0 && arrIdx === 0 ? 0 : ticksPerStep);
         
          if (trackIdx === 0) {
            // Drums
            const drumMap = { kick: 36, snare: 38, hihat: 42, open: 46 };
            ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
              if (pat.drums[drum][step]) {
                const note = drumMap[drum];
                const vel = Math.floor((pat.drumVelocity[drum][step] || 1.0) * 100);
                trackEvents.push(...deltaTime, 0x99, note, vel); // Note on
                trackEvents.push(...varLen(ticksPerStep - 10), 0x89, note, 0); // Note off
              }
            });
          } else {
            // Melodic instruments
            const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][trackIdx];
            const noteStr = pat[trackKey][step];
            if (noteStr && noteStr !== '-' && noteStr !== '^' && noteStr !== '/') {
              const midiNote = midiOf(noteStr);
              const vel = Math.floor((pat.velocity[trackKey][step] || 0.8) * 100);
              const channel = channels[trackIdx];
              trackEvents.push(...deltaTime, 0x90 | channel, midiNote, vel); // Note on
              trackEvents.push(...varLen(ticksPerStep - 10), 0x80 | channel, midiNote, 0); // Note off
            }
          }
         
          currentTick += ticksPerStep;
        }
      }
     
      // End of track
      trackEvents.push(...[0x00, 0xFF, 0x2F, 0x00]);
     
      // Build track chunk
      const trackHeader = [
        0x4D, 0x54, 0x72, 0x6B, // "MTrk"
        (trackEvents.length >> 24) & 0xFF,
        (trackEvents.length >> 16) & 0xFF,
        (trackEvents.length >> 8) & 0xFF,
        trackEvents.length & 0xFF
      ];
     
      tracks.push([...trackHeader, ...trackEvents]);
    }
   
    // Combine all tracks
    const midiData = new Uint8Array([...header, ...tracks.flat()]);
   
    // Download
    const blob = new Blob([midiData], { type: 'audio/midi' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'mobile5000_song.mid';
    a.click();
    URL.revokeObjectURL(url);
   
    showMessage('üíæ MIDI EXPORTED');
    console.log('‚úÖ MIDI export complete');
  } catch (err) {
    console.error('‚ùå MIDI export failed:', err);
    showMessage('‚ùå MIDI EXPORT FAILED');
  }
}


async function initAudio() {
  if (audioInitialized) {
    console.log('‚úÖ Audio already initialized');
    return;
  }
  console.log('üéµ Initializing audio system...');
  try {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioContext = new AudioContext();
    console.log('  AudioContext created, state:', audioContext.state);
    if (audioContext.state === 'suspended') {
      await audioContext.resume();
      console.log('  AudioContext resumed');
    }
    masterGain = audioContext.createGain();
    masterGain.gain.value = 0.8;
    masterGain.connect(audioContext.destination);
    console.log('  Master gain created');
    analyser = audioContext.createAnalyser();
analyser.fftSize = 128;  // Smaller = more responsive
analyser.smoothingTimeConstant = 0.6;  // Less smoothing = more reactive
analyser.minDecibels = -90;  // Lower threshold
analyser.maxDecibels = -10;  // Higher ceiling for more range
masterGain.connect(analyser);
const bufferLength = analyser.frequencyBinCount;
dataArray = new Uint8Array(bufferLength);
console.log('  Analyser created with enhanced sensitivity');
    console.log('  Analyser created');
    audioInitialized = true;
    console.log('  Loading samples...');
    await loadAllSamples();
    console.log('‚úÖ Audio initialization complete!');
  } catch (err) {
    console.error('‚ùå Audio initialization failed:', err);
    throw err;
  }
}

async function loadInstrumentBank(type, index) {
  console.log(`üì¶ Loading ${type} bank[${index}]...`);
  if (!SAMPLE_BANKS[type] || !SAMPLE_BANKS[type][index]) {
    console.error(`‚ùå No bank definition for ${type}[${index}]`);
    return;
  }
  const bank = SAMPLE_BANKS[type][index];
  const url = bank.url || bank.file;
  try {
    console.log(`  Fetching: ${url}`);
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const arrayBuffer = await response.arrayBuffer();
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    if (!buffers[type]) buffers[type] = [];
    buffers[type][index] = audioBuffer;
    console.log(`  ‚úÖ Loaded ${type}[${index}]: ${bank.name}`);
  } catch (err) {
    console.error(`  ‚ùå Failed to load ${type}[${index}]:`, err);
  }
}




async function loadDrumSamples() {
  console.log('ü•Å Loading drum samples...');
  if (!buffers.drums) buffers.drums = {};
 
  const loadPromises = [];
 
  for (const [drum, url] of Object.entries(SAMPLE_BANKS.drums)) {
    const promise = (async () => {
      try {
        console.log(`  Fetching ${drum}: ${url}`);
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
        buffers.drums[drum] = audioBuffer;
        console.log(`  ‚úÖ Loaded ${drum}`);
      } catch (err) {
        console.error(`  ‚ùå Failed to load ${drum}:`, err);
      }
    })();
    loadPromises.push(promise);
  }
 
  return Promise.all(loadPromises);
}

async function loadAllSamples() {
  console.log('üì¶ Loading all samples...');
  try {
    await Promise.all([
      loadInstrumentBank('bass', 0),
      loadInstrumentBank('lead', 0),
      loadInstrumentBank('pad', 0),
      loadInstrumentBank('arp', 0),
      loadDrumSamples()
    ]);
    console.log('‚úÖ All samples loaded!');
  } catch (err) {
    console.error('‚ùå Sample loading failed:', err);
  }
}

function playBuffer(buf, { gain = 1, pan = 0, rate = 1, decay = 1, startTime = 0 } = {}) {
  if (!audioInitialized || !buf) {
    console.warn('‚ö†Ô∏è Audio not initialized or buffer missing');
    return;
  }
  const src = audioContext.createBufferSource();
  src.buffer = buf;
  const g = audioContext.createGain();
  const when = startTime || audioContext.currentTime;
  const duration = buf.duration * decay;
  g.gain.setValueAtTime(gain, when);
  g.gain.linearRampToValueAtTime(0.001, when + duration);
  const p = audioContext.createStereoPanner ? audioContext.createStereoPanner() : null;
  if (p) {
    p.pan.value = Math.max(-1, Math.min(1, pan));
    src.connect(g);
    g.connect(p);
    p.connect(masterGain);
  } else {
    src.connect(g);
    g.connect(masterGain);
  }
  src.playbackRate.value = rate;
  src.start(when);
  src.stop(when + duration);
  activeSources.push(src);
  src.addEventListener('ended', () => {
    const i = activeSources.indexOf(src);
    if (i >= 0) activeSources.splice(i, 1);
    try { src.disconnect(); } catch (_) {}
  });
  if (activeSources.length > 50) {
    const old = activeSources.shift();
    try { old.stop(); old.disconnect(); } catch (_) {}
  }
}

function playInstrument(trackIdx, note, customVelocity = null) {
  if (!note || note === '-' || note === '^' || note === 'REST' || note === 'TIE') return;
  // MIDI OUTPUT
  if (state.midiOutEnabled) {
    const midiChannels = [2, 1, 3, 4]; // bass, lead, pad, arp
    const midiNote = midiOf(note);
    sendMIDINote(midiChannels[trackIdx], midiNote, 100);
  }
  if (!note || note === '-' || note === '^' || note === 'REST' || note === 'TIE') return;
  console.log(`üéµ Playing: ${note} on track ${trackIdx}`);
  const names = ['bass', 'lead', 'pad', 'arp'];
  const type = names[trackIdx] || 'bass';
  const sel = state.soundIndex[type] ?? 0;
  const entry = SAMPLE_BANKS[type][sel];
  console.log(`  Type: ${type}, Sound Index: ${sel}, Entry:`, entry);
  console.log(`  Buffer exists:`, buffers[type] && buffers[type][sel] ? 'YES' : 'NO');
  const volume = state.trackVolumes[trackIdx + 1] || 0.9;
  const pan = (state.trackPans[trackIdx + 1] || 0) / 7;
  const trackKey = names[trackIdx];
 
  // Safe velocity access - use default if pattern data not available
 // Use custom velocity if provided, otherwise read from pattern
let velocity = 0.8;
if (customVelocity !== null) {
  velocity = customVelocity;
} else {
  try {
    if (patterns[state.currentPattern] &&
        patterns[state.currentPattern].velocity &&
        patterns[state.currentPattern].velocity[trackKey]) {
      velocity = patterns[state.currentPattern].velocity[trackKey][state.currentStep] || 0.8;
    }
  } catch (e) {
    console.warn('Could not access velocity, using default');
  }
}
 
  const finalVol = volume * velocity;
  const decay = state.trackDecay[trackIdx + 1] || 1.0;
  if (buffers[type] && buffers[type][sel]) {
    console.log(`  ‚úÖ Playing buffer for ${type}`);
    playBuffer(buffers[type][sel], { gain: finalVol, pan, rate: rateFor(note, entry.base || 'C4'), decay: decay });
  } else {
    console.error(`  ‚ùå Buffer missing for ${type}[${sel}]`);
  }
  // Only flash if this is the currently selected track
  if (state.currentTrack === trackIdx + 1) {
    flashPianoKeyByNote(note, trackIdx + 1);
  }
}

function playDrum(drumName) {
 if (window.FM?.enabled) {
    return window.playFMDrum(drumName);
  }
  if (!audioInitialized) {
    console.warn('‚ö†Ô∏è Audio not initialized');
    return;

  }
  if (window.FM?.enabled) {
    return playFMDrum(drumName);
  }
  console.log(`ü•Å playDrum(${drumName})`);
 
  const currentBuffer = buffers.drums[drumName];
  console.log(`   Buffer exists: ${!!currentBuffer}`);
 
  if (!currentBuffer) {
    console.error(`‚ùå Drum buffer ${drumName} not loaded!`);
    return;
  }
 
  if (state.midiOutEnabled) {
    const drumMidiMap = { kick: 36, snare: 38, hihat: 42, open: 46 };
    sendMIDINote(9, drumMidiMap[drumName], 100);
  }
 
  const drumIndex = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
  if (drumIndex === -1) return;
 
  // ‚úÖ USE MIXER STATE VALUES
  const volume = state.drumVolumes[drumIndex] || 0.9;
  const pan = (state.drumPans[drumIndex] || 0) / 7;
 
  let velocity = 1.0;
  try {
    if (patterns[state.currentPattern] &&
        patterns[state.currentPattern].drumVelocity &&
        patterns[state.currentPattern].drumVelocity[drumName]) {
      velocity = patterns[state.currentPattern].drumVelocity[drumName][state.currentStep] || 1.0;
    }
  } catch (e) {
    console.warn('Could not access drum velocity, using default');
  }
 
  console.log(`   Playing with volume=${volume}, velocity=${velocity}, pan=${pan}`);
  playBuffer(buffers.drums[drumName], { gain: volume * velocity, pan });
 
  if (state.currentTrack === 0) {
    const drumNoteMap = { 'kick': 'C3', 'snare': 'D3', 'hihat': 'E3', 'open': 'F3' };
    flashPianoKeyByNote(drumNoteMap[drumName], 0);
  }
}

function playInstrument(trackIdx, note, customVelocity = null) {
  if (!note || note === '-' || note === '^' || note === 'REST' || note === 'TIE') return;
 
  // FM MODE CHECK - STOP SAMPLE PLAYBACK IN FM MODE
  if (window.FM?.enabled) {
    return window.playFMInstrument(trackIdx, note, customVelocity || 0.8);
  }
  if (state.midiOutEnabled) {
    const midiChannels = [2, 1, 3, 4];
    const midiNote = midiOf(note);
    sendMIDINote(midiChannels[trackIdx], midiNote, 100);
  }
 
  console.log(`üéµ Playing: ${note} on track ${trackIdx}`);
  const names = ['bass', 'lead', 'pad', 'arp'];
  const type = names[trackIdx] || 'bass';
  const sel = state.soundIndex[type] ?? 0;
  const entry = SAMPLE_BANKS[type][sel];
  console.log(`  Type: ${type}, Sound Index: ${sel}, Entry:`, entry);
  console.log(`  Buffer exists:`, buffers[type] && buffers[type][sel] ? 'YES' : 'NO');
 
  // ‚úÖ USE MIXER STATE VALUES (trackIdx + 1 because drums are at 0)
  const volume = state.trackVolumes[trackIdx + 1] || 0.9;
  const pan = (state.trackPans[trackIdx + 1] || 0) / 7;
  const trackKey = names[trackIdx];
 
  let velocity = 0.8;
  if (customVelocity !== null) {
    velocity = customVelocity;
  } else {
    try {
      if (patterns[state.currentPattern] &&
          patterns[state.currentPattern].velocity &&
          patterns[state.currentPattern].velocity[trackKey]) {
        velocity = patterns[state.currentPattern].velocity[trackKey][state.currentStep] || 0.8;
      }
    } catch (e) {
      console.warn('Could not access velocity, using default');
    }
  }
 
  const finalVol = volume * velocity;
  const decay = state.trackDecay[trackIdx + 1] || 1.0;
 
  if (buffers[type] && buffers[type][sel]) {
    console.log(`  ‚úÖ Playing buffer for ${type} with vol=${finalVol.toFixed(2)}, pan=${pan.toFixed(2)}`);
    playBuffer(buffers[type][sel], { gain: finalVol, pan, rate: rateFor(note, entry.base || 'C4'), decay: decay });
  } else {
    console.error(`  ‚ùå Buffer missing for ${type}[${sel}]`);
  }
 
  if (state.currentTrack === trackIdx + 1) {
    flashPianoKeyByNote(note, trackIdx + 1);
  }
}

function playInstrumentScheduled(trackIdx, note, startTime, stepVelocity = 0.8) {
  if (!note || note === '-' || note === '^' || note === 'REST' || note === 'TIE') return;

  if (window.FM?.enabled) {
    // For scheduled playback, we need to play it immediately since FM synths don't support scheduling
    return window.playFMInstrument(trackIdx, note, stepVelocity);
  }
 
  const names = ['bass', 'lead', 'pad', 'arp'];
  const type = names[trackIdx] || 'bass';
  const sel = state.soundIndex[type] ?? 0;
  const entry = SAMPLE_BANKS[type][sel];
  if (!buffers[type] || !buffers[type][sel]) return;
  const volume = state.trackVolumes[trackIdx + 1] || 0.9;
  const pan = (state.trackPans[trackIdx + 1] || 0) / 7;
  const decay = state.trackDecay[trackIdx + 1] || 1.0;
 
  // ‚Üê ADD THIS DEBUG LINE
  if (type === 'arp') {
    console.log(`üéµ ARP decay: ${decay} (trackIdx=${trackIdx}, trackIdx+1=${trackIdx+1})`);
  }
 
  playBuffer(buffers[type][sel], {
    gain: volume * stepVelocity,
    pan: pan,
    rate: rateFor(note, entry.base || 'C4'),
    decay: decay,
    startTime: startTime
  });
  if (state.currentTrack === trackIdx + 1) {
    flashPianoKeyByNote(note, trackIdx + 1);
  }
}

function playDrumScheduled(drumName, startTime, drumVel = 1.0) {
   if (window.FM?.enabled) {
    return window.playFMDrum(drumName);
  }
  if (!audioInitialized || !buffers.drums || !buffers.drums[drumName]) return;
  const drumIndex = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
  if (drumIndex === -1) return;
  const volume = state.drumVolumes[drumIndex] || 0.9;
  const pan = (state.drumPans[drumIndex] || 0) / 7;
  const decay = state.trackDecay[0] || 1.0;  // ‚Üê ADD THIS LINE - use trackDecay[0] for drums
 
  playBuffer(buffers.drums[drumName], {
    gain: volume * drumVel,
    pan: pan,
    decay: decay,  // ‚Üê ADD THIS LINE
    startTime: startTime
  });
}

function stopAllSources() {
  activeSources.forEach(src => {
    try {
      src.stop();
      src.disconnect();
    } catch (e) {}
  });
  activeSources = [];
}

function flashPianoKeyByNote(note, trackIndex) {
  if (!ui.pianoKeys || ui.pianoKeys.length === 0) return;
 
  // 1. Find the key button
  const keyBtn = ui.pianoKeys.find(btn => btn.dataset.note === note);
  if (!keyBtn) return;

  // 2. Determine Color - USE MIXER COLORS DIRECTLY
  let flashColor = '#FFFFFF';
 
  // **CRITICAL FIX: If on mixer page, use mixerSelectedTrack**
  if (state.currentPage === 'mix' && state.mixerSelectedTrack !== undefined) {
    const mixerColors = ['#DD3333', '#DD8833', '#33AADD', '#AA55DD', '#CC3333', '#CC8822', '#33CC55', '#3399DD', '#9b5cff'];
    //                    KICK      SNARE     HIHAT     OPEN      BASS      LEAD      PAD       ARP       MASTER
    flashColor = mixerColors[state.mixerSelectedTrack] || '#FFFFFF';
  } else if (trackIndex === 0) {
    // Drum colors
    const drumIdx = ['kick', 'snare', 'hihat', 'open'].indexOf(state.selectedDrum);
    flashColor = drumColors[drumIdx] || '#FF0000';
  } else {
    // Instrument colors - use trackIndex for correct indexing
    flashColor = trackColors[trackIndex] || '#FFFFFF';
  }

  const isWhite = keyBtn.dataset.isWhite === 'true';
  const originalColor = isWhite ? '#F8F8F8' : '#050508';
 
  if (keyBtn.flashTimeout) {
    clearTimeout(keyBtn.flashTimeout);
    keyBtn.flashTimeout = null;
  }

  keyBtn.setAttribute('color', flashColor);
  keyBtn.setAttribute('material', `metalness:.1;roughness:.3;emissive:${flashColor};emissiveIntensity:3.0`);
 
  // Flash the Ambilight LED
  const glowEl = document.getElementById(`glow-${note}`);
  if (glowEl) {
    glowEl.setAttribute('color', flashColor);
    glowEl.setAttribute('material', `shader:flat; transparent:true; opacity:0.6; color:${flashColor}`);
   
    if (glowEl.fadeTimeout) clearTimeout(glowEl.fadeTimeout);
   
    glowEl.fadeTimeout = setTimeout(() => {
       glowEl.setAttribute('material', 'opacity: 0');
    }, 200);
  }

  // Reset Key Logic
  keyBtn.flashTimeout = setTimeout(() => {
    keyBtn.setAttribute('color', originalColor);
    keyBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    keyBtn.setAttribute('scale', '1 1 1');
    keyBtn.flashTimeout = null;
  }, 150);
}
// ============================================================================
// SECTION 4: DEMO CONVERTER & STEP PLAYBACK
// ============================================================================

// CRITICAL: Demo format converter for old format to new format
// CRITICAL: Demo format converter for old format to new format
function convertOldDemoFormat(oldData) {
  console.log('üîÑ Converting old demo format to new format...');
 
  const newPatterns = [];
 
  // CRITICAL FIX: Sort pattern keys numerically before converting
  const patternKeys = Object.keys(oldData.patterns).sort((a, b) => parseInt(a) - parseInt(b));
 
  console.log('üìã Pattern keys in order:', patternKeys);
 
  // Convert each pattern IN ORDER
  patternKeys.forEach(patternKey => {
    const oldPattern = oldData.patterns[patternKey];
    const patternIndex = parseInt(patternKey) - 1;
   
    console.log(`  Converting pattern "${patternKey}" ‚Üí index ${patternIndex}`);
   
    newPatterns[patternIndex] = {
      length: 64,
      drums: oldPattern.drums,
      drumVelocity: {
        kick: new Array(64).fill(1.0),
        snare: new Array(64).fill(1.0),
        hihat: new Array(64).fill(1.0),
        open: new Array(64).fill(1.0)
      },
      bass: oldPattern.track1 ? oldPattern.track1.map(n => n === null ? '' : n) : new Array(64).fill(''),
      lead: oldPattern.track2 ? oldPattern.track2.map(n => n === null ? '' : n) : new Array(64).fill(''),
      pad: oldPattern.track3 ? oldPattern.track3.map(n => n === null ? '' : n) : new Array(64).fill(''),
      arp: oldPattern.track4 ? oldPattern.track4.map(n => {
        if (n === null) return '';
        if (typeof n === 'string' && n.startsWith('-')) return n.substring(1);
        return n;
      }) : new Array(64).fill(''),
      arpChords: oldPattern.chords ? oldPattern.chords.map(chord => {
        if (!chord || !Array.isArray(chord)) return null;
        const root = midiOf(chord[0]);
        return { root: root % 12, type: 0, color: chordColors[root % 12] };
      }) : new Array(64).fill(null),
      mix: new Array(64).fill(null),
      velocity: {
        bass: new Array(64).fill(0.8),
        lead: new Array(64).fill(0.8),
        pad: new Array(64).fill(0.8),
        arp: new Array(64).fill(0.8)
      }
    };
   
    // DEBUG: Check first pattern for drums
    if (patternIndex === 0) {
      const hasDrums = oldPattern.drums.kick.some(k => k);
      console.log(`  ‚ö†Ô∏è Pattern 1 has drums: ${hasDrums}`);
      console.log(`  First 8 kick steps:`, oldPattern.drums.kick.slice(0, 8));
    }
  });
 
  return {
    patterns: newPatterns,
    state: {
      tempo: oldData.tempo || 85,
      songArrangement: oldData.songArrangement || oldData.arrangement || [],
      trackVolumes: oldData.trackVolumes || [0.8, 1.0, 0.9, 0.9, 0.3],
      drumVolumes: oldData.drumVolumes || [0.81, 0.81, 0.05, 0.225],
      trackPans: oldData.trackPans ? oldData.trackPans.map(p => p > 7 ? 7 : p) : [0, 0, 0, 0, 0],
      drumPans: [0, 0, 0, 0],
      arp: {
        pattern: 0,
        enabled: false,
        currentArpIndex: 0,
        mode: 0,
        randomInversions: false,
        strumPattern: 0,
        timeSubdivision: 2
      }
    }
  };
}

function playStrummedChord(rootMidi, chordNotes, startTime, strumPattern) {
  if (!state.arp.enabled || state.arp.mode !== 2) return;
  const actualTime = startTime || audioContext.currentTime;
  const baseDelay = 0.030 + (Math.random() * 0.020);
  const shouldPlayNote = () => Math.random() > 0.1;
  switch(strumPattern) {
    case 0: // DOWN
      chordNotes.forEach((interval, idx) => {
        if (shouldPlayNote()) {
          const noteTime = actualTime + (idx * (baseDelay + (Math.random() * 0.015)));
          playInstrumentScheduled(3, midiToNote(rootMidi + interval), noteTime);
        }
      });
      break;
    case 1: // UP
      [...chordNotes].reverse().forEach((interval, idx) => {
        if (shouldPlayNote()) {
          const noteTime = actualTime + (idx * (baseDelay + (Math.random() * 0.015)));
          playInstrumentScheduled(3, midiToNote(rootMidi + interval), noteTime);
        }
      });
      break;
    default:
      chordNotes.forEach((interval, idx) => {
        playInstrumentScheduled(3, midiToNote(rootMidi + interval), actualTime + (idx * baseDelay));
      });
      break;
  }
}

function playStep() {
if (state.currentStep === 0) {
    console.log(`üé¨ NEW PATTERN STARTING - arrangementMode: ${state.arrangementMode}, currentArrangementIndex: ${state.currentArrangementIndex}`);
  }
 
  console.log(`üéµ Playing step ${state.currentStep} at tempo ${state.tempo}`);
  console.log(`üéµ Playing step ${state.currentStep} at tempo ${state.tempo}`);
  console.log(`   Pattern: ${state.currentPattern + 1}, Length: ${patterns[state.currentPattern].length}`);
  console.log(`   Arrangement mode: ${state.arrangementMode}, Slot: ${state.currentArrangementIndex + 1}`);
 
  if (state.currentStep >= patterns[state.currentPattern].length) {
    console.error('‚ùå ERROR: currentStep >= pattern length BEFORE playing!');
    return;
  }
 
  // Handle block mode wrapping
  if (state.playBlockMode) {
    const blockStart = state.currentStepView * 16;
    const blockEnd = blockStart + 15;
    if (state.currentStep > blockEnd) state.currentStep = blockStart;
  }
 
  const pat = patterns[state.currentPattern];
  const step = state.currentStep;
  const noteTime = audioContext ? audioContext.currentTime : 0;
 
  // Apply quantization settings
  const gridSizes = [0, 0.5, 1, 2, 4, 8];
  const grid = gridSizes[state.quantize];
  const quantizeActive = state.quantize > 0 && grid > 0;
 
  // Mix automation
  // Mix automation
// Mix automation - preserve last mix across patterns
// Mix automation - ALWAYS persist last mix settings
if (pat.mix && pat.mix[step]) {
  // New mix data found - apply it
  const mix = pat.mix[step];
  state.drumVolumes = [...mix.drumVolumes];
  state.drumPans = [...mix.drumPans];
  state.trackVolumes = [...mix.trackVolumes];
  state.trackPans = [...mix.trackPans];
  state.masterVolume = mix.masterVolume;
  if (masterGain) masterGain.gain.value = state.masterVolume;
 
  // Save as global "last applied mix"
  window.lastAppliedMix = {
    drumVolumes: [...mix.drumVolumes],
    drumPans: [...mix.drumPans],
    trackVolumes: [...mix.trackVolumes],
    trackPans: [...mix.trackPans],
    masterVolume: mix.masterVolume
  };
 
  console.log(`üéöÔ∏è Mix change applied at step ${step} of pattern ${state.currentPattern + 1}`);
}
// If we have a last mix saved, ensure it's still active (no "else" - always maintain)
else if (window.lastAppliedMix) {
  // Continuously maintain the last mix settings
  state.drumVolumes = [...window.lastAppliedMix.drumVolumes];
  state.drumPans = [...window.lastAppliedMix.drumPans];
  state.trackVolumes = [...window.lastAppliedMix.trackVolumes];
  state.trackPans = [...window.lastAppliedMix.trackPans];
  state.masterVolume = window.lastAppliedMix.masterVolume;
  if (masterGain) masterGain.gain.value = state.masterVolume;
}
 
  const anySolo = state.solo.some(s => s);
 
  // PLAY DRUMS - NO QUANTIZE
  ['kick', 'snare', 'hihat', 'open'].forEach((drum, idx) => {
    if (pat.drums[drum][step]) {
      const drumVel = pat.drumVelocity[drum][step] || 1.0;
      playDrumScheduled(drum, noteTime, drumVel);
    }
  });
 
  // PLAY MELODIC TRACKS
  ['bass', 'lead', 'pad', 'arp'].forEach((trackKey, idx) => {
    const trackIdx = idx + 1;
    const channelIdx = idx + 4;
    const isMuted = state.mute[channelIdx] || (anySolo && !state.solo[channelIdx]);
    if (isMuted) return;
   
    const shouldQuantizeThisTrack = quantizeActive && (state.currentTrack === trackIdx);
   
    if (shouldQuantizeThisTrack) {
      // QUANTIZE MODE - Only for currently selected track
      const blockStart = Math.floor(step / 16) * 16;
     
      for (let checkStep = blockStart; checkStep < blockStart + 16 && checkStep < patterns[state.currentPattern].length; checkStep++) {
        let note = pat[trackKey][checkStep];
        const isTie = (note === 'TIE' || note === '-');
        const isRest = (note === 'REST' || note === '^');
       
        if (trackKey === 'arp' && state.arp.enabled && pat.arpChords[checkStep]) {
          // ARP PLAYBACK with quantization
          let activeChord = pat.arpChords[checkStep];
          let activeNote = note;
         
          if (!activeChord || isTie) {
            for (let i = checkStep - 1; i >= blockStart; i--) {
              if (pat.arpChords[i] && pat.arpChords[i] !== null) {
                activeChord = pat.arpChords[i];
                activeNote = pat.arp[i];
                break;
              }
            }
          }
         
          const quantizedPos = getQuantizedStep(checkStep, blockStart, grid);
         
          if (quantizedPos === step && activeChord && !isRest) {
            const chordType = chordTypes[activeChord.type];
            let intervals = chordIntervals[chordType] || [0, 4, 7];
            let rootMidi;
            const rootNoteName = chordRoots[activeChord.root];
            rootMidi = midiOf(rootNoteName + '4');
           
            const stepVel = pat.velocity.arp[checkStep] || 0.8;
           
            if (state.arp.mode === 0) {
              const pattern = state.arp.pattern;
              let arpIndex = 0;
             
              if (pattern === 0) {
                arpIndex = state.arp.currentArpIndex % intervals.length;
              } else if (pattern === 1) {
                arpIndex = (intervals.length - 1) - (state.arp.currentArpIndex % intervals.length);
              } else if (pattern === 2) {
                const cycle = (intervals.length - 1) * 2;
                const pos = state.arp.currentArpIndex % cycle;
                arpIndex = pos < intervals.length ? pos : cycle - pos;
              } else if (pattern === 3) {
                arpIndex = Math.floor(Math.random() * intervals.length);
              }
             
              const chordNote = midiToNote(rootMidi + intervals[arpIndex]);
              playInstrumentScheduled(3, chordNote, noteTime, stepVel);
              state.arp.currentArpIndex++;
             
            } else if (state.arp.mode === 1) {
              intervals.forEach((interval, idx) => {
                const chordNote = midiToNote(rootMidi + interval);
                playInstrumentScheduled(3, chordNote, noteTime, stepVel);
              });
             
            } else if (state.arp.mode === 2) {
              playStrummedChord(rootMidi, intervals, noteTime, state.arp.strumPattern);
            }
            break;
          }
        } else if (note && note !== '' && !isRest && !isTie) {
          const quantizedPos = getQuantizedStep(checkStep, blockStart, grid);
          if (quantizedPos === step) {
            const stepVel = pat.velocity[trackKey][checkStep] || 0.8;
            playInstrumentScheduled(idx, note, noteTime, stepVel);
            break;
          }
        }
      }
    } else {
      // NO QUANTIZE - Play original positions
      let note = pat[trackKey][step];
      const isTie = (note === 'TIE' || note === '-');
      const isRest = (note === 'REST' || note === '^');
     
      if (trackKey === 'arp' && state.arp.enabled && pat.arpChords[step]) {
        let activeChord = pat.arpChords[step];
        let activeNote = note;
       
        if (!activeChord || isTie) {
          for (let i = step - 1; i >= 0; i--) {
            if (pat.arpChords[i] && pat.arpChords[i] !== null) {
              activeChord = pat.arpChords[i];
              activeNote = pat.arp[i];
              break;
            }
          }
        }
       
        if (activeChord && !isRest) {
          const chordType = chordTypes[activeChord.type];
          let intervals = chordIntervals[chordType] || [0, 4, 7];
          let rootMidi;
          const rootNoteName = chordRoots[activeChord.root];
          rootMidi = midiOf(rootNoteName + '4');
         
          const stepVel = pat.velocity.arp[step] || 0.8;
         
          if (state.arp.mode === 0) {
            const pattern = state.arp.pattern;
            let arpIndex = 0;
           
            if (pattern === 0) {
              arpIndex = state.arp.currentArpIndex % intervals.length;
            } else if (pattern === 1) {
              arpIndex = (intervals.length - 1) - (state.arp.currentArpIndex % intervals.length);
            } else if (pattern === 2) {
              const cycle = (intervals.length - 1) * 2;
              const pos = state.arp.currentArpIndex % cycle;
              arpIndex = pos < intervals.length ? pos : cycle - pos;
            } else if (pattern === 3) {
              arpIndex = Math.floor(Math.random() * intervals.length);
            }
           
            const chordNote = midiToNote(rootMidi + intervals[arpIndex]);
            playInstrumentScheduled(3, chordNote, noteTime, stepVel);
            state.arp.currentArpIndex++;
           
          } else if (state.arp.mode === 1) {
            intervals.forEach((interval, idx) => {
              const chordNote = midiToNote(rootMidi + interval);
              playInstrumentScheduled(3, chordNote, noteTime, stepVel);
            });
           
          } else if (state.arp.mode === 2) {
            playStrummedChord(rootMidi, intervals, noteTime, state.arp.strumPattern);
          }
        }
      } else if (note && note !== '' && !isRest && !isTie) {
        const stepVel = pat.velocity[trackKey][step] || 0.8;
        playInstrumentScheduled(idx, note, noteTime, stepVel);
      }
    }
  });
 
  if (state.autoBassFollow && pat.arpChords[step]) {
    const rootNote = chordRoots[pat.arpChords[step].root] + '2';
    if (!state.mute[4] && (!anySolo || state.solo[4])) {
      playInstrumentScheduled(0, rootNote, noteTime);
    }
  }
 // Add to handleButtonClick function (around line 3500):


// Add these new functions after handleButtonClick:

function runStartupSequence() {
  console.log('‚ö° POWERING ON...');
  showMessage('‚ö° SYSTEM STARTING...');
 
  // Stop pulsing and turn green
  const powerCap = document.getElementById('powerButtonCap');
  if (powerCap) {
    powerCap.classList.remove('power-button-pulse');
    powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#00FF00;emissiveIntensity:2.0;opacity:1.0;transparent:false');
    powerCap.setAttribute('color', '#00FF00');
  }
 
  // 1. Restore synth body (0ms)
  const synthBody = document.getElementById('synthBody');
  if (synthBody) {
    synthBody.setAttribute('material', 'metalness:0.5;roughness:0.3;opacity:0.85;transparent:true');
  }
 
  // 2. Speakers pulse (100ms)
  setTimeout(() => {
    animateSpeakers();
  }, 100);
 
  // 3. Oscilloscope bars rise (200ms)
  setTimeout(() => {
    if (oscilloscopeBars && oscilloscopeBars.length > 0) {
      oscilloscopeBars.forEach((bar, i) => {
        setTimeout(() => {
          bar.setAttribute('height', '0.15');
          bar.setAttribute('material', `emissive:${rainbow[i % rainbow.length]};emissiveIntensity:2.0;opacity:1.0;transparent:false`);
          setTimeout(() => {
            bar.setAttribute('height', '0.01');
            bar.setAttribute('material', `emissiveIntensity:0.6;opacity:1.0;transparent:false`);
          }, 100);
        }, i * 20);
      });
    }
  }, 200);
 
  // 4. Step buttons light up in sequence (400ms)
  setTimeout(() => {
    if (ui.stepButtons && ui.stepButtons.length > 0) {
      ui.stepButtons.forEach((btn, i) => {
        setTimeout(() => {
          btn.setAttribute('material', 'emissive:#9b5cff;emissiveIntensity:2.0;opacity:1.0;transparent:false');
          setTimeout(() => {
            btn.setAttribute('material', 'emissive:#000;emissiveIntensity:0;opacity:1.0;transparent:false');
          }, 50);
        }, i * 30);
      });
    }
  }, 400);
 
  // 5. Piano keys flash (800ms)
  setTimeout(() => {
    if (ui.pianoKeys && ui.pianoKeys.length > 0) {
      ui.pianoKeys.forEach((key, i) => {
        setTimeout(() => {
          const color = key.dataset.isWhite === 'true' ? '#FFFFFF' : '#9b5cff';
          key.setAttribute('material', `emissive:${color};emissiveIntensity:2.0;opacity:1.0;transparent:false`);
          setTimeout(() => {
            key.setAttribute('material', 'emissive:#000;emissiveIntensity:0;opacity:1.0;transparent:false');
          }, 50);
        }, i * 10);
      });
    }
  }, 800);
 
  // 6. Restore all buttons to full brightness (1000ms)
  setTimeout(() => {
    if (ui.allButtons && ui.allButtons.length > 0) {
      ui.allButtons.forEach(btn => {
        if (btn.id !== 'powerButtonCap') {
          btn.setAttribute('material', 'opacity:1.0;transparent:false');
        }
      });
    }
  }, 1000);
 
  // 7. Restore text displays (1100ms)
  setTimeout(() => {
    const infoDisplay = document.getElementById('infoDisplay');
    if (infoDisplay) {
      infoDisplay.setAttribute('opacity', '1.0');
    }
   
    const buttonFunctionDisplay = document.getElementById('buttonFunctionDisplay');
    if (buttonFunctionDisplay) {
      buttonFunctionDisplay.setAttribute('opacity', '1.0');
    }
  }, 1100);
 
  // 8. **FIX: Restore velocity bars** (1100ms)
  setTimeout(() => {
    if (velocityBars && velocityBars.length > 0) {
      velocityBars.forEach(bar => {
        bar.setAttribute('material', 'opacity:1.0;transparent:false');
      });
      updateVelocityLane(); // ‚Üê CRITICAL: Update their display
    }
  }, 1100);
 
  // 9. All lights on, system ready (1200ms)
  setTimeout(() => {
    updateUI();
    showMessage('‚úÖ SYSTEM READY');
  }, 1200);
}

function powerDown() {
  console.log('‚ö° POWERING OFF...');
  showMessage('‚èπ SHUTTING DOWN...');
 
  // Stop playback
  state.isPlaying = false;
  stopAllSources();
 
  // Dim all buttons
  ui.allButtons.forEach(btn => {
    btn.setAttribute('material', 'emissive:#000;emissiveIntensity:0;opacity:0.3;transparent:true');
  });
 
  // Dim piano keys
  if (ui.pianoKeys) {
    ui.pianoKeys.forEach(key => {
      key.setAttribute('material', 'opacity:0.3;transparent:true');
    });
  }
 
  // Turn power button red and pulsing
  const powerCap = document.getElementById('powerButtonCap');
  if (powerCap) {
    powerCap.setAttribute('color', '#FF0000');
    powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#FF0000;emissiveIntensity:2.0');
    powerCap.classList.add('power-pulse');
  }
 
  showMessage('‚ö´ POWERED OFF');
}

// Modify the window.addEventListener('load') section (around line 4200):
window.addEventListener('load', () => {
  console.log('üåê Page loaded - auto-starting desktop mode...');
 
  // Auto-start in desktop mode with power ON
  setTimeout(() => {
    startMode('desktop');
   
    // Auto-power on
    setTimeout(() => {
      state.powered = true;
      runStartupSequence();
    }, 500);
  }, 100);
});

// Modify buildUI() to respect powered state:
function buildUI() {
  console.log('üé® Building main UI...');
 
  // ... existing buildUI code ...
 
  // At the END of buildUI(), add:
  if (!state.powered) {
    // Start with everything dimmed
    ui.allButtons.forEach(btn => {
      btn.setAttribute('material', 'opacity:0.3;transparent:true;emissive:#000;emissiveIntensity:0');
    });
   
    if (ui.pianoKeys) {
      ui.pianoKeys.forEach(key => {
        key.setAttribute('material', 'opacity:0.3;transparent:true');
      });
    }
  }
}
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STEP ADVANCEMENT - HAPPENS AFTER PLAYING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
console.log(`‚¨ÜÔ∏è BEFORE increment: currentStep = ${state.currentStep}`);

// Increment FIRST
state.currentStep++;

console.log(`‚¨ÜÔ∏è AFTER increment: currentStep = ${state.currentStep}`);
console.log(`üìè Pattern length = ${patterns[state.currentPattern].length}`);

// Check if we've NOW reached the end (after increment)
// Use > instead of >= so we complete all 64 steps (0-63)
if (state.currentStep > patterns[state.currentPattern].length - 1) {
  console.log(`‚úÖ‚úÖ‚úÖ PATTERN COMPLETE! Step ${state.currentStep} reached end of pattern ${state.currentPattern + 1} (length ${patterns[state.currentPattern].length})`);
 
  // Pattern completed
  state.currentStep = 0;
  console.log(`üîÑ Reset currentStep to 0`);
 
  // If in arrangement mode, move to next pattern in song
  if (state.arrangementMode) {
    console.log(`üéº ARRANGEMENT MODE ACTIVE`);
    console.log(`   Current slot: ${state.currentArrangementIndex}`);
    console.log(`   Current pattern: ${state.currentPattern + 1}`);
   
    state.currentArrangementIndex++;
    console.log(`   ‚è≠Ô∏è Incremented to slot: ${state.currentArrangementIndex}`);
   
    // Get next pattern number
    const nextPatNum = state.songArrangement[state.currentArrangementIndex];
    console.log(`   üìã Song arrangement[${state.currentArrangementIndex}] = ${nextPatNum}`);
   
    // If we hit an empty slot (0) or end of arrangement (64), stop or loop
    if (!nextPatNum || state.currentArrangementIndex >= 64) {
      console.log(`   üèÅ END OF SONG - STOPPING`);
      state.isPlaying = false;
      state.arrangementMode = false;
      showMessage('üéµ SONG ENDED');
      return;
    }
   

// MISC PAGE TRANSPORT CONTROLS

    // Valid pattern found, load it
    console.log(`   ‚úÖ Valid pattern number found: ${nextPatNum}`);
    console.log(`   BEFORE: state.currentPattern = ${state.currentPattern + 1}`);
    state.currentPattern = nextPatNum - 1;
    console.log(`   AFTER: state.currentPattern = ${state.currentPattern + 1}`);
    console.log(`   NEW pattern length = ${patterns[state.currentPattern].length}`);
  } else {
    console.log(`üîÅ Not in arrangement mode - pattern will loop`);
  }
} else {
  console.log(`‚è© Pattern continues - step ${state.currentStep} of ${patterns[state.currentPattern].length}`);
}
 
  updateSongProgress();
  animateSpeakers();
}


// Speaker animation function
function animateSpeakers() {
  // Get all speaker elements
  const leftElements = ['leftSpeakerRim', 'leftSpeakerRing1', 'leftSpeakerRing2', 'leftSpeakerRing3', 'leftSpeakerRing4', 'leftSpeakerRing5', 'leftSpeakerDome'];
  const rightElements = ['rightSpeakerRim', 'rightSpeakerRing1', 'rightSpeakerRing2', 'rightSpeakerRing3', 'rightSpeakerRing4', 'rightSpeakerRing5', 'rightSpeakerDome'];
 
  // Original Z positions
  const leftOriginal = [0.126, 0.127, 0.128, 0.129, 0.130, 0.131, 0.132];
  const rightOriginal = [0.126, 0.127, 0.128, 0.129, 0.130, 0.131, 0.132];
 
  // Pump all rings forward
  leftElements.forEach((id, i) => {
    const el = document.getElementById(id);
    if (el) {
      const newZ = leftOriginal[i] + 0.015;
      el.setAttribute('position', `0 0 ${newZ}`);
      // Brighten dome glow
      if (id === 'leftSpeakerDome') {
        el.setAttribute('material', 'metalness:0.8;roughness:0.2;emissive:#AA55DD;emissiveIntensity:2.5;side:double');
      }
    }
  });
 
  rightElements.forEach((id, i) => {
    const el = document.getElementById(id);
    if (el) {
      const newZ = rightOriginal[i] + 0.015;
      el.setAttribute('position', `0 0 ${newZ}`);
      // Brighten dome glow
      if (id === 'rightSpeakerDome') {
        el.setAttribute('material', 'metalness:0.8;roughness:0.2;emissive:#33AADD;emissiveIntensity:2.5;side:double');
      }
    }
  });
 
  // Return to normal after 100ms
  setTimeout(() => {
    leftElements.forEach((id, i) => {
      const el = document.getElementById(id);
      if (el) {
        el.setAttribute('position', `0 0 ${leftOriginal[i]}`);
        if (id === 'leftSpeakerDome') {
          el.setAttribute('material', 'metalness:0.8;roughness:0.2;emissive:#AA55DD;emissiveIntensity:1.0;side:double');
        }
      }
    });
   
    rightElements.forEach((id, i) => {
      const el = document.getElementById(id);
      if (el) {
        el.setAttribute('position', `0 0 ${rightOriginal[i]}`);
        if (id === 'rightSpeakerDome') {
          el.setAttribute('material', 'metalness:0.8;roughness:0.2;emissive:#33AADD;emissiveIntensity:1.0;side:double');
        }
      }
    });
  }, 100);
}

// ============================================================================
// SECTION 5: COMPLETE UI BUILDING, PAGE NAVIGATION & UPDATE FUNCTIONS
// ============================================================================

// --- CORE BUTTON CREATION FUNCTION ---
function createButton(parent, x, y, z, w, h, d, color, id, text = '', textColor = 'white', attachHandler = false) {
  const btn = document.createElement('a-box');
  btn.setAttribute('class', 'clickable');
  btn.setAttribute('position', `${x} ${y} ${z}`);
  btn.setAttribute('width', w);
  btn.setAttribute('height', h * 1.15);
  btn.setAttribute('depth', d);
  btn.setAttribute('color', color);
  btn.setAttribute('material', 'metalness:.3;roughness:.6');
  btn.setAttribute('shadow', 'cast:true;receive:true');
  btn.setAttribute('id', id);
  btn.dataset.originalColor = color;
  btn.dataset.buttonId = id;

  if (text) {
    const label = document.createElement('a-text');
    label.setAttribute('value', text);
    label.setAttribute('align', 'center');
    label.setAttribute('position', `0 0 ${d / 2 + 0.01}`);
    const scale = Math.min(0.15 * (w / 0.12), 0.18);
    label.setAttribute('scale', `${scale} ${scale} ${scale}`);
    label.setAttribute('color', textColor);
    btn.appendChild(label);
  }

  parent.appendChild(btn);
  if (typeof ui !== 'undefined' && ui.allButtons) ui.allButtons.push(btn);
  if (attachHandler) attachClickHandler(btn);
  return btn;
}

function dimEverything() {
  console.log('üåë Dimming all controls...');
 
  // Dim all buttons
  if (ui.allButtons && ui.allButtons.length > 0) {
    ui.allButtons.forEach(btn => {
      if (btn.id !== 'powerButtonCap') {
        btn.setAttribute('material', 'opacity:0.1;transparent:true;emissive:#000;emissiveIntensity:0');
      }
    });
  }
 
  // Dim piano keys
  if (ui.pianoKeys && ui.pianoKeys.length > 0) {
    ui.pianoKeys.forEach(key => {
      key.setAttribute('material', 'opacity:0.1;transparent:true;emissive:#000;emissiveIntensity:0');
    });
  }
 
  // Dim oscilloscope
  if (oscilloscopeBars && oscilloscopeBars.length > 0) {
    oscilloscopeBars.forEach(bar => {
      bar.setAttribute('material', 'opacity:0.1;transparent:true;emissive:#000;emissiveIntensity:0');
    });
  }
 
  // Dim velocity bars - MORE AGGRESSIVE
  if (velocityBars && velocityBars.length > 0) {
    console.log('üåë Dimming', velocityBars.length, 'velocity bars');
    velocityBars.forEach((bar, i) => {
      bar.setAttribute('material', 'color:#333333;opacity:0.1;transparent:true;emissive:#000;emissiveIntensity:0');
      bar.setAttribute('visible', 'true'); // Keep visible but dim
      bar.object3D.visible = true;
    });
  }
 
  // Dim text displays
  const infoDisplay = document.getElementById('infoDisplay');
  if (infoDisplay) {
    infoDisplay.setAttribute('opacity', '0.1');
  }
 
  const buttonFunctionDisplay = document.getElementById('buttonFunctionDisplay');
  if (buttonFunctionDisplay) {
    buttonFunctionDisplay.setAttribute('opacity', '0.1');
  }
 
  // Dim synth body
  const synthBody = document.getElementById('synthBody');
  if (synthBody) {
    synthBody.setAttribute('material', 'opacity:0.2;transparent:true');
  }
 
  // Ensure power button is bright and pulsing
  const powerCap = document.getElementById('powerButtonCap');
  if (powerCap) {
    powerCap.classList.add('power-button-pulse');
    powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#FF0000;emissiveIntensity:2.5;opacity:1.0;transparent:false');
  }
}

function runStartupSequence() {
  console.log('‚ö° POWERING ON...');
  showMessage('‚ö° SYSTEM STARTING...');
 
  // Stop pulsing and turn green
  const powerCap = document.getElementById('powerButtonCap');
  if (powerCap) {
    powerCap.classList.remove('power-button-pulse');
    powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#00FF00;emissiveIntensity:2.0;opacity:1.0;transparent:false');
    powerCap.setAttribute('color', '#00FF00');
  }
 
  // 1. Restore synth body (0ms)
  const synthBody = document.getElementById('synthBody');
  if (synthBody) {
    synthBody.setAttribute('material', 'metalness:0.5;roughness:0.3;opacity:0.85;transparent:true');
  }
 
  // 2. Speakers pulse (100ms)
  setTimeout(() => {
    animateSpeakers();
  }, 100);
 
  // 3. Oscilloscope bars rise (200ms)
  setTimeout(() => {
    if (oscilloscopeBars && oscilloscopeBars.length > 0) {
      oscilloscopeBars.forEach((bar, i) => {
        setTimeout(() => {
          bar.setAttribute('height', '0.15');
          bar.setAttribute('material', `emissive:${rainbow[i % rainbow.length]};emissiveIntensity:2.0;opacity:1.0;transparent:false`);
          setTimeout(() => {
            bar.setAttribute('height', '0.01');
            bar.setAttribute('material', `emissiveIntensity:0.6;opacity:1.0;transparent:false`);
          }, 100);
        }, i * 20);
      });
    }
  }, 200);
 
  // 4. Step buttons light up in sequence (400ms)
  setTimeout(() => {
    if (ui.stepButtons && ui.stepButtons.length > 0) {
      ui.stepButtons.forEach((btn, i) => {
        setTimeout(() => {
          btn.setAttribute('material', 'emissive:#9b5cff;emissiveIntensity:2.0;opacity:1.0;transparent:false');
          setTimeout(() => {
            btn.setAttribute('material', 'emissive:#000;emissiveIntensity:0;opacity:1.0;transparent:false');
          }, 50);
        }, i * 30);
      });
    }
  }, 400);
 
  // 5. Velocity bars light up in sequence (600ms) - MOVED EARLIER
  setTimeout(() => {
    console.log('‚ö° Lighting up velocity bars...');
    if (velocityBars && velocityBars.length > 0) {
      velocityBars.forEach((bar, i) => {
        setTimeout(() => {
          // Flash bright
          bar.setAttribute('material', 'emissive:#00FFAA;emissiveIntensity:3.0;opacity:1.0;transparent:false');
          bar.setAttribute('visible', 'true');
          bar.object3D.visible = true;
         
          setTimeout(() => {
            // Return to normal
            bar.setAttribute('material', 'opacity:1.0;transparent:false');
          }, 80);
        }, i * 40);
      });
     
      // Update velocity display after animation
      setTimeout(() => {
        updateVelocityLane();
      }, velocityBars.length * 40 + 100);
    }
  }, 600);
 
  // 6. Piano keys flash (800ms)
  setTimeout(() => {
    if (ui.pianoKeys && ui.pianoKeys.length > 0) {
      ui.pianoKeys.forEach((key, i) => {
        setTimeout(() => {
          const color = key.dataset.isWhite === 'true' ? '#FFFFFF' : '#9b5cff';
          key.setAttribute('material', `emissive:${color};emissiveIntensity:2.0;opacity:1.0;transparent:false`);
          setTimeout(() => {
            key.setAttribute('material', 'emissive:#000;emissiveIntensity:0;opacity:1.0;transparent:false');
          }, 50);
        }, i * 10);
      });
    }
  }, 800);
 
  // 7. Restore all buttons to full brightness (1000ms)
  setTimeout(() => {
    if (ui.allButtons && ui.allButtons.length > 0) {
      ui.allButtons.forEach(btn => {
        if (btn.id !== 'powerButtonCap') {
          btn.setAttribute('material', 'opacity:1.0;transparent:false');
          btn.setAttribute('visible', 'true');
          btn.object3D.visible = true;
        }
      });
    }
  }, 1000);
 
  // 8. Restore text displays (1100ms)
  setTimeout(() => {
    const infoDisplay = document.getElementById('infoDisplay');
    if (infoDisplay) {
      infoDisplay.setAttribute('opacity', '1.0');
    }
   
    const buttonFunctionDisplay = document.getElementById('buttonFunctionDisplay');
    if (buttonFunctionDisplay) {
      buttonFunctionDisplay.setAttribute('opacity', '1.0');
    }
  }, 1100);
 
  // 9. All lights on, system ready (1200ms)
  setTimeout(() => {
    updateUI();
    showMessage('‚úÖ SYSTEM READY');
  }, 1200);
}

// 7. Update powerDown function:
function powerDown() {
  console.log('‚ö° POWERING OFF...');
  showMessage('‚èπ SHUTTING DOWN...');
 
  // Stop playback
  state.isPlaying = false;
  stopAllSources();
 
  // Turn power button red and start pulsing
  const powerCap = document.getElementById('powerButtonCap');
  if (powerCap) {
    powerCap.setAttribute('color', '#FF0000');
    powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#FF0000;emissiveIntensity:2.0;opacity:1.0;transparent:false');
    powerCap.classList.add('power-button-pulse');
  }
 
  // Dim everything
  setTimeout(() => {
    dimEverything();
  }, 100);
 
  setTimeout(() => {
    showMessage('‚ö´ POWERED OFF');
  }, 500);
}

// Calculate velocity from mouse position on piano key
function calculateKeyVelocity(btn, event) {
  try {
    // Get button's bounding box in screen space
    const camera = document.querySelector('[camera]');
    if (!camera) return 0.8;
   
    const btnObj = btn.object3D;
    const btnBox = new THREE.Box3().setFromObject(btnObj);
   
    // Get the center and height of the button
    const btnCenter = new THREE.Vector3();
    btnBox.getCenter(btnCenter);
    const btnSize = new THREE.Vector3();
    btnBox.getSize(btnSize);
   
    // Project to screen coordinates
    const vector = btnCenter.clone();
    vector.project(camera.object3DMap.camera);
   
    // Convert to screen space (0-1)
    const screenX = (vector.x + 1) / 2;
    const screenY = (-vector.y + 1) / 2;
   
    // Get mouse position (0-1)
    const mouseX = event.detail.cursorEl ?
      (event.detail.intersection.point.x - btnCenter.x) / btnSize.x :
      0;
    const mouseY = event.detail.cursorEl ?
      (event.detail.intersection.point.y - btnCenter.y) / btnSize.y :
      0;
   
    console.log('üìç Mouse Y relative to button:', mouseY);
   
    // Convert to velocity (0-1)
    // mouseY ranges from -0.5 (bottom) to +0.5 (top)
    const normalizedY = mouseY + 0.5; // 0 (bottom) to 1 (top)
    const velocity = Math.max(0.01, Math.min(1.0, 1.0 - normalizedY));
   
    return velocity;
  } catch (err) {
    console.error('Velocity calculation error:', err);
    return 0.8;
  }
}
function attachClickHandler(btn) {
  if (!btn) return;
 btn.addEventListener('click', (e) => {
  e.stopPropagation();
 
  // **CRITICAL: Capture intersection data IMMEDIATELY**
  if (e.detail && e.detail.intersection) {
    const intersection = e.detail.intersection;
    const worldPoint = intersection.point.clone();
   
    // Convert world position to local button space
    const localPoint = btn.object3D.worldToLocal(worldPoint);
   
    // Store Y position (height) for velocity calculation
    btn._lastClickY = localPoint.y;
    btn._lastClickTime = Date.now();
   
    console.log(`üìç Piano Key Click - Y: ${localPoint.y.toFixed(3)}`);
  }
 
  const id = btn.dataset.buttonId || btn.id;
  handleButtonClick(id, btn);
});
}

// --- PAGE NAVIGATION FUNCTIONS ---
function clearPageElements(page) {
  // List of all possible UI container IDs
  const uiIds = ['mixUI', 'drumSeqUI', 'chordUI', 'songUI', 'fileUI', 'editUI', 'miscUI'];
 
  uiIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      // Remove from DOM
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      } else {
        el.remove();
      }
      console.log(`üßπ Cleared UI element: ${id}`);
    }
  });

  // CRITICAL: Clean up the global button array to stop VR interactions with dead buttons
  if (ui.allButtons) {
    // Keep only buttons that are still in the DOM (like piano keys and global nav)
    ui.allButtons = ui.allButtons.filter(btn => document.body.contains(btn));
  }
}


function updateSynthBodyColor() {
  const synthBody = document.getElementById('synthBody');
  const pianoPlinth = document.getElementById('pianoPlinth');
  if (!synthBody) return;
 
  let bodyColor = '#2a2a4e';
 
  if (state.currentPage === 'mix' && state.mixerSelectedTrack >= 0) {
    if (state.mixerSelectedTrack < 4) {
      const drumDarkColors = ['#4a1a1a', '#4a2a1a', '#1a2a4a', '#3a1a4a'];
      bodyColor = drumDarkColors[state.mixerSelectedTrack];
    } else {
      bodyColor = trackBodyColors[state.mixerSelectedTrack - 4];
    }
  } else if (state.currentPage === 'seq' || state.currentPage === 'drum') {
    bodyColor = trackBodyColors[state.currentTrack];
  }
 
  // Apply color to synth body
  synthBody.setAttribute('color', bodyColor);

  // Apply BRIGHTER version to plinth (using track colors instead of body colors)
  if (pianoPlinth) {
    let plinthColor = '#2a2a4e';
   
    if (state.currentPage === 'mix' && state.mixerSelectedTrack >= 0) {
      if (state.mixerSelectedTrack < 4) {
        // Drum colors (brighter)
        const drumColors = ['#DD3333', '#DD8833', '#33AADD', '#AA55DD'];
        plinthColor = drumColors[state.mixerSelectedTrack];
      } else {
        // Track colors (already bright)
     plinthColor = trackColors[state.mixerSelectedTrack - 3];
      }
    } else if (state.currentPage === 'seq' || state.currentPage === 'drum') {
      plinthColor = trackColors[state.currentTrack];
    }
   
    pianoPlinth.setAttribute('color', plinthColor);
  }
}

function showPage(page) {
  console.log('üìÑ Page Switch:', page);
  const previousPage = state.currentPage;

  // 1. CLEAR PREVIOUS PAGE STRICTLY
  clearPageElements(state.currentPage);
 
  state.currentPage = page;
  updateSynthBodyColor();

  // 2. Hide specific containers (Standard Hiding)
  const allContainers = ['stepButtons', 'transport', 'bpmButtons', 'patternButtons',
    'infoDisplay', 'velocityLane', 'oscilloscope', 'viewButtons',
    'soundSelector', 'buttonFunctionDisplay', 'octaveButtons', 'leftButtons', 'rightButtons', 'pianoKeys', 'drumButtons'];

  allContainers.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.object3D.visible = false;
      el.setAttribute('visible', 'false');
    }
  });

  // 3. Specific Logic to force-kill overlapping buttons
  if (page === 'song') {
     // Song page specifically conflicts with Chord/Edit views, so we force-hide global views
     const viewContainer = document.getElementById('viewButtons');
     if(viewContainer) {
        viewContainer.object3D.visible = false;
        viewContainer.setAttribute('visible', 'false');
     }
  }

  // 4. Always show global undo and demo
  const globalUndo = document.getElementById('globalUndo');
  if (globalUndo) {
    globalUndo.innerHTML = '';
    createButton(globalUndo, 0, 0, 0, 0.20, 0.10, 0.08, '#f39c12', 'global-undo', 'UNDO', 'white', true);
    globalUndo.object3D.visible = true;
    globalUndo.setAttribute('visible', 'true');
  }

  const demoButton = document.getElementById('demoButton');
  if (demoButton) {
    demoButton.innerHTML = '';
    createButton(demoButton, 0, 0, 0, 0.20, 0.10, 0.08, '#CC9933', 'demo-1', 'DEMO', 'white', true);
    demoButton.object3D.visible = true;
    demoButton.setAttribute('visible', 'true');
  }

  // 5. Build the New Page
  let toShow = [];

  if (page === 'seq') {
    toShow = ['stepButtons', 'transport', 'bpmButtons', 'patternButtons', 'infoDisplay',
      'velocityLane', 'oscilloscope', 'viewButtons', 'buttonFunctionDisplay',
      'octaveButtons', 'leftButtons', 'rightButtons', 'pianoKeys'];
    updateOscButtons();
    // Only show drum buttons if on track 0
    if (state.currentTrack === 0) toShow.push('drumButtons');
  }
  else if (page === 'mix') {
    buildMixPage();
    toShow = ['infoDisplay', 'pianoKeys'];
  }
  else if (page === 'drum') {
    buildDrumPage();
    toShow = ['infoDisplay', 'pianoKeys'];
  }
  else if (page === 'chord') {
    buildChordPage();
    toShow = ['infoDisplay', 'pianoKeys', 'viewButtons'];
  }
  else if (page === 'song') {
    buildSongPage(); // This builds songUI
    toShow = ['infoDisplay', 'pianoKeys'];
  }
  else if (page === 'file') {
    buildFilePage();
    toShow = ['infoDisplay', 'pianoKeys'];
  }
  else if (page === 'edit') {
    buildEditPage();
    toShow = ['infoDisplay', 'pianoKeys'];
  }
  else if (page === 'misc') {
    buildMiscPage();
    toShow = ['infoDisplay', 'pianoKeys'];
   
    // FM Visibility Logic
    const fmUI = document.getElementById('fmUI');
    if (window.FM && window.FM.enabled) {
      if (fmUI) fmUI.object3D.visible = true;
      if (window.FM.originalMiscUI) window.FM.originalMiscUI.object3D.visible = false;
    } else {
      if (fmUI) fmUI.object3D.visible = false;
      if (window.FM && window.FM.originalMiscUI) window.FM.originalMiscUI.object3D.visible = true;
    }
  }

  // 6. Reveal elements
  toShow.forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.object3D.visible = true;
      el.setAttribute('visible', 'true');
      if (id === 'viewButtons') {
        // Ensure child buttons are also visible
        ['v1', 'v2', 'v3', 'v4'].forEach(bid => {
           const b = document.getElementById(bid);
           if(b) b.setAttribute('visible', 'true');
        });
      }
    }
  });

  if (toShow.includes('velocityLane')) updateVelocityLane();

  // 7. Update Nav Highlight
  const pageButtons = document.getElementById('pageButtons');
  if (pageButtons) {
    pageButtons.object3D.visible = true;
    pageButtons.setAttribute('visible', 'true');
    const pageButtonIds = ['page-seq', 'page-mix', 'page-drum', 'page-chord', 'page-song', 'page-file', 'page-edit', 'page-misc'];
    pageButtonIds.forEach(btnId => {
      const btn = pageButtons.querySelector(`[data-button-id="${btnId}"]`);
      if (btn) {
        const isActive = btnId === `page-${page}`;
        const currentColor = btn.getAttribute('color');
        if (isActive) {
          btn.setAttribute('scale', '1.15 1.15 1.15');
          btn.setAttribute('material', `metalness:0.3;roughness:0.6;emissive:${currentColor};emissiveIntensity:2.0`);
        } else {
          btn.setAttribute('scale', '1 1 1');
          btn.setAttribute('material', 'metalness:0.3;roughness:0.6;emissive:#000;emissiveIntensity:0');
        }
      }
    });
  }

  updateUI();
  updateHUD();
  updateSynthBodyColor();
}

// --- UNDO SYSTEM ---
function saveUndoState() {
  const snapshot = {
    pattern: state.currentPattern,
    track: state.currentTrack,
    step: state.highlightedStep,
    data: JSON.parse(JSON.stringify(patterns[state.currentPattern])),
    trackVolumes: [...state.trackVolumes],
    drumVolumes: [...state.drumVolumes],
    trackPans: [...state.trackPans],
    drumPans: [...state.drumPans]
  };
  undoStack.push(snapshot);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function updateOscButtons() {
  const osc1Btn = document.getElementById('osc1');
  const osc2Btn = document.getElementById('osc2');
 
  if (osc1Btn) {
    const label = osc1Btn.querySelector('a-text');
    if (state.scopeMode === 0) {
      // OSC1 active (bar mode)
      osc1Btn.setAttribute('color', '#00FFAA');
      osc1Btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FFAA;emissiveIntensity:1.5');
      osc1Btn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000');
    } else {
      // OSC1 inactive
      osc1Btn.setAttribute('color', '#5599DD');
      osc1Btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      osc1Btn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white');
    }
  }
 
  if (osc2Btn) {
    const label = osc2Btn.querySelector('a-text');
    if (state.scopeMode === 1) {
      // OSC2 active (waveform mode)
      osc2Btn.setAttribute('color', '#00FFAA');
      osc2Btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FFAA;emissiveIntensity:1.5');
      osc2Btn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000');
    } else {
      // OSC2 inactive
      osc2Btn.setAttribute('color', '#5599DD');
      osc2Btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      osc2Btn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white');
    }
  }
}

function performUndo() {
  if (undoStack.length === 0) {
    showMessage('‚ö†Ô∏è NOTHING TO UNDO');
    return;
  }
 
  const snapshot = undoStack.pop();
  state.currentPattern = snapshot.pattern;
  state.currentTrack = snapshot.track;
  state.highlightedStep = Math.max(0, snapshot.step - 1);
 
  const newView = Math.floor(state.highlightedStep / 16);
  if (newView !== state.currentStepView) state.currentStepView = newView;
 
  patterns[state.currentPattern] = JSON.parse(JSON.stringify(snapshot.data));
 
  if (snapshot.trackVolumes) state.trackVolumes = [...snapshot.trackVolumes];
  if (snapshot.drumVolumes) state.drumVolumes = [...snapshot.drumVolumes];
  if (snapshot.trackPans) state.trackPans = [...snapshot.trackPans];
  if (snapshot.drumPans) state.drumPans = [...snapshot.drumPans];
 
  updateSteps();
  updateUI();
  showMessage(`‚Ü∂ UNDO (${undoStack.length} left)`);
}

function showMessage(msg) {
  console.log(msg);
  const infoDisplay = document.getElementById('infoDisplay');
  if (infoDisplay) {
    const currentText = infoDisplay.getAttribute('value');
    infoDisplay.setAttribute('value', msg);
    setTimeout(() => {
      infoDisplay.setAttribute('value', currentText);
    }, 2000);
  }
}

// --- VELOCITY LANE ---
AFRAME.registerComponent('velocity-painter', {
  schema: {
    barIndex: { type: 'number', default: 0 }
  },
  init: function() {
    this.el.addEventListener('click', (e) => {
      e.stopPropagation();
      const barIndex = this.data.barIndex;
      const offset = state.currentStepView * 16;
      const stepIndex = offset + barIndex;
     
      // **CRITICAL: Calculate velocity from click Y position**
      const intersection = e.detail.intersection;
      if (intersection) {
        // Get the click point in world space
        const clickPoint = intersection.point;
       
        // Get the bar's world position
        const barWorldPos = new THREE.Vector3();
        this.el.object3D.getWorldPosition(barWorldPos);
       
        // Calculate relative Y position
        // Bar height range is 0.05 to 0.15 (total 0.1 range)
        const minHeight = 0.05;
        const maxHeight = 0.15;
        const barRange = maxHeight - minHeight;
       
        // Click Y relative to bar bottom
        const relativeY = clickPoint.y - (barWorldPos.y - (this.el.getAttribute('height') / 2));
       
        // Convert to velocity (0-1)
        let velocity = Math.max(0, Math.min(1, relativeY / barRange));
       
        // Snap to MIDI values (0-127)
        const midiVel = Math.round(velocity * 127);
        velocity = midiVel / 127;
       
        console.log(`üéöÔ∏è Velocity Bar Click: Y=${relativeY.toFixed(3)}, Vel=${velocity.toFixed(3)}, MIDI=${midiVel}`);
       
        this.paintVelocity(stepIndex, velocity);
      }
    });
   
    this.el.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      window.isVelocityPainting = true;
      this.lastPaintedBar = this.data.barIndex;
    });
   
    this.el.addEventListener('mouseenter', (e) => {
      if (window.isVelocityPainting) {
        const barIndex = this.data.barIndex;
        const offset = state.currentStepView * 16;
        const stepIndex = offset + barIndex;
       
        // Get intersection point for continuous painting
        const raycaster = document.querySelector('[camera]').components.raycaster;
        if (raycaster && raycaster.raycaster) {
          const intersects = raycaster.raycaster.intersectObject(this.el.object3D, true);
          if (intersects.length > 0) {
            const clickPoint = intersects[0].point;
            const barWorldPos = new THREE.Vector3();
            this.el.object3D.getWorldPosition(barWorldPos);
           
            const minHeight = 0.05;
            const maxHeight = 0.15;
            const barRange = maxHeight - minHeight;
            const relativeY = clickPoint.y - (barWorldPos.y - (this.el.getAttribute('height') / 2));
           
            let velocity = Math.max(0, Math.min(1, relativeY / barRange));
            const midiVel = Math.round(velocity * 127);
            velocity = midiVel / 127;
           
            this.paintVelocity(stepIndex, velocity);
          }
        }
      }
    });
  },
 
  getCurrentVelocity: function(stepIndex) {
    const pat = patterns[state.currentPattern];
    if (state.currentTrack === 0) {
      return pat.drumVelocity[state.selectedDrum][stepIndex] ?? 1.0;
    } else {
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const trackKey = trackKeys[state.currentTrack];
      return pat.velocity[trackKey][stepIndex] ?? 0.8;
    }
  },
 
  paintVelocity: function(stepIndex, velocity) {
    const pat = patterns[state.currentPattern];
   
    // Round to MIDI value
    const midiVel = Math.round(velocity * 127);
    const normalizedVel = midiVel / 127;
   
    if (state.currentTrack === 0) {
      pat.drumVelocity[state.selectedDrum][stepIndex] = normalizedVel;
    } else {
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const trackKey = trackKeys[state.currentTrack];
      pat.velocity[trackKey][stepIndex] = normalizedVel;
    }
   
    updateVelocityLane();
    showMessage(`VEL: ${midiVel}/127 @ STEP ${stepIndex + 1}`);
  }
});

function createVelocityLane() {
  const container = document.getElementById('velocityLane');
  if (!container) return;
 
  container.innerHTML = '';
  velocityBars = [];
  const num = 16;
 
  window.isVelocityPainting = false;
  window.lastVelocityPainted = -1;
 
  // Create clickable background plane - SAME Z as step buttons
  const clickPlane = document.createElement('a-plane');
  clickPlane.setAttribute('width', num * 0.13 + 0.2);
  clickPlane.setAttribute('height', 0.25);
  clickPlane.setAttribute('position', '0 0.05 0'); // ‚Üê Z = 0 (same as step buttons)
  clickPlane.setAttribute('rotation', '0 0 0');
  clickPlane.setAttribute('color', '#0a0a1a');
  clickPlane.setAttribute('opacity', '0.2');
  clickPlane.setAttribute('transparent', 'true');
  clickPlane.setAttribute('class', 'clickable');
  clickPlane.setAttribute('id', 'velocity-click-plane');
  container.appendChild(clickPlane);
 
  // Paint velocity function
  const paintVelocityAtPoint = (localPoint) => {
    const planeWidth = num * 0.13 + 0.2;
    const planeHeight = 0.25;
   
    // Calculate which bar (X position)
    const normalizedX = (localPoint.x + planeWidth/2) / planeWidth;
    const barIndex = Math.floor(normalizedX * num);
   
    if (barIndex < 0 || barIndex >= num) return;
    if (barIndex === window.lastVelocityPainted && window.isVelocityPainting) return;
   
    window.lastVelocityPainted = barIndex;
   
    // Calculate velocity from Y position
    const minY = -planeHeight / 2;
    const maxY = planeHeight / 2;
    const normalizedY = (localPoint.y - minY) / (maxY - minY);
   
    let velocity = Math.max(0, Math.min(1, normalizedY));
    const midiVel = Math.round(velocity * 127);
    velocity = midiVel / 127;
   
    console.log(`üéöÔ∏è Paint: Bar=${barIndex}, LocalY=${localPoint.y.toFixed(3)}, NormY=${normalizedY.toFixed(3)}, MIDI=${midiVel}`);
   
    // Apply velocity
    const offset = state.currentStepView * 16;
    const stepIndex = offset + barIndex;
    const pat = patterns[state.currentPattern];
   
    if (state.currentTrack === 0) {
      pat.drumVelocity[state.selectedDrum][stepIndex] = velocity;
    } else {
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const trackKey = trackKeys[state.currentTrack];
      pat.velocity[trackKey][stepIndex] = velocity;
    }
   
    updateVelocityLane();
    showMessage(`VEL: ${midiVel}/127 @ STEP ${stepIndex + 1}`);
  };
 
  // Click handler
  clickPlane.addEventListener('click', (e) => {
    e.stopPropagation();
    const intersection = e.detail.intersection;
    if (!intersection) return;
   
    const localPoint = clickPlane.object3D.worldToLocal(intersection.point.clone());
    paintVelocityAtPoint(localPoint);
  });
 
  // Mouse down - start painting
  clickPlane.addEventListener('mousedown', (e) => {
    e.stopPropagation();
    window.isVelocityPainting = true;
    window.lastVelocityPainted = -1;
   
    const intersection = e.detail.intersection;
    if (intersection) {
      const localPoint = clickPlane.object3D.worldToLocal(intersection.point.clone());
      paintVelocityAtPoint(localPoint);
    }
  });
 
  // Mouse enter - continue painting if mouse is down
  clickPlane.addEventListener('mouseenter', (e) => {
    if (window.isVelocityPainting) {
      const intersection = e.detail.intersection;
      if (intersection) {
        const localPoint = clickPlane.object3D.worldToLocal(intersection.point.clone());
        paintVelocityAtPoint(localPoint);
      }
    }
  });
 
  // Mouse move - paint while dragging
  clickPlane.addEventListener('mousemove', (e) => {
    if (window.isVelocityPainting) {
      const intersection = e.detail.intersection;
      if (intersection) {
        const localPoint = clickPlane.object3D.worldToLocal(intersection.point.clone());
        window.lastVelocityPainted = -1;
        paintVelocityAtPoint(localPoint);
      }
    }
  });
 
  // Global mouse up - stop painting
  window.addEventListener('mouseup', () => {
    window.isVelocityPainting = false;
    window.lastVelocityPainted = -1;
  });
 
  // Create visual bars - SAME Z as step buttons
  for (let i = 0; i < num; i++) {
    const bar = document.createElement('a-box');
    const x = (i - num / 2 + 0.5) * 0.13;
    bar.setAttribute('position', `${x} 0 0`); // ‚Üê Z = 0 (same as step buttons)
    bar.setAttribute('width', '0.10');
    bar.setAttribute('height', '0.10');
    bar.setAttribute('depth', '0.04');
    container.appendChild(bar);
    velocityBars[i] = bar;
   
    // Add MIDI value label
    const stepLabel = document.createElement('a-text');
    stepLabel.setAttribute('value', '64');
    stepLabel.setAttribute('align', 'center');
    stepLabel.setAttribute('position', '0 0 0.025');
    stepLabel.setAttribute('scale', '0.12 0.12 0.12');
    stepLabel.setAttribute('color', '#000000');
    bar.appendChild(stepLabel);
  }
 
  console.log('‚úÖ Created velocity lane with drag painting support');
}

function updateVelocityLane() {
  if (!velocityBars || velocityBars.length === 0) return;
 
  const offset = state.currentStepView * 16;
  const currentColor = trackColors[state.currentTrack] || '#00AA00';
  const pat = patterns[state.currentPattern];
 
  if (!pat || !pat.velocity || !pat.drumVelocity) return;
 
  velocityBars.forEach((bar, i) => {
    const step = offset + i;
    let velValue = 0.8;
   
    if (state.currentTrack === 0) {
      if (pat.drumVelocity && pat.drumVelocity[state.selectedDrum]) {
        velValue = pat.drumVelocity[state.selectedDrum][step] ?? 1.0;
      }
    } else {
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const trackKey = trackKeys[state.currentTrack];
      if (pat.velocity && pat.velocity[trackKey]) {
        velValue = pat.velocity[trackKey][step] ?? 0.8;
      }
    }
   
    // Height based on velocity (0.02 min to 0.18 max)
    const minHeight = 0.02;
    const maxHeight = 0.18;
    const h = minHeight + (velValue * (maxHeight - minHeight));
    bar.setAttribute('height', h.toFixed(3));
   
    // Position: Y = half the height, Z = 0 (same as step buttons)
    const x = (i - 8 + 0.5) * 0.13;
    const y = (h / 2) - 0.1;
    bar.setAttribute('position', `${x} ${y} 0`); // ‚Üê Z = 0
   
    // Color intensity based on velocity
    const glow = 0.3 + (velValue * 2.0);
    bar.setAttribute('material', `color: ${currentColor}; emissive: ${currentColor}; emissiveIntensity: ${glow}`);
   
    // UPDATE LABEL WITH MIDI VALUE
    const stepLabel = bar.querySelector('a-text');
    if (stepLabel) {
      const midiVal = Math.round(velValue * 127);
      stepLabel.setAttribute('value', `${midiVal}`);
     
      // Use white text on dark bars, black on bright bars
      const textColor = velValue < 0.5 ? '#FFFFFF' : '#000000';
      stepLabel.setAttribute('color', textColor);
      stepLabel.setAttribute('scale', '0.12 0.12 0.12');
    }
   
    // Highlight current/playing step
    if (step === state.highlightedStep) {
      bar.setAttribute('material', `emissive: #FFFF00; emissiveIntensity: 3`);
    } else if (state.isPlaying && step === state.currentStep) {
      bar.setAttribute('material', `emissive: #00FF00; emissiveIntensity: 3`);
    }
  });
}
function createOsc2() {
  const container = document.getElementById('oscilloscope');
  if (!container) return;
 
  container.innerHTML = '';
 
  // Clickable background for toggling
  const scopeBackground = document.createElement('a-plane');
  scopeBackground.setAttribute('width', '2.1');
  scopeBackground.setAttribute('height', '0.18');
  scopeBackground.setAttribute('position', '0 0 -0.01');
  scopeBackground.setAttribute('color', '#0a0a1a');
  scopeBackground.setAttribute('opacity', '0.5');
  scopeBackground.setAttribute('class', 'clickable');
  scopeBackground.setAttribute('id', 'scope-toggle');
  scopeBackground.dataset.buttonId = 'scope-toggle';
  container.appendChild(scopeBackground);
  attachClickHandler(scopeBackground);
 
  // Initialize waveform data structures
  window.waveform2Data = {
    currentPoints: [],
    trail1: [],
    trail2: [],
    trail3: [],
    hueOffset: 0,
    time: 0
  };
 
  console.log('‚úÖ Oscilloscope 2 (Rainbow Waveform) created');
}

function updateOsc2() {
  if (!analyser || !window.waveform2Data) return;
  if (Math.random() > 0.5) return; // Throttle updates
 
  const container = document.getElementById('oscilloscope');
  if (!container) return;
 
  analyser.getByteTimeDomainData(dataArray);
 
  const data = window.waveform2Data;
  const samples = 80; // Number of waveform points
  const width = 2.0; // Width of oscilloscope
  const height = 0.15; // Height of oscilloscope
 
  // Detect audio activity
  let maxAmplitude = 0;
  for (let i = 0; i < dataArray.length; i++) {
    const rawValue = Math.abs(dataArray[i] / 128.0 - 1.0);
    if (rawValue > maxAmplitude) maxAmplitude = rawValue;
  }
 
  const isPlayingAudio = maxAmplitude > 0.01 && state.isPlaying;
 
  // Advance time and hue
  data.time += 0.05;
  data.hueOffset = (data.hueOffset + 2) % 360;
 
  // Calculate new waveform points
  const newPoints = [];
  const step = Math.floor(dataArray.length / samples);
 
  if (isPlayingAudio) {
    // Real audio waveform
    const dynamicAmplification = maxAmplitude > 0.001 ? (0.6 / maxAmplitude) : 10.0;
    const amplification = Math.min(dynamicAmplification, 12.0);
   
    for (let i = 0; i < samples; i++) {
      const x = (i / samples - 0.5) * width;
      const rawValue = (dataArray[i * step] / 128.0 - 1.0);
      const y = rawValue * (height / 2) * amplification;
      newPoints.push({ x, y, z: 0.01 });
    }
  } else {
    // Demo animated waveform
    for (let i = 0; i < samples; i++) {
      const x = (i / samples - 0.5) * width;
      const wave1 = Math.sin((i / samples) * Math.PI * 4 + data.time) * 0.4;
      const wave2 = Math.sin((i / samples) * Math.PI * 8 + data.time * 1.5) * 0.2;
      const wave3 = Math.sin((i / samples) * Math.PI * 16 + data.time * 2) * 0.1;
      const y = (wave1 + wave2 + wave3) * (height / 2);
      newPoints.push({ x, y, z: 0.01 });
    }
  }
 
  // Update trail history (phosphor effect)
  if (data.currentPoints.length > 0) {
    data.trail3 = [...data.trail2];
    data.trail2 = [...data.trail1];
    data.trail1 = [...data.currentPoints];
  }
  data.currentPoints = newPoints;
 
  // Render main waveform
  renderWaveformLine('waveform-main', data.currentPoints, data.hueOffset, 1.0);
 
  // Render phosphor trails
  if (data.trail1.length > 0) {
    renderWaveformLine('waveform-trail1', data.trail1, data.hueOffset - 30, 0.6);
  }
  if (data.trail2.length > 0) {
    renderWaveformLine('waveform-trail2', data.trail2, data.hueOffset - 60, 0.3);
  }
  if (data.trail3.length > 0) {
    renderWaveformLine('waveform-trail3', data.trail3, data.hueOffset - 90, 0.15);
  }
 
  // Add glow spheres at peak points
  renderGlowSpheres(data.currentPoints, data.hueOffset);
}

function renderWaveformLine(id, points, hueBase, opacity) {
  const container = document.getElementById('oscilloscope');
  if (!container || points.length < 2) return;
 
  let lineEl = document.getElementById(id);
 
  if (!lineEl) {
    lineEl = document.createElement('a-entity');
    lineEl.setAttribute('id', id);
    container.appendChild(lineEl);
  }
 
  // Create line segments with rainbow gradient
  const segmentCount = points.length - 1;
  let pathStr = '';
 
  for (let i = 0; i < segmentCount; i++) {
    const p1 = points[i];
    const p2 = points[i + 1];
   
    // Calculate hue for this segment (rainbow gradient)
    const hue = (hueBase + (i / segmentCount) * 360) % 360;
    const color = `hsl(${hue}, 100%, 60%)`;
   
    // Create individual line segment
    let segmentEl = document.getElementById(`${id}-seg-${i}`);
    if (!segmentEl) {
      segmentEl = document.createElement('a-entity');
      segmentEl.setAttribute('id', `${id}-seg-${i}`);
      segmentEl.setAttribute('line', `start: ${p1.x} ${p1.y} ${p1.z}; end: ${p2.x} ${p2.y} ${p2.z}; color: ${color}; opacity: ${opacity}`);
      lineEl.appendChild(segmentEl);
    } else {
      segmentEl.setAttribute('line', `start: ${p1.x} ${p1.y} ${p1.z}; end: ${p2.x} ${p2.y} ${p2.z}; color: ${color}; opacity: ${opacity}`);
    }
  }
}

function renderGlowSpheres(points, hueBase) {
  const container = document.getElementById('oscilloscope');
  if (!container || points.length < 5) return;
 
  // Find peak points (every 10th point for performance)
  const peakIndices = [];
  for (let i = 10; i < points.length - 10; i += 10) {
    const current = Math.abs(points[i].y);
    const prev = Math.abs(points[i - 1].y);
    const next = Math.abs(points[i + 1].y);
   
    if (current > prev && current > next && current > 0.02) {
      peakIndices.push(i);
    }
  }
 
  // Limit to 8 glow spheres max
  const maxGlows = Math.min(8, peakIndices.length);
 
  for (let i = 0; i < maxGlows; i++) {
    const idx = peakIndices[i];
    const point = points[idx];
    const hue = (hueBase + (idx / points.length) * 360) % 360;
    const color = `hsl(${hue}, 100%, 70%)`;
   
    let glowEl = document.getElementById(`waveform-glow-${i}`);
    if (!glowEl) {
      glowEl = document.createElement('a-sphere');
      glowEl.setAttribute('id', `waveform-glow-${i}`);
      glowEl.setAttribute('radius', '0.008');
      container.appendChild(glowEl);
    }
   
    glowEl.setAttribute('position', `${point.x} ${point.y} ${point.z + 0.005}`);
    glowEl.setAttribute('color', color);
    glowEl.setAttribute('material', `shader: flat; transparent: true; opacity: 0.8; emissive: ${color}; emissiveIntensity: 2.0`);
  }
 
  // Hide unused glow spheres
  for (let i = maxGlows; i < 8; i++) {
    const glowEl = document.getElementById(`waveform-glow-${i}`);
    if (glowEl) {
      glowEl.setAttribute('visible', 'false');
    }
  }
}
// --- OSCILLOSCOPE ---
function createOsc() {
  const container = document.getElementById('oscilloscope');
  if (!container) return;
 
  container.innerHTML = '';
  oscilloscopeBars = [];
 if (typeof state.scopeMode === 'undefined') state.scopeMode = 0;
if (typeof state.activeOscilloscope === 'undefined') state.activeOscilloscope = 1; // 1 or 2
 
  const num = 32;
 
  // Clickable background
  const scopeBackground = document.createElement('a-plane');
  scopeBackground.setAttribute('width', '2.1');
  scopeBackground.setAttribute('height', '0.18');
  scopeBackground.setAttribute('position', '0 0 -0.01');
  scopeBackground.setAttribute('color', '#0a0a1a');
  scopeBackground.setAttribute('opacity', '0.5');
  scopeBackground.setAttribute('class', 'clickable');
  scopeBackground.setAttribute('id', 'scope-toggle');
  scopeBackground.dataset.buttonId = 'scope-toggle';
  container.appendChild(scopeBackground);
  attachClickHandler(scopeBackground);
 
  // Create spectrum bars
  for (let i = 0; i < num; i++) {
    const bar = document.createElement('a-box');
    const x = (i - num / 2) * 0.065;
    const color = rainbow[Math.floor((i / num) * rainbow.length)];
   
    bar.setAttribute('position', `${x} 0 0`);
    bar.setAttribute('width', '0.04');
    bar.setAttribute('height', '0.01');
    bar.setAttribute('depth', '0.01');
    bar.setAttribute('color', color);
    bar.setAttribute('material', `metalness:.4;roughness:.5;emissive:${color};emissiveIntensity:.6`);
    bar.classList.add('scope-bar');
    container.appendChild(bar);
    oscilloscopeBars.push(bar);
  }
 
  // Initialize waveform arrays
  window.waveformSpheres = [];
  window.waveformLines = []; // NEW: Store line segments
  window.waveformTrails = [[], [], []];
 
  console.log('‚úÖ Oscilloscope created with thick-line waveform renderer');
 
 
}

// üåà HSL to HEX color converter
// üåà HSL to HEX color converter
function hslToHex(h, s, l) {
  l /= 100;
  const a = s * Math.min(l, 1 - l) / 100;
  const f = n => {
    const k = (n + h / 30) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color).toString(16).padStart(2, '0');
  };
  return `#${f(0)}${f(8)}${f(4)}`;
}

// Add this near the top of your script, after the other global variables
let waveformCanvas = null;
let waveformContext = null;
let waveformTexture = null;

// Replace the entire updateOsc() function with this optimized version:
function updateOsc() {
  if (!analyser || !oscilloscopeBars.length) return;
  if (Math.random() > 0.5) return;
 
  if (state.scopeMode === 0) {
    // BAR MODE
    analyser.getByteFrequencyData(dataArray);
    const step = Math.floor(dataArray.length / oscilloscopeBars.length);
   
    oscilloscopeBars.forEach((bar, i) => {
      bar.setAttribute('visible', 'true');
      const rawValue = dataArray[i * step] / 255;
      const v = Math.pow(rawValue, 0.6) * 1.8;
      const h = Math.max(0.01, Math.min(0.15, v * 0.15));
      bar.setAttribute('height', h);
     
      const color = bar.getAttribute('color');
      const intensity = Math.max(0.5, v * 3);
      bar.setAttribute('material', `metalness:.4;roughness:.5;emissive:${color};emissiveIntensity:${intensity}`);
    });
   
    // Hide waveform canvas
    const waveformPlane = document.getElementById('waveform-canvas-plane');
    if (waveformPlane) {
      waveformPlane.setAttribute('visible', 'false');
      waveformPlane.object3D.visible = false;
    }
   
  } else {
    // WAVEFORM MODE
    analyser.getByteTimeDomainData(dataArray);
   
    // Hide bar oscilloscope
    oscilloscopeBars.forEach(bar => bar.setAttribute('visible', 'false'));
   
    // Initialize canvas if needed
    if (!waveformCanvas) {
      console.log('üé® Creating waveform canvas...');
      waveformCanvas = document.createElement('canvas');
      waveformCanvas.width = 1024;
      waveformCanvas.height = 256;
      waveformContext = waveformCanvas.getContext('2d');
      waveformTexture = new THREE.CanvasTexture(waveformCanvas);
      waveformTexture.needsUpdate = true;
    }
   
    // Get or create plane
    const container = document.getElementById('oscilloscope');
    let plane = document.getElementById('waveform-canvas-plane');
   
    if (!plane && container) {
      console.log('üé® Creating waveform plane...');
      plane = document.createElement('a-plane');
      plane.setAttribute('id', 'waveform-canvas-plane');
    plane.setAttribute('position', '0 0 0.01'); // ‚Üê Changed from 0.15 to 0.01
      plane.setAttribute('width', '1.9');
      plane.setAttribute('height', '0.14');
      plane.setAttribute('material', 'shader: flat; transparent: true; opacity: 1; side: double');
      plane.setAttribute('visible', 'true');
      container.appendChild(plane);
     
      // Wait for plane to load, then assign texture
      plane.addEventListener('loaded', () => {
        console.log('‚úÖ Waveform plane loaded');
        const mesh = plane.getObject3D('mesh');
        if (mesh && mesh.material) {
          mesh.material.map = waveformTexture;
          mesh.material.needsUpdate = true;
          console.log('‚úÖ Texture assigned to plane');
        }
      });
    }
   
    // Make sure plane is visible
    if (plane) {
      plane.setAttribute('visible', 'true');
      plane.object3D.visible = true;
     
      // Assign texture if not already assigned
      const mesh = plane.getObject3D('mesh');
      if (mesh && mesh.material && !mesh.material.map) {
        mesh.material.map = waveformTexture;
        mesh.material.needsUpdate = true;
        console.log('‚úÖ Texture assigned (late)');
      }
    }
   
    // Detect audio activity
    let maxAmplitude = 0;
    for (let i = 0; i < dataArray.length; i++) {
      const rawValue = Math.abs(dataArray[i] / 128.0 - 1.0);
      if (rawValue > maxAmplitude) maxAmplitude = rawValue;
    }
   
    const isPlayingAudio = maxAmplitude > 0.01 && state.isPlaying;
   
    // Clear canvas with fade effect for trails
    waveformContext.fillStyle = 'rgba(10, 10, 26, 0.15)';
    waveformContext.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
   
    const width = waveformCanvas.width;
    const height = waveformCanvas.height;
    const samples = 200;
   
    // Generate waveform points
    const points = [];
    if (isPlayingAudio) {
      const step = Math.floor(dataArray.length / samples);
      const dynamicAmplification = maxAmplitude > 0.001 ? (0.6 / maxAmplitude) : 10.0;
      const amplification = Math.min(dynamicAmplification, 10.0);
     
      for (let i = 0; i < samples; i++) {
        const x = (i / samples) * width;
        const rawValue = (dataArray[i * step] / 128.0 - 1.0);
        const y = (height / 2) + (rawValue * (height / 2) * amplification);
        points.push({x, y});
      }
    } else {
      // Animated demo waveform
      if (!window.waveformTime) window.waveformTime = 0;
      window.waveformTime += 0.08;
     
      for (let i = 0; i < samples; i++) {
        const x = (i / samples) * width;
        const wave1 = Math.sin((i / samples) * Math.PI * 3 + window.waveformTime) * 0.5;
        const wave2 = Math.sin((i / samples) * Math.PI * 7 + window.waveformTime * 1.3) * 0.25;
        const y = (height / 2) + ((wave1 + wave2) * (height / 3));
        points.push({x, y});
      }
    }
   
    // Draw waveform with rainbow gradient
    if (!window.waveformColorTime) window.waveformColorTime = 0;
    window.waveformColorTime += 0.5;
   
    waveformContext.lineWidth = 3;
    waveformContext.lineCap = 'round';
    waveformContext.lineJoin = 'round';
   
    // Draw gradient line
    for (let i = 0; i < points.length - 1; i++) {
      const p1 = points[i];
      const p2 = points[i + 1];
     
      // Rainbow color
      const hue = (i / points.length) * 360;
      const amplitude = Math.abs((p1.y - height/2) / (height/2));
      const hueShift = amplitude * 60;
      const finalHue = (hue + hueShift + window.waveformColorTime) % 360;
     
      waveformContext.strokeStyle = `hsl(${finalHue}, 100%, 60%)`;
      waveformContext.beginPath();
      waveformContext.moveTo(p1.x, p1.y);
      waveformContext.lineTo(p2.x, p2.y);
      waveformContext.stroke();
    }
   
    // Draw glow points
    points.forEach((p, i) => {
      const hue = (i / points.length) * 360;
      const amplitude = Math.abs((p.y - height/2) / (height/2));
      const hueShift = amplitude * 60;
      const finalHue = (hue + hueShift + window.waveformColorTime) % 360;
     
      const gradient = waveformContext.createRadialGradient(p.x, p.y, 0, p.x, p.y, 6);
      gradient.addColorStop(0, `hsla(${finalHue}, 100%, 70%, 1)`);
      gradient.addColorStop(1, `hsla(${finalHue}, 100%, 70%, 0)`);
     
      waveformContext.fillStyle = gradient;
      waveformContext.fillRect(p.x - 6, p.y - 6, 12, 12);
    });
   
    // Update texture
    if (waveformTexture) {
      waveformTexture.needsUpdate = true;
    }
  }
}

// Replace the waveform component registrations with these corrected versions:
// (Place these BEFORE the sequencer-loop component)


// --- UI UPDATE FUNCTIONS ---
function updateSteps() {
  if (!patterns[state.currentPattern]) return;
 
  const pat = patterns[state.currentPattern];
  const off = state.currentStepView * 16;
 
  // Calculate quantize grid
  const gridSizes = [0, 0.5, 1, 2, 4, 8]; // 0=off, 32nd, 16th, 8th, 4th, 2nd notes
  const grid = gridSizes[state.quantize];
  const quantizeActive = state.quantize > 0 && grid > 0;
 
  ui.stepButtons.forEach((btn, i) => {
  const step = off + i;
  const beyondLength = step >= patterns[state.currentPattern].length;
 
  let hasNote = false;
  let stepText = '';
  let targetColor = '#FFFFFF';
  let isTieOrRest = false;
  let noteDisplay = '';
 
  // Calculate quantize grid
  const gridSizes = [0, 0.5, 1, 2, 4, 8];
  const grid = gridSizes[state.quantize];
  const quantizeActive = state.quantize > 0 && grid > 0;
 
  if (quantizeActive) {
    // Quantize mode logic (keeping your existing code)
    if (state.currentTrack === 0) {
      const drumName = state.selectedDrum || 'kick';
      const drumIdx = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
      if (drumIdx >= 0) targetColor = drumColors[drumIdx];
     
      for (let checkStep = off; checkStep < off + 16; checkStep++) {
        const quantizedPos = getQuantizedStep(checkStep, off, grid);
        if (quantizedPos === step && pat.drums[drumName][checkStep]) {
          hasNote = true;
          break;
        }
      }
    } else {
      targetColor = trackColors[state.currentTrack];
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const currentKey = trackKeys[state.currentTrack];
     
      if (currentKey && pat[currentKey]) {
        for (let checkStep = off; checkStep < off + 16; checkStep++) {
          const note = pat[currentKey][checkStep];
          if (note && note !== '' && note !== 'TIE' && note !== 'REST' && note !== '-' && note !== '^') {
            const quantizedPos = getQuantizedStep(checkStep, off, grid);
            if (quantizedPos === step) {
              hasNote = true;
              noteDisplay = note; // Store the note name
              break;
            }
          }
        }
      }
    }
  } else {
    // NO QUANTIZE
    if (state.currentTrack === 0) {
      const drumName = state.selectedDrum || 'kick';
      if (pat.drums[drumName] && pat.drums[drumName][step]) hasNote = true;
      const drumIdx = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
      if (drumIdx >= 0) targetColor = drumColors[drumIdx];
    } else {
      targetColor = trackColors[state.currentTrack];
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const currentKey = trackKeys[state.currentTrack];
     
      if (currentKey && pat[currentKey]) {
        const note = pat[currentKey][step];
        if (note && note !== '') {
          if (note === '-' || note === 'TIE') {
            isTieOrRest = true;
            stepText = '/';
          } else if (note === '^' || note === 'REST') {
            isTieOrRest = true;
            stepText = '^';
          } else {
            hasNote = true;
            noteDisplay = note; // Store the note name
          }
        }
       
        if (state.currentTrack === 4 && pat.arpChords && pat.arpChords[step]) {
          const root = pat.arpChords[step].root;
          if (typeof root !== 'undefined' && chordColors[root]) {
            targetColor = chordColors[root];
          }
        }
      }
    }
  }
 
  const label = btn.querySelector('a-text');
  if (label) {
    // Determine text color based on background brightness
    let textColor = 'white';
   
    if (hasNote && !isTieOrRest) {
      // Calculate brightness of targetColor
      const hex = targetColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
     
      // Use dark text on bright backgrounds
      textColor = brightness > 128 ? '#000033' : 'white';
     
      // Display note name instead of step number
      label.setAttribute('value', noteDisplay);
      label.setAttribute('color', textColor);
      label.setAttribute('scale', '0.35 0.35 0.35'); // Bigger for note names
    } else if (stepText) {
      // Tie or Rest symbol
      label.setAttribute('value', stepText);
      label.setAttribute('color', 'white');
      label.setAttribute('scale', '0.25 0.25 0.25');
    } else {
      // Step number
      label.setAttribute('value', `${i + 1}`);
      label.setAttribute('color', 'white');
      label.setAttribute('scale', '0.15 0.15 0.15');
    }
  }
 
  // Set button appearance
  if (beyondLength) {
    btn.setAttribute('color', '#1a1a2a');
    btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  } else if (state.isPlaying && step === state.currentStep) {
    btn.setAttribute('color', '#00FF00');
    btn.setAttribute('material', 'metalness:0;roughness:1;emissive:#00FF00;emissiveIntensity:3.5');
    btn.setAttribute('scale', '1 1 1');
  } else if (step === state.highlightedStep) {
    btn.setAttribute('color', purple);
    btn.setAttribute('material', `metalness:0;roughness:1;emissive:${purple};emissiveIntensity:2.5`);
    btn.setAttribute('scale', '1.1 1.1 1.1');
  } else if (isTieOrRest) {
    // TIES AND RESTS - Dark grey, no color
    btn.setAttribute('color', '#333344');
    btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  } else if (hasNote) {
    btn.setAttribute('color', targetColor);
    btn.setAttribute('material', `metalness:0;roughness:1;emissive:${targetColor};emissiveIntensity:2.5`);
    btn.setAttribute('scale', '1.05 1.05 1.05');
  } else {
    btn.setAttribute('color', '#556677');
    btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  }
});ui.stepButtons.forEach((btn, i) => {
  const step = off + i;
  const beyondLength = step >= patterns[state.currentPattern].length;
 
  let hasNote = false;
  let stepText = '';
  let targetColor = '#FFFFFF';
  let isTieOrRest = false;
  let noteDisplay = '';
 
  // Calculate quantize grid
  const gridSizes = [0, 0.5, 1, 2, 4, 8];
  const grid = gridSizes[state.quantize];
  const quantizeActive = state.quantize > 0 && grid > 0;
 
  if (quantizeActive) {
    // Quantize mode logic (keeping your existing code)
    if (state.currentTrack === 0) {
      const drumName = state.selectedDrum || 'kick';
      const drumIdx = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
      if (drumIdx >= 0) targetColor = drumColors[drumIdx];
     
      for (let checkStep = off; checkStep < off + 16; checkStep++) {
        const quantizedPos = getQuantizedStep(checkStep, off, grid);
        if (quantizedPos === step && pat.drums[drumName][checkStep]) {
          hasNote = true;
          break;
        }
      }
    } else {
      targetColor = trackColors[state.currentTrack];
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const currentKey = trackKeys[state.currentTrack];
     
      if (currentKey && pat[currentKey]) {
        for (let checkStep = off; checkStep < off + 16; checkStep++) {
          const note = pat[currentKey][checkStep];
          if (note && note !== '' && note !== 'TIE' && note !== 'REST' && note !== '-' && note !== '^') {
            const quantizedPos = getQuantizedStep(checkStep, off, grid);
            if (quantizedPos === step) {
              hasNote = true;
              noteDisplay = note; // Store the note name
              break;
            }
          }
        }
      }
    }
  } else {
    // NO QUANTIZE
    if (state.currentTrack === 0) {
      const drumName = state.selectedDrum || 'kick';
      if (pat.drums[drumName] && pat.drums[drumName][step]) hasNote = true;
      const drumIdx = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
      if (drumIdx >= 0) targetColor = drumColors[drumIdx];
    } else {
      targetColor = trackColors[state.currentTrack];
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const currentKey = trackKeys[state.currentTrack];
     
      if (currentKey && pat[currentKey]) {
        const note = pat[currentKey][step];
        if (note && note !== '') {
          if (note === '-' || note === 'TIE') {
            isTieOrRest = true;
            stepText = '/';
          } else if (note === '^' || note === 'REST') {
            isTieOrRest = true;
            stepText = '^';
          } else {
            hasNote = true;
            noteDisplay = note; // Store the note name
          }
        }
       
        if (state.currentTrack === 4 && pat.arpChords && pat.arpChords[step]) {
          const root = pat.arpChords[step].root;
          if (typeof root !== 'undefined' && chordColors[root]) {
            targetColor = chordColors[root];
          }
        }
      }
    }
  }
 
  const label = btn.querySelector('a-text');
  if (label) {
    // Determine text color based on background brightness
    let textColor = 'white';
   
    if (hasNote && !isTieOrRest) {
      // Calculate brightness of targetColor
      const hex = targetColor.replace('#', '');
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      const brightness = (r * 299 + g * 587 + b * 114) / 1000;
     
      // Use dark text on bright backgrounds
      textColor = brightness > 128 ? '#000033' : 'white';
     
      // Display note name instead of step number
      label.setAttribute('value', noteDisplay);
      label.setAttribute('color', textColor);
      label.setAttribute('scale', '0.35 0.35 0.35'); // Bigger for note names
    } else if (stepText) {
      // Tie or Rest symbol
      label.setAttribute('value', stepText);
      label.setAttribute('color', 'white');
      label.setAttribute('scale', '0.25 0.25 0.25');
    } else {
      // Step number
      label.setAttribute('value', `${i + 1}`);
      label.setAttribute('color', 'white');
      label.setAttribute('scale', '0.15 0.15 0.15');
    }
  }
 
  // Set button appearance
  if (beyondLength) {
    btn.setAttribute('color', '#1a1a2a');
    btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  } else if (state.isPlaying && step === state.currentStep) {
    btn.setAttribute('color', '#00FF00');
    btn.setAttribute('material', 'metalness:0;roughness:1;emissive:#00FF00;emissiveIntensity:3.5');
    btn.setAttribute('scale', '1 1 1');
  } else if (step === state.highlightedStep) {
    btn.setAttribute('color', purple);
    btn.setAttribute('material', `metalness:0;roughness:1;emissive:${purple};emissiveIntensity:2.5`);
    btn.setAttribute('scale', '1.1 1.1 1.1');
  } else if (isTieOrRest) {
    // TIES AND RESTS - Dark grey, no color
    btn.setAttribute('color', '#333344');
    btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  } else if (hasNote) {
    btn.setAttribute('color', targetColor);
    btn.setAttribute('material', `metalness:0;roughness:1;emissive:${targetColor};emissiveIntensity:2.5`);
    btn.setAttribute('scale', '1.05 1.05 1.05');
  } else {
    btn.setAttribute('color', '#556677');
    btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  }
});
 
  // Update view buttons with grey-out for unused blocks
const playBlock = Math.floor(state.currentStep / 16);
ui.viewButtons.forEach((b, i) => {
  const blockStart = i * 16;
  const isBlockActive = blockStart < patterns[state.currentPattern].length;
 
  if (!isBlockActive) {
    // Grey out inactive blocks
    b.setAttribute('color', '#1a1a2a');
    b.setAttribute('material', 'metalness:.5;roughness:.5;emissive:#000;emissiveIntensity:0;opacity:0.3;transparent:true');
    b.setAttribute('scale', '0.95 0.95 0.95');
  } else if (i === state.currentStepView) {
    // Active and selected - purple
    b.setAttribute('color', purple);
    b.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:1.2;opacity:1;transparent:false`);
    b.setAttribute('scale', '1 1 1');
  } else if (state.isPlaying && i === playBlock) {
    // Active and playing - green
    b.setAttribute('color', '#00FF00');
    b.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.2;opacity:1;transparent:false');
    b.setAttribute('scale', '1 1 1');
  } else {
    // Active but not selected - normal
    b.setAttribute('color', '#336688');
    b.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0;opacity:1;transparent:false');
    b.setAttribute('scale', '1 1 1');
  }
});
 
  updateVelocityLane();
}

function updateUI() {
 console.log('üîÑ updateUI() START');
  console.log('   Current page:', state.currentPage);
  console.log('   Current track:', state.currentTrack);
  console.log('   Previous track:', state.previousTrack);

  const page = state.currentPage;
  const previousPage = state.previousPage;

  // ===== FM UI VISIBILITY - HANDLE FIRST =====
  const fmUI = document.getElementById('fmUI');
  if (fmUI) {
    if (page === 'misc' && window.FM && window.FM.enabled) {
      console.log('   -> Showing FM UI (MISC page + FM enabled)');
      fmUI.object3D.visible = true;
      if (window.FM.originalMiscUI) window.FM.originalMiscUI.object3D.visible = false;
    } else {
      console.log('   -> Hiding FM UI (not MISC or FM disabled)');
      fmUI.object3D.visible = false;
      if (page === 'misc' && window.FM && window.FM.originalMiscUI) {
        window.FM.originalMiscUI.object3D.visible = true;
      }
    }
  }
  console.log('üîÑ updateUI() START');
  console.log('   Current page:', state.currentPage);
  console.log('   Current track:', state.currentTrack);
  console.log('   Previous track:', state.previousTrack);
 
  updateHUD();
  updateSteps();
  updateSoundLabel();
  updateSongProgress();
 
  const drumButtonsContainer = document.getElementById('drumButtons');
  const shouldShowDrumButtons = (state.currentPage === 'seq' && state.currentTrack === 0);

  console.log('üîç updateUI() - Drum button visibility check:');
  console.log('   currentPage:', state.currentPage);
  console.log('   currentTrack:', state.currentTrack);
  console.log('   shouldShow:', shouldShowDrumButtons);
  console.log('   containerExists:', !!drumButtonsContainer);
 
  if (drumButtonsContainer) {
    console.log('   BEFORE - container visible:', drumButtonsContainer.object3D.visible);
    drumButtonsContainer.object3D.visible = shouldShowDrumButtons;
    drumButtonsContainer.setAttribute('visible', shouldShowDrumButtons ? 'true' : 'false');
    console.log('   AFTER - container set to:', shouldShowDrumButtons);
  }

  if (ui.drumButtons) {
    console.log('   Processing', ui.drumButtons.length, 'drum buttons');
    ui.drumButtons.forEach((btn, i) => {
      if (btn && btn.object3D) {
        btn.object3D.visible = shouldShowDrumButtons;
        btn.setAttribute('visible', shouldShowDrumButtons ? 'true' : 'false');
       
        if (shouldShowDrumButtons) {
          if (['kick', 'snare', 'hihat', 'open'][i] === state.selectedDrum) {
            btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:1');
          } else {
            btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
          }
        }
      }
    });
  }

  console.log('   ‚úÖ Drum buttons update complete');
 
  ui.viewButtons.forEach((b, i) => {
    if (i === state.currentStepView) {
      b.setAttribute('color', purple);
      b.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:.9`);
    } else {
      b.setAttribute('color', '#336688');
      b.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    }
  });
 
  updateTieRestButtons();
  updateCopyStepButton();
  updateClearStepButton();
  updatePatternLengthButton()
 
  const recBtn = document.getElementById('record');
  if (recBtn) {
    if (state.isRecording) {
      recBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FF0000;emissiveIntensity:1.5');
    } else {
      recBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    }
  }
 
  updateSynthBodyColor();
  console.log('üîÑ updateUI() END\n');
}

function updateTieRestButtons() {
  const tieBtn = document.getElementById('tie');
  const restBtn = document.getElementById('rest');
 
  if (tieBtn) {
    const tieLabel = tieBtn.querySelector('a-text');
    if (state.tieMode) {
      tieBtn.setAttribute('color', '#00FFFF');
      tieBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FFFF;emissiveIntensity:1.5');
      tieBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (tieLabel) tieLabel.setAttribute('color', '#000000'); // Black text
    } else {
      tieBtn.setAttribute('color', '#6688DD');
      tieBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      tieBtn.setAttribute('scale', '1 1 1');
      if (tieLabel) tieLabel.setAttribute('color', 'white'); // White text when not active
    }
  }
 
  if (restBtn) {
    const restLabel = restBtn.querySelector('a-text');
    if (state.restMode) {
      restBtn.setAttribute('color', '#FFAA00');
      restBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FFAA00;emissiveIntensity:1.5');
      restBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (restLabel) restLabel.setAttribute('color', '#000000'); // Black text
    } else {
      restBtn.setAttribute('color', '#DD8866');
      restBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      restBtn.setAttribute('scale', '1 1 1');
      if (restLabel) restLabel.setAttribute('color', 'white'); // White text when not active
    }
  }
}

function updateClearStepButton() {
  const clrBtn = document.getElementById('clrstep');
  if (clrBtn) {
    const label = clrBtn.querySelector('a-text');
    if (state.clearStepMode) {
      clrBtn.setAttribute('color', '#FF00FF');
      clrBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FF00FF;emissiveIntensity:1.5');
      clrBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000'); // Black text when active
    } else {
      clrBtn.setAttribute('color', '#AA5555');
      clrBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      clrBtn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white'); // White text when inactive
    }
  }
}
function updatePatternLengthButton() {
  const patLenBtn = document.getElementById('patlen');
  if (patLenBtn) {
    const label = patLenBtn.querySelector('a-text');
    if (label) {
      label.setAttribute('value', patterns[state.currentPattern].length.toString());
     
      // Change text color based on button state
      if (patterns[state.currentPattern].length !== 64) {
        label.setAttribute('color', '#000000'); // ‚Üê BLACK TEXT when highlighted
      } else {
        label.setAttribute('color', 'white'); // ‚Üê WHITE TEXT when normal
      }
    }
   
    // Highlight if not default length
    if (patterns[state.currentPattern].length !== 64) {
      patLenBtn.setAttribute('color', '#00FFAA');
      patLenBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FFAA;emissiveIntensity:1.5');
      patLenBtn.setAttribute('scale', '1.1 1.1 1.1');
    } else {
      patLenBtn.setAttribute('color', '#5599DD');
      patLenBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      patLenBtn.setAttribute('scale', '1 1 1');
    }
  }
}
function updateQuantizeButton() {
  const qBtn = document.getElementById('quantize');
  if (qBtn) {
    const label = qBtn.querySelector('a-text');
    const quantizeValues = ['Q', '32', '16', '8', '4', '2'];
   
    if (label) {
      label.setAttribute('value', quantizeValues[state.quantize]);
    }
   
    if (state.quantize > 0) {
      qBtn.setAttribute('color', '#00FFAA');
      qBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FFAA;emissiveIntensity:1.5');
      qBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000'); // Black text when active
    } else {
      qBtn.setAttribute('color', '#AA88DD');
      qBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      qBtn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white'); // White text when inactive
    }
  }
}

// ‚Üê ADD THE FUNCTION HERE
function getQuantizedStep(step, blockStart, grid) {
  // Calculate position relative to block
  const relativePos = step - blockStart;
  const offset = relativePos % grid;
  let quantizedRelative;
 
  if (offset < grid / 2) {
    quantizedRelative = relativePos - offset; // Snap backwards
  } else {
    quantizedRelative = relativePos + (grid - offset); // Snap forwards
  }
 
  return blockStart + quantizedRelative;
}

 
function updateCopyStepButton() {
  const cpyBtn = document.getElementById('cpystep');
  if (cpyBtn) {
    const label = cpyBtn.querySelector('a-text');
    if (state.copyStepMode) {
      cpyBtn.setAttribute('color', '#00FFAA');
      cpyBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FFAA;emissiveIntensity:1.5');
      cpyBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000'); // Black text when active
    } else {
      cpyBtn.setAttribute('color', '#5599AA');
      cpyBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      cpyBtn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white'); // White text when inactive
    }
  }
}

function updateHUD() {
  const infoDisplay = document.getElementById('infoDisplay');
  if (infoDisplay) {
    let hudContent = '';
   
    // Show current pattern and next pattern in song mode
    if (state.currentPage === 'song') {
      if (state.isPlaying && state.arrangementMode) {
        // Show current playing pattern and next
        const currentPatternNum = state.songArrangement[state.currentArrangementIndex];
        const nextPatternNum = state.songArrangement[state.currentArrangementIndex + 1];
       
        if (nextPatternNum && nextPatternNum > 0) {
          hudContent = `PATTERN ${currentPatternNum} > ${nextPatternNum}`;
        } else {
          hudContent = `PATTERN ${currentPatternNum} (LAST)`;
        }
      } else {
        // Not playing - just show selected slot's pattern
        const patternNum = state.songArrangement[ui.selectedSongSlot];
        if (patternNum > 0) {
          hudContent = `PATTERN ${patternNum}`;
        } else {
          hudContent = `SLOT ${ui.selectedSongSlot + 1} EMPTY`;
        }
      }
    } else {
      // All other pages - just show current pattern
      hudContent = `PATTERN ${state.currentPattern + 1}`;
    }
   
    infoDisplay.setAttribute('value', hudContent);
    infoDisplay.setAttribute('width', '6.0');
    infoDisplay.setAttribute('color', '#00FFFF');
  }
}

function updateSongProgress() {}

function updateSoundLabel() {
  const lb = document.querySelector('#snd-label a-text');
  if (!lb) return;
 
  if (state.currentTrack === 0) {
    lb.setAttribute('value', 'Drum Kit');
    return;
  }
 
  const map = ['bass', 'lead', 'pad', 'arp'];
  const typ = map[state.currentTrack - 1] || 'bass';
  const idx = state.soundIndex[typ] || 0;
  const name = SAMPLE_BANKS[typ][idx]?.name || `${typ} ${idx + 1}`;
  lb.setAttribute('value', name);
}

function updatePianoKeyColors() {
  if (!ui.pianoKeys) return;
 
  ui.pianoKeys.forEach(btn => {
    if (btn.flashTimeout) return;
   
    const isWhite = btn.dataset.isWhite === 'true';
    if (isWhite) {
      btn.setAttribute('color', '#F8F8F8');
      btn.dataset.originalColor = '#F8F8F8';
    } else {
      btn.setAttribute('color', '#050508');
      btn.dataset.originalColor = '#050508';
    }
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
  });
}

// --- CONTINUES WITH BUILD FUNCTIONS ---
// ============================================================================
// SECTION 5B: BUILD UI & ALL PAGE BUILDERS
// ============================================================================


function buildUI() {
  console.log('üé® Building main UI...');
 
  // Global Undo Button
  const globalUndo = document.getElementById('globalUndo');
  if (globalUndo) {
    globalUndo.innerHTML = '';
    createButton(globalUndo, 0, 0, 0, 0.20, 0.10, 0.08, '#f39c12', 'global-undo', 'UNDO', 'white', true);
  }
 
  // Demo Button - always visible on main screen
  const demoButton = document.getElementById('demoButton');
  if (demoButton) {
    demoButton.innerHTML = '';
    createButton(demoButton, 0, 0, 0, 0.20, 0.10, 0.08, '#CC9933', 'demo-1', 'DEMO', 'white', true);
  }
 
  // Page Navigation Buttons
  const pageButtons = document.getElementById('pageButtons');
  if (pageButtons) {
    pageButtons.innerHTML = '';
    const pageButtonWidth = 0.28;
    const pageButtonSpacing = 0.30;
    const pageButtonStartX = -1.15;
   
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 0), 0, 0, pageButtonWidth, 0.10, 0.08, '#9b5cff', 'page-seq', 'SEQ', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 1), 0, 0, pageButtonWidth, 0.10, 0.08, '#5599AA', 'page-mix', 'MIX', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 2), 0, 0, pageButtonWidth, 0.10, 0.08, '#DD3333', 'page-drum', 'DRUM', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 3), 0, 0, pageButtonWidth, 0.10, 0.08, '#AA55DD', 'page-chord', 'CHORD', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 4), 0, 0, pageButtonWidth, 0.10, 0.08, '#CC8822', 'page-song', 'SONG', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 5), 0, 0, pageButtonWidth, 0.10, 0.08, '#2d6cdf', 'page-file', 'FILE', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 6), 0, 0, pageButtonWidth, 0.10, 0.08, '#f39c12', 'page-edit', 'EDIT', 'white', true);
    createButton(pageButtons, pageButtonStartX + (pageButtonSpacing * 7), 0, 0, pageButtonWidth, 0.10, 0.08, '#AA88CC', 'page-misc', 'MISC', 'white', true);
  }

  // BPM Buttons
  const bpmButtons = document.getElementById('bpmButtons');
if (bpmButtons) {
  bpmButtons.innerHTML = '';
  bpmButtons.setAttribute('position', '-1.75 -0.25 0.05');
  createButton(bpmButtons, 0.00, 0, 0, 0.22, 0.13, 0.08, '#557799', 'bpm-', 'BPM-', 'white', true);
  createButton(bpmButtons, 0.24, 0, 0, 0.22, 0.13, 0.08, '#557799', 'bpm+', 'BPM+', 'white', true);
}

  // Pattern Buttons
  const patternButtons = document.getElementById('patternButtons');
  if (patternButtons) {
    patternButtons.innerHTML = '';
    // Changed Z from 0.04 to 0 in both lines below
    createButton(patternButtons, 0.00, -0.02, 0, 0.20, 0.12, 0.08, '#555577', 'pat-', 'PAT-', 'white', true);
    createButton(patternButtons, 0.22, -0.02, 0, 0.20, 0.12, 0.08, '#555577', 'pat+', 'PAT+', 'white', true);
  }

  // View Buttons
  // View Buttons
const viewContainer = document.getElementById('viewButtons');
if (viewContainer) {
  viewContainer.innerHTML = '';
  ui.viewButtons = [];
  ui.viewButtons.push(createButton(viewContainer, 1.20, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'v1', '1-16', 'white', true));
  ui.viewButtons.push(createButton(viewContainer, 1.42, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'v2', '17-32', 'white', true));
  ui.viewButtons.push(createButton(viewContainer, 1.20, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'v3', '33-48', 'white', true));
  ui.viewButtons.push(createButton(viewContainer, 1.42, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'v4', '49-64', 'white', true));
}

  // Step Buttons
  // Step Buttons - MATCHED TO MIXER POSITION
  const stepC = document.getElementById('stepButtons');
  if (stepC) {
    stepC.innerHTML = '';
    ui.stepButtons = [];
    for (let i = 0; i < 16; i++) {
      const x = (i * 0.13) - 1.1;
      // Changed Z from 0.05 to 0
      ui.stepButtons.push(createButton(stepC, x, 0, 0, 0.12, 0.12, 0.08, '#556677', `step-${i}`, `${i + 1}`, 'white', true));
    }
  }

 // Transport Controls - repositioned
const transport = document.getElementById('transport');
if (transport) {
  transport.innerHTML = '';
  transport.setAttribute('position', '-1.75 0 0.05');
  createButton(transport, 0.00, -0.42, 0, 0.22, 0.13, 0.08, '#33AA55', 'play', 'PLAY', 'white', true);
  createButton(transport, 0.24, -0.42, 0, 0.22, 0.13, 0.08, '#DD3333', 'stop', 'STOP', 'white', true);
  createButton(transport, 0.00, -0.59, 0, 0.22, 0.13, 0.08, '#CC3333', 'record', 'REC', 'white', true);
  createButton(transport, 0.24, -0.59, 0, 0.22, 0.13, 0.08, '#AA55DD', 'playblk', 'PLYBLK', 'white', true);
}

 // Left Buttons (Tie/Rest)
  const leftButtons = document.getElementById('leftButtons');
  if (leftButtons) {
    leftButtons.innerHTML = '';
    // Changed Z from 0.04 to 0 in both lines below
    createButton(leftButtons, 0.00, 0.34, 0, 0.12, 0.12, 0.08, '#5599DD', 'osc1', 'OSC1', 'white', true);  // ‚Üê
    createButton(leftButtons, 0.00, 0.20, 0, 0.12, 0.12, 0.08, '#AA88DD', 'quantize', 'Q', 'white', true);
  createButton(leftButtons, 0.00, 0.06, 0, 0.12, 0.12, 0.08, '#6688DD', 'tie', 'TIE', 'white', true);
  createButton(leftButtons, 0.00, -0.08, 0, 0.12, 0.12, 0.08, '#DD8866', 'rest', 'REST', 'white', true);
  }

  // Right Buttons (Clear/Copy Step)
  // Right Buttons (Clear Step/Clear Block)
let rightButtons = document.getElementById('rightButtons');
if (!rightButtons) {
  rightButtons = document.createElement('a-entity');
  rightButtons.setAttribute('id', 'rightButtons');
  rightButtons.setAttribute('position', '1.0 -0.55 0.05');
  document.getElementById('synthWorkstation').appendChild(rightButtons);
}
rightButtons.innerHTML = '';
createButton(rightButtons, 0.00, 0.34, 0, 0.12, 0.12, 0.08, '#5599DD', 'osc2', 'OSC2', 'white', true);  // ‚Üê NEW
createButton(rightButtons, 0.00, 0.20, 0, 0.12, 0.12, 0.08, '#5599DD', 'patlen', '64', 'white', true);
createButton(rightButtons, 0.00, 0.06, 0, 0.12, 0.12, 0.08, '#AA5555', 'clrstep', 'CLRS', 'white', true);
createButton(rightButtons, 0.00, -0.08, 0, 0.12, 0.12, 0.08, '#5599AA', 'clrblock', 'CLRB', 'white', true);

  // Piano Keys
  // Piano Keys & Ambilight Glows
  const pk = document.getElementById('pianoKeys');
  if (pk && pk.children.length === 0) {
    ui.pianoKeys = [];
   
    // Helper to create LED underglow
    const createGlow = (note, x, z, isWhite) => {
      const glow = document.createElement('a-plane');
      glow.setAttribute('id', `glow-${note}`);
      // Glow is slightly wider than the key for that "spill" effect
      glow.setAttribute('width', isWhite ? 0.10 : 0.06);
      glow.setAttribute('height', isWhite ? 0.08 : 0.06);
      // Position it slightly underneath (y = -0.02) and forward
      glow.setAttribute('position', `${x} -0.02 ${z + 0.08}`);
      glow.setAttribute('rotation', '-90 0 0');
      // Start invisible
      glow.setAttribute('material', 'shader:flat; transparent:true; opacity:0; color:#FFF');
      pk.appendChild(glow);
    };

    // White keys
    const whites = ['C2', 'D2', 'E2', 'F2', 'G2', 'A2', 'B2',
                    'C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3',
                    'C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4',
                    'C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5'];
   
    whites.forEach((n, i) => {
      const x = i * 0.12;
      const b = createButton(pk, x, 0, 0.20, 0.11, 0.15, 0.40, '#F8F8F8', `key-${n}`, '', 'black', true);
      b.dataset.note = n;
      b.dataset.isWhite = 'true';
      b.dataset.originalColor = '#F8F8F8';
      ui.pianoKeys.push(b);
     
      // Create the underglow for this white key
      createGlow(n, x, 0.20, true);
    });
   
    // Black keys
    const blacks = [
      ['C#2', 0.06], ['D#2', 0.18], ['F#2', 0.42], ['G#2', 0.54], ['A#2', 0.66],
      ['C#3', 0.90], ['D#3', 1.02], ['F#3', 1.26], ['G#3', 1.38], ['A#3', 1.50],
      ['C#4', 1.74], ['D#4', 1.86], ['F#4', 2.10], ['G#4', 2.22], ['A#4', 2.34],
      ['C#5', 2.58], ['D#5', 2.70], ['F#5', 2.94], ['G#5', 3.06], ['A#5', 3.18]
    ];
   
    blacks.forEach(([n, x]) => {
      const b = createButton(pk, x, 0.04, 0.12, 0.07, 0.13, 0.27, '#050508', `key-${n}`, '', 'white', true);
      b.dataset.note = n;
      b.dataset.isWhite = 'false';
      b.dataset.originalColor = '#050508';
      ui.pianoKeys.push(b);
     
      // Create the underglow for this black key
      createGlow(n, x, 0.12, false);
    });
   
    console.log(`‚úÖ Created ${ui.pianoKeys.length} piano keys with Ambilight LEDs`);
  }

  // Octave Buttons
 const octaveButtons = document.getElementById('octaveButtons');
  if (octaveButtons) {
    octaveButtons.innerHTML = '';
    // Changed Z from 0.04 to 0 in both lines below
    createButton(octaveButtons, 0, 0, 0, 0.20, 0.12, 0.08, '#557799', 'oct-', 'OCT-', 'white', true);
    createButton(octaveButtons, 0.22, 0, 0, 0.20, 0.12, 0.08, '#557799', 'oct+', 'OCT+', 'white', true);
  }

 // DEBUG: Track drum button visibility changes
setTimeout(() => {
  const drumContainer = document.getElementById('drumButtons');
  if (drumContainer && ui.drumButtons) {
    console.log('üîç Setting up drum button visibility tracker...');
   
    // Monitor the container
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === 'attributes' && mutation.attributeName === 'visible') {
          const newValue = drumContainer.getAttribute('visible');
          console.log('‚ö†Ô∏è DRUM CONTAINER VISIBILITY CHANGED TO:', newValue);
          console.trace('Stack trace:'); // This will show what code changed it
        }
      });
    });
   
    observer.observe(drumContainer, { attributes: true });
   
    // Monitor individual buttons
    ui.drumButtons.forEach((btn, i) => {
      const btnObserver = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.type === 'attributes' && mutation.attributeName === 'visible') {
            const newValue = btn.getAttribute('visible');
            console.log(`‚ö†Ô∏è DRUM BUTTON ${i} VISIBILITY CHANGED TO:`, newValue);
            console.trace('Stack trace:');
          }
        });
      });
      btnObserver.observe(btn, { attributes: true });
    });
   
    console.log('‚úÖ Drum button trackers installed');
  }
}, 2000); // Drum Buttons - FIXED POSITIONING
 // Drum Buttons - FIXED POSITIONING WITH UNIQUE IDs
const drumContainer = document.getElementById('drumButtons');
if (drumContainer && drumContainer.children.length === 0) {
  ui.drumButtons = [];
  const drumNames = ['KICK', 'SNARE', 'HIHAT', 'OPEN'];
  for (let i = 0; i < 4; i++) {
    const x = 0;
    const y = 0.10 - (i * 0.09);
    // CRITICAL: Use "drumsel-" prefix instead of "drum-" to avoid conflicts
    const btn = createButton(drumContainer, x, y, 0.04, 0.30, 0.08, 0.08, drumColors[i], `drumsel-${i}`, drumNames[i], 'white', true);
    btn.dataset.originalColor = drumColors[i];
    ui.drumButtons.push(btn);
  }
 
  // **NEW: Start with drum buttons hidden**
  drumContainer.object3D.visible = false;
  drumContainer.setAttribute('visible', 'false');
  console.log('‚úÖ Drum buttons created and initially hidden');
}

 

  createOsc();
  createVelocityLane();

  updateUI();
  updateSoundLabel();
  updatePianoKeyColors();
  applySynthTilt();
updateUI();
  updateSoundLabel();
  updatePianoKeyColors();
  updateQuantizeButton();  // ‚Üê ADD THIS
  applySynthTilt();

// Attach click handler to power button
  const powerCap = document.getElementById('powerButtonCap');
  if (powerCap) {
    attachClickHandler(powerCap);
    console.log('‚úÖ Power button handler attached');
  }
 
  // Start with everything dimmed if not powered
  if (!state.powered) {
    console.log('üåë Starting in powered-off state');
    setTimeout(() => {
      dimEverything();
    }, 100);
  }
}

function applySynthTilt() {
  const synthWorkstation = document.getElementById('synthWorkstation');
  if (synthWorkstation) {
    synthWorkstation.setAttribute('rotation', `${SYNTH_TILT} 0 0`);
  }
  const pianoKeys = document.getElementById('pianoKeys');
  if (pianoKeys) {
    pianoKeys.setAttribute('rotation', `${-SYNTH_TILT} 0 0`);
  }
  console.log(`‚úÖ Synth tilt set to ${SYNTH_TILT}¬∞`);
}

// BUILD DRUM PAGE
// BUILD DRUM PAGE
// BUILD DRUM PAGE
function buildDrumPage() {
  console.log('ü•Å Building Drum Page...');
  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;

  // **CRITICAL: Hide the main SEQ drum buttons IMMEDIATELY**
  const mainDrumButtons = document.getElementById('drumButtons');
  if (mainDrumButtons) {
    mainDrumButtons.object3D.visible = false;
    mainDrumButtons.setAttribute('visible', 'false');
    console.log('   üîí Hidden main drum selection buttons');
  }
 
  // **ALSO: Force hide all individual drum buttons**
  if (ui.drumButtons && ui.drumButtons.length > 0) {
    ui.drumButtons.forEach(btn => {
      if (btn && btn.object3D) {
        btn.object3D.visible = false;
        btn.setAttribute('visible', 'false');
      }
    });
    console.log('   üîí Hidden all', ui.drumButtons.length, 'drum selection buttons');
  }

  let drumUI = document.getElementById('drumSeqUI');
  if (drumUI && drumUI.parentNode) drumUI.parentNode.removeChild(drumUI);

  drumUI = document.createElement('a-entity');
  drumUI.setAttribute('id', 'drumSeqUI');
  drumUI.setAttribute('position', '0 0 0');
  workstation.appendChild(drumUI);

  // Create 4 rows of 16 step buttons (one row per drum)
  const drumNames = ['KICK', 'SNARE', 'HIHAT', 'OPEN'];
  ui.drumSeqStepButtons = [[], [], [], []];
 
  const startY = -0.19;
  const rowSpacing = 0.13;
  const startX = -0.85;
  const stepSpacing = 0.11;
 
  for (let drumIdx = 0; drumIdx < 4; drumIdx++) {
    const y = startY - (drumIdx * rowSpacing);
   
    // Colored label block
    const labelBox = document.createElement('a-box');
    labelBox.setAttribute('position', `${startX - 0.25} ${y} 0.05`);
    labelBox.setAttribute('width', '0.20');
    labelBox.setAttribute('height', '0.09');
    labelBox.setAttribute('depth', '0.06');
    labelBox.setAttribute('color', drumColors[drumIdx]);
    labelBox.setAttribute('material', `metalness:0.4;roughness:0.5;emissive:${drumColors[drumIdx]};emissiveIntensity:0.8`);
    drumUI.appendChild(labelBox);
   
    // Drum label text
    const label = document.createElement('a-text');
    label.setAttribute('position', `${startX - 0.25} ${y} 0.09`);
    label.setAttribute('value', drumNames[drumIdx]);
    label.setAttribute('align', 'center');
    label.setAttribute('scale', '0.10 0.10 0.10');
    label.setAttribute('color', 'white');
    drumUI.appendChild(label);
   
    // 16 step buttons for this drum
    for (let stepIdx = 0; stepIdx < 16; stepIdx++) {
      const blockNum = Math.floor(stepIdx / 4);
      const blockGap = blockNum * 0.03;
      const x = startX + (stepIdx * stepSpacing) + blockGap;
     const btn = createButton(drumUI, x, y, 0.05, 0.10, 0.09, 0.12, '#334455', `drum-step-${drumIdx}-${stepIdx}`, '', 'white', true);
      ui.drumSeqStepButtons[drumIdx][stepIdx] = btn;
      ui.allButtons.push(btn);
    }
  }
 
  // View buttons
  ui.drumSeqViewButtons = [];
  ui.drumSeqViewButtons.push(createButton(drumUI, 1.20, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'drum-v1', '1-16', 'white', true));
  ui.drumSeqViewButtons.push(createButton(drumUI, 1.42, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'drum-v2', '17-32', 'white', true));
  ui.drumSeqViewButtons.push(createButton(drumUI, 1.20, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'drum-v3', '33-48', 'white', true));
  ui.drumSeqViewButtons.push(createButton(drumUI, 1.42, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'drum-v4', '49-64', 'white', true));
 
  // Pattern controls
  createButton(drumUI, 1.20, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'drum-pat-', 'PAT-', 'white', true);
  createButton(drumUI, 1.42, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'drum-pat+', 'PAT+', 'white', true);
 
  // Clear buttons
  createButton(drumUI, 1.20, -0.60, 0.05, 0.20, 0.12, 0.08, '#AA3333', 'drum-clear-row', 'CLR ROW', 'white', true);
  createButton(drumUI, 1.42, -0.60, 0.05, 0.20, 0.12, 0.08, '#AA3333', 'drum-clear-all', 'CLR ALL', 'white', true);
 
  // BPM controls
  createButton(drumUI, -1.75, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'drum-bpm-', 'BPM-', 'white', true);
  createButton(drumUI, -1.51, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'drum-bpm+', 'BPM+', 'white', true);
 
  // Transport controls
  createButton(drumUI, -1.75, -0.42, 0.04, 0.22, 0.13, 0.08, '#33AA55', 'drum-play', 'PLAY', 'white', true);
  createButton(drumUI, -1.51, -0.42, 0.04, 0.22, 0.13, 0.08, '#DD3333', 'drum-stop', 'STOP', 'white', true);
  createButton(drumUI, -1.75, -0.59, 0.04, 0.22, 0.13, 0.08, '#CC3333', 'drum-rec', 'REC', 'white', true);
  createButton(drumUI, -1.51, -0.59, 0.04, 0.22, 0.13, 0.08, '#AA55DD', 'drum-playblk', 'PLYBLK', 'white', true);

  // **CRITICAL: Save previous track**
  console.log('ü•Å Saving current track before switching:', state.currentTrack);
  state.previousTrack = state.currentTrack;
  console.log('ü•Å Saved previousTrack:', state.previousTrack);
 
  state.currentTrack = 0;
  state.selectedDrum = 'kick';
  updateDrumSeqSteps();
 
  // **FINAL LOCKDOWN: Keep main drum buttons hidden**
  if (mainDrumButtons) {
    mainDrumButtons.object3D.visible = false;
    mainDrumButtons.setAttribute('visible', 'false');
  }
 
  console.log('‚úÖ Drum page built - main buttons should be HIDDEN');
}
// Update drum sequencer steps
function updateDrumSeqSteps() {
  if (!ui.drumSeqStepButtons || ui.drumSeqStepButtons.length === 0) return;
 
  const pat = patterns[state.currentPattern];
  const offset = state.currentStepView * 16;
  const drumNames = ['kick', 'snare', 'hihat', 'open'];
 
  // Update all 4 rows of drum step buttons
  for (let drumIdx = 0; drumIdx < 4; drumIdx++) {
    const drumName = drumNames[drumIdx];
   
    ui.drumSeqStepButtons[drumIdx].forEach((btn, stepIdx) => {
      const step = offset + stepIdx;
      const isActive = pat.drums[drumName][step];
     
      if (state.isPlaying && step === state.currentStep) {
        // Playing step - green
        btn.setAttribute('color', '#00FF00');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:2.5');
      } else if (step === state.highlightedStep) {
        // Selected step - purple
        btn.setAttribute('color', '#9b5cff');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#9b5cff;emissiveIntensity:1.5');
      } else if (isActive) {
        // Active drum hit - drum color
        btn.setAttribute('color', drumColors[drumIdx]);
        btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${drumColors[drumIdx]};emissiveIntensity:1.5`);
      } else {
        // Empty step - dark
        btn.setAttribute('color', '#334455');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      }
    });
  }
 
  // Update view buttons
  if (ui.drumSeqViewButtons) {
    ui.drumSeqViewButtons.forEach((btn, i) => {
      if (i === state.currentStepView) {
        btn.setAttribute('color', '#9b5cff');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#9b5cff;emissiveIntensity:1.2');
      } else {
        btn.setAttribute('color', '#336688');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      }
    });
  }
}

// BUILD CHORD PAGE
function buildChordPage() {
  console.log('üéπ Building Chord Page...');
  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;

  // **NUCLEAR: Force remove drum buttons completely**
  const drumContainer = document.getElementById('drumButtons');
  if (drumContainer) {
    drumContainer.object3D.visible = false;
    drumContainer.setAttribute('visible', 'false');
    drumContainer.object3D.position.set(0, -1000, 0); // Teleport away
    // Disable all child buttons
    if (ui.drumButtons) {
      ui.drumButtons.forEach(btn => {
        if (btn && btn.object3D) {
          btn.object3D.visible = false;
          btn.setAttribute('visible', 'false');
          btn.classList.remove('clickable'); // Remove clickability
        }
      });
    }
    console.log('üîí NUCLEAR: Drum buttons disabled on chord page');
  }
 
  // Clear old button references
  ui.chordStepButtons = [];
  ui.chordRootButtons = [];
  ui.chordTypeButtons = [];

  // Create fresh chordUI
  chordUI = document.createElement('a-entity');
  chordUI.setAttribute('id', 'chordUI');
  chordUI.setAttribute('position', '0 0 0');
  workstation.appendChild(chordUI);
 
  console.log('‚úÖ Created fresh chordUI');

  // Root selection buttons (top row - chord notes)
  // Root selection buttons (top row - chord notes)
const rootStartX = -0.78;
const rootY = -0.28;
for (let i = 0; i < 12; i++) {
  const x = rootStartX + (i * 0.13);
  const btn = createButton(chordUI, x, rootY, 0.05, 0.12, 0.10, 0.08, chordColors[i], `chord-root-${i}`, chordRoots[i], 'black', true);
  //                                      ^^^^ Changed from 0.15
  ui.chordRootButtons.push(btn);
}

  // Chord type buttons (middle rows)
  const typeStartX = -0.45;
  const typeY1 = -0.42;
  const typeY2 = -0.54;
  for (let i = 0; i < 8; i++) {
    const x = typeStartX + ((i % 4) * 0.30);
    const y = i < 4 ? typeY1 : typeY2;
    const btn = createButton(chordUI, x, y, 0.05, 0.28, 0.10, 0.06, '#5588AA', `chord-type-${i}`, chordTypes[i], 'white', true);
    ui.chordTypeButtons.push(btn);
  }

  // **STEP BUTTONS - numbered 1-16**
  const stepStartX = -1.04;
  const stepY = -0.70;
  console.log('üéπ Creating 16 chord step buttons...');
 
  for (let i = 0; i < 16; i++) {
    const x = stepStartX + (i * 0.13);
    const btn = createButton(chordUI, x, stepY, 0.05, 0.12, 0.12, 0.08, '#334455', `chord-step-${i}`, `${i + 1}`, 'white', true);
    ui.chordStepButtons.push(btn);
    console.log(`  ‚úÖ Button ${i} created with ID: ${btn.id}`);
  }
 
  console.log('‚úÖ Created', ui.chordStepButtons.length, 'chord step buttons');

  // Transport & BPM controls (left side)
  createButton(chordUI, -1.75, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'chord-bpm-', 'BPM-', 'white', true);
  createButton(chordUI, -1.51, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'chord-bpm+', 'BPM+', 'white', true);
  createButton(chordUI, -1.75, -0.42, 0.04, 0.22, 0.13, 0.08, '#33AA55', 'chord-play2', 'PLAY', 'white', true);
  createButton(chordUI, -1.51, -0.42, 0.04, 0.22, 0.13, 0.08, '#DD3333', 'chord-stop2', 'STOP', 'white', true);
  createButton(chordUI, -1.75, -0.59, 0.04, 0.22, 0.13, 0.08, '#CC3333', 'chord-rec', 'REC', 'white', true);
  createButton(chordUI, -1.51, -0.59, 0.04, 0.22, 0.13, 0.08, '#AA55DD', 'chord-playblk', 'PLYBLK', 'white', true);

  // Pattern controls (right side)
  createButton(chordUI, 1.20, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'chord-pat-', 'PAT-', 'white', true);
  createButton(chordUI, 1.42, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'chord-pat+', 'PAT+', 'white', true);

  // Write and Clear buttons (right side bottom)
  createButton(chordUI, 1.20, -0.60, 0.05, 0.20, 0.12, 0.08, '#0000AA', 'chord-write', 'WRITE', 'white', true);
  createButton(chordUI, 1.42, -0.60, 0.05, 0.20, 0.12, 0.08, '#AA3333', 'chord-clear', 'CLEAR', 'white', true);
// LEFT SIDE COPY/PASTE BLOCK BUTTONS (aligned with chord type buttons)
createButton(chordUI, -0.95, -0.42, 0.05, 0.20, 0.10, 0.08, '#00BBFF', 'chord-cpyb', 'CPYB', 'white', true);
createButton(chordUI, -0.95, -0.54, 0.05, 0.20, 0.10, 0.08, '#00BBFF', 'chord-pstb', 'PSTB', 'white', true);

// RIGHT SIDE COPY/PASTE PATTERN BUTTONS (aligned with chord type buttons - moved further right)
createButton(chordUI, 0.90, -0.42, 0.05, 0.20, 0.10, 0.08, '#FF3388', 'chord-cpyp', 'CPYP', 'white', true);
createButton(chordUI, 0.90, -0.54, 0.05, 0.20, 0.10, 0.08, '#FF3388', 'chord-pstp', 'PSTP', 'white', true);
  state.currentTrack = 4;
 
  if (state.chordSelectionRoot === null) state.chordSelectionRoot = 0;
  if (state.chordSelectionType === null) state.chordSelectionType = 0;
 
  // **FORCE UPDATE AFTER SHORT DELAY**
  setTimeout(() => {
    updateChordSteps();
    updateUI();
    console.log('üéπ Chord page initialized with', ui.chordStepButtons.length, 'step buttons');
  }, 100);
}

// Update chord sequencer steps
// Update chord sequencer steps
function updateChordSteps() {
  if (!ui.chordStepButtons || ui.chordStepButtons.length === 0) return;
 
  const pat = patterns[state.currentPattern];
  const offset = state.currentStepView * 16;
 
  console.log('üé® updateChordSteps called - Pattern:', state.currentPattern, 'View:', state.currentStepView, 'Offset:', offset);
 
  // UPDATE existing buttons instead of recreating them
  ui.chordStepButtons.forEach((btn, i) => {
    const step = offset + i;
    const chord = pat.arpChords[step];
   
    // Determine color based on state
    let btnColor = '#334455'; // Default dark
    let emissive = '#000';
    let emissiveIntensity = 0;
    let scale = '1 1 1';
   
    if (state.isPlaying && step === state.currentStep) {
      btnColor = '#00FF00';
      emissive = '#00FF00';
      emissiveIntensity = 3.5;
    } else if (step === state.highlightedStep) {
      // Highlighted step - purple
      btnColor = purple;
      emissive = purple;
      emissiveIntensity = 2.5;
      scale = '1.1 1.1 1.1';
    } else if (chord && chord.root !== undefined) {
      // **DARK button with colored subtle glow**
      btnColor = '#2a2a3a';
      emissive = chordColors[chord.root];
      emissiveIntensity = 0.1;
      scale = '1.0 1.0 1.0';
    }
   
    // Update button appearance
    btn.setAttribute('color', btnColor);
    btn.setAttribute('material', `metalness:0.1;roughness:0.9;emissive:${emissive};emissiveIntensity:${emissiveIntensity}`);
    btn.setAttribute('scale', scale);
   
    // **NEW: Update label text with chord name**
    const label = btn.querySelector('a-text');
    if (label) {
      if (chord && chord.root !== undefined) {
        // Build chord name (e.g., "Cm", "F7", "Gmaj")
        const rootName = chordRoots[chord.root];
        const typeName = chordTypes[chord.type];
       
        let chordName = rootName;
       
        // Shorten common chord types for readability
        if (typeName === 'MAJ') {
          chordName = rootName; // Just "C"
        } else if (typeName === 'MIN') {
          chordName = rootName + 'm'; // "Cm"
        } else if (typeName === '7TH') {
          chordName = rootName + '7'; // "C7"
        } else if (typeName === 'M7') {
          chordName = rootName + 'm7'; // "Cm7"
        } else if (typeName === 'DIM') {
          chordName = rootName + '¬∞'; // "C¬∞"
        } else if (typeName === 'AUG') {
          chordName = rootName + '+'; // "C+"
        } else {
          chordName = rootName + typeName; // "Csus2", "Csus4"
        }
       
        label.setAttribute('value', chordName);
        label.setAttribute('color', '#FFFFFF'); // White text for contrast
        label.setAttribute('scale', '0.22 0.22 0.22'); // Bigger for chord names
       
      } else {
        // Empty step - show step number
        label.setAttribute('value', `${i + 1}`);
        label.setAttribute('color', '#AAAAAA');
        label.setAttribute('scale', '0.15 0.15 0.15');
      }
    }
  });
 
  console.log('üé® updateChordSteps complete - buttons updated');
 
  // Update view buttons
  // Update view buttons
if (ui.chordViewButtons) {
  ui.chordViewButtons.forEach((btn, i) => {
    const blockStart = i * 16;
    const isBlockActive = blockStart < patterns[state.currentPattern].length;
   
    if (!isBlockActive) {
      btn.setAttribute('color', '#1a1a2a');
      btn.setAttribute('material', 'metalness:.5;roughness:.5;emissive:#000;emissiveIntensity:0;opacity:0.3;transparent:true');
      btn.setAttribute('scale', '0.95 0.95 0.95');
    } else if (i === state.currentStepView) {
      btn.setAttribute('color', purple);
      btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:1.2;opacity:1;transparent:false`);
    } else {
      btn.setAttribute('color', '#336688');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0;opacity:1;transparent:false');
    }
  });
}
 
  // Update root selection buttons
  if (ui.chordRootButtons) {
    ui.chordRootButtons.forEach((btn, i) => {
      if (state.chordSelectionRoot === i) {
        btn.setAttribute('material', `metalness:0.3;roughness:0.6;emissive:#FFFFFF;emissiveIntensity:1.5`);
        btn.setAttribute('scale', '1.1 1.1 1.1');
      } else {
        btn.setAttribute('material', `metalness:0.3;roughness:0.6;emissive:#000;emissiveIntensity:0`);
        btn.setAttribute('scale', '1 1 1');
      }
    });
  }
 
  // Update chord type buttons
  if (ui.chordTypeButtons) {
    ui.chordTypeButtons.forEach((btn, i) => {
      if (state.chordSelectionType === i) {
        btn.setAttribute('color', '#00FFAA'); // Cyan when selected
        btn.setAttribute('material', `metalness:0.3;roughness:0.6;emissive:#FFFFFF;emissiveIntensity:1.5`);
        btn.setAttribute('scale', '1.1 1.1 1.1');
      } else {
        btn.setAttribute('color', '#5588AA'); // Original blue
        btn.setAttribute('material', `metalness:0.3;roughness:0.6;emissive:#000;emissiveIntensity:0`);
        btn.setAttribute('scale', '1 1 1');
      }
    });
  }
}


// BUILD SONG PAGE
// BUILD SONG PAGE
function buildSongPage() {
  console.log('üéº Building Song Page...');
  // REMOVED THE CRASHING LINE HERE (The one referencing 'offset')

  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;

  let songUI = document.getElementById('songUI');
  if (songUI && songUI.parentNode) songUI.parentNode.removeChild(songUI);

  songUI = document.createElement('a-entity');
  songUI.setAttribute('id', 'songUI');
  songUI.setAttribute('position', '0 0 0');
  workstation.appendChild(songUI);

  // 1. ADDED MISSING PATTERN DISPLAY (Required for updateSongSlots to work)
  const patDisplay = document.createElement('a-text');
  patDisplay.setAttribute('id', 'song-current-pat-display');
  patDisplay.setAttribute('position', '0 0.55 0.05'); // Placed below title
  patDisplay.setAttribute('align', 'center');
  patDisplay.setAttribute('value', 'PATTERN 1');
  patDisplay.setAttribute('width', '6');
  patDisplay.setAttribute('color', '#FFFFFF');
  songUI.appendChild(patDisplay);

 
  // 64 Song slot buttons (4 rows of 16) - IMPROVED VISUALS
// 64 Song slot buttons (4 rows of 16) - IMPROVED VISUALS
ui.songSlotButtons = [];
ui.selectedSongSlot = ui.selectedSongSlot || 0;
for (let row = 0; row < 4; row++) {
  for (let col = 0; col < 16; col++) {
    const slotIndex = row * 16 + col;
 const x = (col * 0.13) - 1.10;
    const y = -0.25 - (row * 0.14);
   
    // Create button with better depth and material
    const btn = createButton(songUI, x, y, 0.05, 0.12, 0.12, 0.08, '#334455', `song-slot-${slotIndex}`, '', 'white', true);
   
    // Enhanced material properties for better look
    btn.setAttribute('material', 'metalness:0.6;roughness:0.3;emissive:#000;emissiveIntensity:0');
   
    ui.songSlotButtons.push(btn);
    ui.allButtons.push(btn);
  }
}

  // BPM controls (left side TOP)
  createButton(songUI, -1.75, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'song-bpm-', 'BPM-', 'white', true);
  createButton(songUI, -1.51, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'song-bpm+', 'BPM+', 'white', true);

  // Transport controls - standardized position
// Transport controls - standardized position
createButton(songUI, -1.75, -0.42, 0.04, 0.22, 0.13, 0.08, '#33AA55', 'song-play', 'PLAY', 'white', true);
createButton(songUI, -1.51, -0.42, 0.04, 0.22, 0.13, 0.08, '#DD3333', 'song-stop', 'STOP', 'white', true);


  // Transport controls row 2 - standardized position
  createButton(songUI, -1.75, -0.59, 0.04, 0.22, 0.13, 0.08, '#CC3333', 'song-rec', 'REC', 'white', true);
  createButton(songUI, -1.51, -0.59, 0.04, 0.22, 0.13, 0.08, '#AA55DD', 'song-playblk', 'PLYBLK', 'white', true);

  // Pattern selector (right side)
  createButton(songUI, 1.20, -0.18, 0.10, 0.20, 0.12, 0.04, '#555577', 'song-pat-', 'PAT-', 'white', true);
  createButton(songUI, 1.42, -0.18, 0.10, 0.20, 0.12, 0.04, '#555577', 'song-pat+', 'PAT+', 'white', true);

  // ADD and CLEAR buttons
  createButton(songUI, 1.20, -0.32, 0.10, 0.20, 0.12, 0.04, '#0000AA', 'song-add', 'ADD', 'white', true);
  createButton(songUI, 1.42, -0.32, 0.10, 0.20, 0.12, 0.04, '#AA3333', 'song-clear', 'CLEAR', 'white', true);

  // INS and REM buttons
  createButton(songUI, 1.20, -0.46, 0.10, 0.20, 0.12, 0.04, '#5599AA', 'song-ins', 'INS', 'white', true);
  createButton(songUI, 1.42, -0.46, 0.10, 0.20, 0.12, 0.04, '#AA5566', 'song-rem', 'REM', 'white', true);

  // Force hide individual buttons
  setTimeout(() => {
    console.log('üîí SONG PAGE: Forcing view buttons hidden');
    const viewContainer = document.getElementById('viewButtons');
    if (viewContainer) {
      viewContainer.object3D.visible = false;
      viewContainer.setAttribute('visible', 'false');
    }
    ['v1', 'v2', 'v3', 'v4'].forEach(btnId => {
      const btn = document.getElementById(btnId);
      if (btn) {
        btn.object3D.visible = false;
        btn.setAttribute('visible', 'false');
      }
    });
  }, 500);

  updateSongSlots();
}

function updateSongSlots() {
  if (!ui.songSlotButtons || ui.songSlotButtons.length === 0) return;
  if (typeof ui.selectedSongSlot === 'undefined') ui.selectedSongSlot = 0;

  ui.songSlotButtons.forEach((btn, i) => {
    const patternNum = state.songArrangement[i];
   
    let label = btn.querySelector('a-text');
    if (!label) {
      label = document.createElement('a-text');
      label.setAttribute('align', 'center');
      label.setAttribute('position', '0 0 0.055');
      btn.appendChild(label);
    }
   
    let textValue = patternNum > 0 ? `${patternNum}` : '-';
    let textColor = '#FFFFFF';
    let textScale = patternNum > 0 ? '0.35 0.35 0.35' : '0.15 0.15 0.15';

    // PRIORITY 1: PLAYING HEAD (Inverted - BLACK background, WHITE text)
    if (state.isPlaying && state.arrangementMode && i === state.currentArrangementIndex) {
      btn.setAttribute('color', '#000000');  // BLACK background
      btn.setAttribute('material', 'metalness:0.3;roughness:0.6;emissive:#000000;emissiveIntensity:0');
      btn.setAttribute('scale', '1.2 1.2 1.2');
      textColor = '#FFFFFF';  // WHITE text
      textScale = '0.45 0.45 0.45';
    }
    // PRIORITY 2: SELECTED CURSOR (BLACK background, WHITE text with purple glow)
    else if (i === ui.selectedSongSlot) {
      btn.setAttribute('color', '#000000');  // ‚Üê BLACK background
      btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:#9b5cff;emissiveIntensity:1.5`);  // ‚Üê Purple glow
      btn.setAttribute('scale', '1.15 1.15 1.15');
      textColor = '#FFFFFF';  // ‚Üê WHITE text
    }
    // PRIORITY 3: FILLED SLOT
    else if (patternNum > 0) {
      const color = patternColors[patternNum] || '#5588AA';
      btn.setAttribute('color', color);
      btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${color};emissiveIntensity:0.4`);
      btn.setAttribute('scale', '1 1 1');
      textColor = '#000000';
    }
    // PRIORITY 4: EMPTY SLOT
    else {
      btn.setAttribute('color', '#334455');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      btn.setAttribute('scale', '1 1 1');
      textColor = '#555555';
    }

    label.setAttribute('value', textValue);
    label.setAttribute('color', textColor);
    label.setAttribute('scale', textScale);
    label.setAttribute('visible', 'true');
  });

  const patDisplay = document.getElementById('song-current-pat-display');
  if (patDisplay) patDisplay.setAttribute('value', `PATTERN ${state.currentPattern + 1}`);
}

// BUILD FILE PAGE
// BUILD FILE PAGE
function buildFilePage() {
  console.log('üìÅ Building File Page...');
  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;

  let fileUI = document.getElementById('fileUI');
  if (fileUI && fileUI.parentNode) fileUI.parentNode.removeChild(fileUI);

  fileUI = document.createElement('a-entity');
  fileUI.setAttribute('id', 'fileUI');
  fileUI.setAttribute('position', '0 0 0');
  workstation.appendChild(fileUI);

  // Single row of 4 buttons, moved down
  createButton(fileUI, -0.75, -0.35, 0.05, 0.40, 0.15, 0.08, '#2d6cdf', 'file-save', 'SAVE', 'white', true);
  createButton(fileUI, -0.25, -0.35, 0.05, 0.40, 0.15, 0.08, '#2d6cdf', 'file-load', 'LOAD', 'white', true);
  createButton(fileUI, 0.25, -0.35, 0.05, 0.40, 0.15, 0.08, '#CC9933', 'demo-1', 'AMPLE', 'white', true);
  createButton(fileUI, 0.75, -0.35, 0.05, 0.40, 0.15, 0.08, '#9b5cff', 'file-midi', 'MIDI', 'white', true);

  const infoDisplay = document.getElementById('infoDisplay');
  if (infoDisplay) {
    infoDisplay.object3D.visible = true;
    infoDisplay.setAttribute('visible', 'true');
  }
}


// BUILD EDIT PAGE
function buildEditPage() {
  console.log('‚úèÔ∏è Building Edit Page...');
  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;

  let editUI = document.getElementById('editUI');
  if (editUI && editUI.parentNode) editUI.parentNode.removeChild(editUI);

  editUI = document.createElement('a-entity');
  editUI.setAttribute('id', 'editUI');
  editUI.setAttribute('position', '0 0 0');
  workstation.appendChild(editUI);

  // BPM controls (left side TOP)
  createButton(editUI, -1.75, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'edit-bpm-', 'BPM-', 'white', true);
  createButton(editUI, -1.51, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'edit-bpm+', 'BPM+', 'white', true);
 
  // Transport controls (left side SECOND ROW)
  createButton(editUI, -1.75, -0.42, 0.04, 0.22, 0.13, 0.08, '#33AA55', 'edit-play', 'PLAY', 'white', true);
  createButton(editUI, -1.51, -0.42, 0.04, 0.22, 0.13, 0.08, '#DD3333', 'edit-stop', 'STOP', 'white', true);
 
  // Transport controls (left side THIRD ROW)
  createButton(editUI, -1.75, -0.59, 0.04, 0.22, 0.13, 0.08, '#CC3333', 'edit-rec', 'REC', 'white', true);
  createButton(editUI, -1.51, -0.59, 0.04, 0.22, 0.13, 0.08, '#AA55DD', 'edit-playblk', 'PLYBLK', 'white', true);

  // COPY/PASTE/CLEAR PATTERN - MOVED DOWN to avoid HUD overlap
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COPY/PASTE/CLEAR BUTTONS - REORGANIZED IN 3x2 GRID
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Row 1: COPY PAT | COPY TRK | CLEAR PAT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COPY/PASTE/CLEAR BUTTONS - 3x2 GRID WITH COLUMN COLOR CODING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COPY/PASTE PATTERN/TRACK - TOP 2 ROWS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Column 1: COPY (Cyan)
createButton(editUI, -1.05, -0.25, 0.05, 0.30, 0.12, 0.08, '#5599AA', 'edit-copy-pat', 'COPY PAT', 'white', true);
createButton(editUI, -1.05, -0.39, 0.05, 0.30, 0.12, 0.08, '#5599AA', 'edit-paste-pat', 'PASTE PAT', 'white', true);

// Column 2: TRACK (Purple)
createButton(editUI, -0.70, -0.25, 0.05, 0.30, 0.12, 0.08, '#9955DD', 'edit-copy-trk', 'COPY TRK', 'white', true);
createButton(editUI, -0.70, -0.39, 0.05, 0.30, 0.12, 0.08, '#9955DD', 'edit-paste-trk', 'PASTE TRK', 'white', true);

// NEW BLOCK COPY/PASTE BUTTONS - Column 3
createButton(editUI, -0.35, -0.25, 0.05, 0.30, 0.12, 0.08, '#00BBFF', 'edit-copy-block', 'CPYB', 'white', true);
createButton(editUI, -0.35, -0.39, 0.05, 0.30, 0.12, 0.08, '#00BBFF', 'edit-paste-block', 'PSTB', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ARP CONTROLS - MOVED FURTHER LEFT AND DOWN
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
createButton(editUI, -1.05, -0.60, 0.04, 0.22, 0.12, 0.08, '#9b5cff', 'edit-arp-toggle', 'ARP', 'white', true);
createButton(editUI, -0.79, -0.60, 0.04, 0.22, 0.12, 0.08, '#00AA00', 'edit-arp-write', 'WRITE', 'white', true);

// Time subdivision button
const timeBtn = document.createElement('a-box');
timeBtn.setAttribute('class', 'clickable');
timeBtn.setAttribute('position', '-0.51 -0.60 0.04');
timeBtn.setAttribute('width', '0.25');
timeBtn.setAttribute('height', '0.12');
timeBtn.setAttribute('depth', '0.08');
timeBtn.setAttribute('color', '#AA55DD');
timeBtn.setAttribute('material', 'metalness:.3;roughness:.6');
timeBtn.setAttribute('id', 'edit-arp-time');
timeBtn.dataset.buttonId = 'edit-arp-time';

const timeLabel = document.createElement('a-text');
timeLabel.setAttribute('id', 'edit-arp-time-label');
timeLabel.setAttribute('value', arpTimeSubdivisions[state.arp.timeSubdivision]);
timeLabel.setAttribute('align', 'center');
timeLabel.setAttribute('position', '0 0 0.045');
timeLabel.setAttribute('scale', '0.15 0.15 0.15');
timeLabel.setAttribute('color', 'white');
timeBtn.appendChild(timeLabel);
editUI.appendChild(timeBtn);
attachClickHandler(timeBtn);

// Arp pattern type button
const typeBtn = document.createElement('a-box');
typeBtn.setAttribute('class', 'clickable');
typeBtn.setAttribute('position', '-0.22 -0.60 0.04');
typeBtn.setAttribute('width', '0.25');
typeBtn.setAttribute('height', '0.12');
typeBtn.setAttribute('depth', '0.08');
typeBtn.setAttribute('color', '#5599AA');
typeBtn.setAttribute('material', 'metalness:.3;roughness:.6');
typeBtn.setAttribute('id', 'edit-arp-type');
typeBtn.dataset.buttonId = 'edit-arp-type';

const typeLabel = document.createElement('a-text');
typeLabel.setAttribute('id', 'edit-arp-type-label');
typeLabel.setAttribute('value', arpPatterns[state.arp.pattern]);
typeLabel.setAttribute('align', 'center');
typeLabel.setAttribute('position', '0 0 0.045');
typeLabel.setAttribute('scale', '0.15 0.15 0.15');
typeLabel.setAttribute('color', 'white');
typeBtn.appendChild(typeLabel);
editUI.appendChild(typeBtn);
attachClickHandler(typeBtn);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BEAT/FILL/BASS/RAND GENERATORS - ALIGNED WITH TOP ROW
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
createButton(editUI, 0.10, -0.25, 0.05, 0.22, 0.12, 0.08, '#9b5cff', 'edit-gen-beat', 'BEAT', 'white', true);
createButton(editUI, 0.34, -0.25, 0.05, 0.22, 0.12, 0.08, '#AA55DD', 'edit-gen-fill', 'FILL', 'white', true);
createButton(editUI, 0.10, -0.39, 0.05, 0.22, 0.12, 0.08, '#5599AA', 'edit-gen-bass', 'BASS', 'white', true);
createButton(editUI, 0.34, -0.39, 0.05, 0.22, 0.12, 0.08, '#DD8833', 'edit-gen-rand', 'RAND', 'white', true);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TRANSPOSE BUTTONS - ALIGNED WITH TOP ROW
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
createButton(editUI, 0.62, -0.25, 0.05, 0.22, 0.12, 0.08, '#CC8844', 'edit-trans+1', '+1', 'white', true);
createButton(editUI, 0.86, -0.25, 0.05, 0.22, 0.12, 0.08, '#CC8844', 'edit-trans+12', '+12', 'white', true);
createButton(editUI, 0.62, -0.39, 0.05, 0.22, 0.12, 0.08, '#CC8844', 'edit-trans-1', '-1', 'white', true);
createButton(editUI, 0.86, -0.39, 0.05, 0.22, 0.12, 0.08, '#CC8844', 'edit-trans-12', '-12', 'white', true);
// CLEAR BUTTONS - UNDER TRANSPOSE (Row 3)
createButton(editUI, 0.62, -0.53, 0.05, 0.22, 0.12, 0.08, '#DD5555', 'edit-clear-pat', 'CLR PAT', 'white', true);
createButton(editUI, 0.86, -0.53, 0.05, 0.22, 0.12, 0.08, '#DD5555', 'edit-clear-trk', 'CLR TRK', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // VIEW BUTTONS - STANDARDIZED POSITION (SAME AS MIXER/CHORD)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  ui.editViewButtons = [];
  ui.editViewButtons.push(createButton(editUI, 1.20, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'edit-v1', '1-16', 'white', true));
  ui.editViewButtons.push(createButton(editUI, 1.42, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'edit-v2', '17-32', 'white', true));
  ui.editViewButtons.push(createButton(editUI, 1.20, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'edit-v3', '33-48', 'white', true));
  ui.editViewButtons.push(createButton(editUI, 1.42, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'edit-v4', '49-64', 'white', true));

  // PATTERN CONTROLS - STANDARDIZED POSITION
  createButton(editUI, 1.20, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'edit-pat-', 'PAT-', 'white', true);
  createButton(editUI, 1.42, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'edit-pat+', 'PAT+', 'white', true);

  // DECAY CONTROLS - STANDARDIZED POSITION
  // DECAY CONTROLS - STANDARDIZED POSITION
// DECAY CONTROLS - MOVED TO AVOID OCTAVE BUTTON OVERLAP
createButton(editUI, 1.20, -0.60, 0.05, 0.20, 0.12, 0.08, '#AA88CC', 'edit-decay-', 'DEC-', 'white', true);
createButton(editUI, 1.42, -0.60, 0.05, 0.20, 0.12, 0.08, '#AA88CC', 'edit-decay+', 'DEC+', 'white', true);
const octaveButtons = document.getElementById('octaveButtons');
if (octaveButtons) {
  octaveButtons.object3D.visible = false;
  octaveButtons.setAttribute('visible', 'false');
}
  const infoDisplay = document.getElementById('infoDisplay');
  if (infoDisplay) {
    infoDisplay.object3D.visible = true;
    infoDisplay.setAttribute('visible', 'true');
  }
 
  updateEditViewButtons();
  updateEditSteps();
 
  // Initialize ARP displays
  setTimeout(() => {
    updateEditArpDisplay();
  }, 100);
}

// GENERATOR FUNCTIONS

function generateRandomBeat() {
  const pat = patterns[state.currentPattern];
 
  // Generate kick pattern - every 4 steps with variation
  for (let i = 0; i < 64; i += 4) {
    pat.drums.kick[i] = true;
    pat.drumVelocity.kick[i] = 0.8 + (Math.random() * 0.2);
  }
 
  // Generate snare pattern - on beats 2 and 4
  for (let i = 4; i < 64; i += 8) {
    pat.drums.snare[i] = true;
    pat.drumVelocity.snare[i] = 0.8 + (Math.random() * 0.2);
  }
 
  // Generate hihat pattern - 16th notes with variation
  for (let i = 0; i < 64; i += 2) {
    pat.drums.hihat[i] = Math.random() > 0.2;
    pat.drumVelocity.hihat[i] = 0.5 + (Math.random() * 0.3);
  }
 
  // Random open hihats
  for (let i = 0; i < 64; i += 16) {
    if (Math.random() > 0.5) {
      pat.drums.open[i + 8] = true;
      pat.drumVelocity.open[i + 8] = 0.6 + (Math.random() * 0.2);
    }
  }
}

function generateRandomFill() {
  const pat = patterns[state.currentPattern];
  const blockStart = state.currentStepView * 16;
  const blockEnd = blockStart + 16;
 
  // Clear the current block first
  ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
    for (let i = blockStart; i < blockEnd; i++) {
      pat.drums[drum][i] = false;
    }
  });
 
  // Generate fill pattern in current block
  for (let i = blockStart; i < blockEnd; i++) {
    // Kick on strong beats
    if ((i - blockStart) % 4 === 0) {
      pat.drums.kick[i] = Math.random() > 0.3;
      pat.drumVelocity.kick[i] = 0.8 + (Math.random() * 0.2);
    }
   
    // Snare rolls
    if ((i - blockStart) % 2 === 1) {
      pat.drums.snare[i] = Math.random() > 0.4;
      pat.drumVelocity.snare[i] = 0.7 + (Math.random() * 0.3);
    }
   
    // Dense hihat
    pat.drums.hihat[i] = Math.random() > 0.1;
    pat.drumVelocity.hihat[i] = 0.5 + (Math.random() * 0.4);
  }
}

function generateBassline() {
  const pat = patterns[state.currentPattern];
  const scale = ['C2', 'D2', 'E2', 'F2', 'G2', 'A2', 'B2', 'C3'];
 
  // Generate bassline for whole pattern
  for (let i = 0; i < 64; i += 4) {
    const note = scale[Math.floor(Math.random() * scale.length)];
    pat.bass[i] = note;
    pat.velocity.bass[i] = 0.7 + (Math.random() * 0.2);
   
    // Add some ties
    if (Math.random() > 0.6 && i + 2 < 64) {
      pat.bass[i + 2] = 'TIE';
    }
  }
}

function generateRandomPattern() {
  const pat = patterns[state.currentPattern];
 
  // Randomize drums
  generateRandomBeat();
 
  // Randomize bass
  generateBassline();
 
  // Randomize lead (octave higher)
  const leadScale = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
  for (let i = 0; i < 64; i++) {
    if (Math.random() > 0.6) {
      pat.lead[i] = leadScale[Math.floor(Math.random() * leadScale.length)];
      pat.velocity.lead[i] = 0.6 + (Math.random() * 0.3);
    } else {
      pat.lead[i] = '';
    }
  }
}

// Add function to update edit step buttons
function updateEditSteps() {
  if (!ui.editStepButtons || ui.editStepButtons.length === 0) return;
 
  const pat = patterns[state.currentPattern];
  const offset = state.currentStepView * 16;

  ui.editStepButtons.forEach((btn, i) => {
    const step = offset + i;
    const beyondLength = step >= patterns[state.currentPattern].length;
   
    let hasNote = false;
    let stepText = '';
    let targetColor = '#FFFFFF';
   
    if (state.currentTrack === 0) {
      const drumName = state.selectedDrum || 'kick';
      if (pat.drums[drumName] && pat.drums[drumName][step]) hasNote = true;
      const drumIdx = ['kick', 'snare', 'hihat', 'open'].indexOf(drumName);
      if (drumIdx >= 0) targetColor = drumColors[drumIdx];
    } else {
      targetColor = trackColors[state.currentTrack];
      const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
      const currentKey = trackKeys[state.currentTrack];
     
      if (currentKey && pat[currentKey]) {
        const note = pat[currentKey][step];
        if (note && note !== '') {
          hasNote = true;
          if (note === '-' || note === 'TIE') {
            stepText = '/';
            targetColor = '#00FFFF';
          } else if (note === '^' || note === 'REST') {
            stepText = '^';
            targetColor = '#FFAA00';
          }
        }
       
        if (state.currentTrack === 4 && pat.arpChords && pat.arpChords[step]) {
          const root = pat.arpChords[step].root;
          if (typeof root !== 'undefined' && chordColors[root]) {
            targetColor = chordColors[root];
          }
        }
      }
    }
   
    const label = btn.querySelector('a-text');
    if (label) {
      const textColors = ['white', '#0033AA', 'white', 'white', 'white'];
      const currentTextColor = textColors[state.currentTrack];
     
      if (stepText) {
        label.setAttribute('value', stepText);
        label.setAttribute('color', currentTextColor);
        label.setAttribute('scale', '0.25 0.25 0.25');
      } else {
        label.setAttribute('value', `${i + 1}`);
        label.setAttribute('color', currentTextColor);
        label.setAttribute('scale', '0.15 0.15 0.15');
      }
    }
   
    if (beyondLength) {
      btn.setAttribute('color', '#1a1a2a');
      btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
      btn.setAttribute('scale', '1 1 1');
    } else if (state.isPlaying && step === state.currentStep) {
      btn.setAttribute('color', '#00FF00');
      btn.setAttribute('material', 'metalness:0;roughness:1;emissive:#00FF00;emissiveIntensity:3.5');
      btn.setAttribute('scale', '1 1 1');
    } else if (step === state.highlightedStep) {
      btn.setAttribute('color', purple);
      btn.setAttribute('material', `metalness:0;roughness:1;emissive:${purple};emissiveIntensity:2.5`);
      btn.setAttribute('scale', '1.1 1.1 1.1');
    } else if (hasNote) {
      btn.setAttribute('color', targetColor);
      btn.setAttribute('material', `metalness:0;roughness:1;emissive:${targetColor};emissiveIntensity:2.5`);
      btn.setAttribute('scale', '1.05 1.05 1.05');
    } else {
      btn.setAttribute('color', '#0a0a1a');
      btn.setAttribute('material', 'metalness:0.5;roughness:0.5;emissive:#000000;emissiveIntensity:0');
      btn.setAttribute('scale', '1 1 1');
    }
  });
}

// Update function to update edit view buttons
function updateEditViewButtons() {
  if (!ui.editViewButtons) return;
 
  ui.editViewButtons.forEach((btn, i) => {
    if (i === state.currentStepView) {
      btn.setAttribute('color', purple);
      btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:1.2`);
    } else {
      btn.setAttribute('color', '#336688');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    }
  });
}

// Add function to update edit view buttons
function updateEditViewButtons() {
  if (!ui.editViewButtons) return;
 
  ui.editViewButtons.forEach((btn, i) => {
    if (i === state.currentStepView) {
      btn.setAttribute('color', purple);
      btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:1.2`);
    } else {
      btn.setAttribute('color', '#336688');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    }
  });
}

// BUILD MISC PAGE
// MIDI Output
let midiOutput = null;
let midiOutputInitialized = false;

async function initMIDIOutput() {
  if (!navigator.requestMIDIAccess) {
    console.warn('‚ö†Ô∏è Web MIDI API not supported');
    return;
  }
 
  try {
    if (!midiAccess) {
     window.midiAccess = await navigator.requestMIDIAccess();
    }
   
    const outputs = midiAccess.outputs.values();
    for (let output of outputs) {
      console.log(`üì§ MIDI Output: ${output.name}`);
      midiOutput = output; // Use first available output
      break;
    }
   
    if (midiOutput) {
      midiOutputInitialized = true;
      showMessage('üì§ MIDI OUT READY');
    } else {
      showMessage('‚ö†Ô∏è NO MIDI OUT FOUND');
    }
  } catch (err) {
    console.error('‚ùå MIDI output init failed:', err);
  }
}

function sendMIDINote(channel, note, velocity, duration = 100) {
  if (!state.midiOutEnabled || !midiOutput) return;
 
  const noteOn = [0x90 | channel, note, velocity];
  const noteOff = [0x80 | channel, note, 0];
 
  try {
    midiOutput.send(noteOn);
    setTimeout(() => midiOutput.send(noteOff), duration);
  } catch (err) {
    console.error('MIDI send error:', err);
  }
}

// BUILD MIX PAGE
// BUILD MIX PAGE
// BUILD MIX PAGE
// BUILD MIX PAGE - COMPLETELY REDESIGNED WITH SIMPLE BUTTONS
// BUILD MIX PAGE - CLEAN NON-OVERLAPPING LAYOUT
function buildMixPage() {
  console.log('üéöÔ∏è Building Mix Page (Visual Faders)...');
  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;
 if (typeof state.mixerSelectedTrack === 'undefined') {
    state.mixerSelectedTrack = 0; // Default to KICK
  }
 let mixUI = document.getElementById('mixUI');
  if (mixUI && mixUI.parentNode) mixUI.parentNode.removeChild(mixUI);

  mixUI = document.createElement('a-entity');
  mixUI.setAttribute('id', 'mixUI');
  mixUI.setAttribute('position', '0 0 0');
  workstation.appendChild(mixUI);

  const mixerTracks = [
    { name: "KICK", idx: 0, color: '#DD3333' },
    { name: "SNARE", idx: 1, color: '#DD8833' },
    { name: "HIHAT", idx: 2, color: '#33AADD' },
    { name: "OPEN", idx: 3, color: '#AA55DD' },
    { name: "BASS", idx: 4, color: '#CC3333' },
    { name: "LEAD", idx: 5, color: '#CC8822' },
    { name: "PAD", idx: 6, color: '#33CC55' },
    { name: "ARP", idx: 7, color: '#3399DD' },
    { name: "MASTER", idx: 8, color: '#9b5cff' }
  ];

  const channelStartX = -1.00;
  const channelSpacing = 0.220;
 
  for (let i = 0; i < 9; i++) {
    const track = mixerTracks[i];
    const xPos = channelStartX + (i * channelSpacing);
    const channelZ = 0.05;  // Pushed back into synth body

    // TRACK NAME (Top)
    createButton(mixUI, xPos, -0.18, channelZ, 0.20, 0.08, 0.06, track.color, `mix-track-${i}`, track.name, 'white', true);

    // PAN SECTION
    createButton(mixUI, xPos - 0.055, -0.28, channelZ, 0.045, 0.06, 0.06, '#5588AA', `mix-pan-l-${i}`, 'L', 'white', true);
   
    // PAN VISUAL INDICATOR (Line that moves left/right) - WIDER
    const panTrackEl = document.createElement('a-box');
    panTrackEl.setAttribute('position', `${xPos} -0.28 0.09`);
    panTrackEl.setAttribute('width', '0.12');
    panTrackEl.setAttribute('height', '0.02');
    panTrackEl.setAttribute('depth', '0.01');
    panTrackEl.setAttribute('color', '#334455');
    panTrackEl.setAttribute('material', 'metalness:0.5;roughness:0.5');
    mixUI.appendChild(panTrackEl);
   
    const panKnobEl = document.createElement('a-box');
    panKnobEl.setAttribute('id', `mix-pan-knob-${i}`);
    panKnobEl.setAttribute('position', `${xPos} -0.28 0.11`);
    panKnobEl.setAttribute('width', '0.020');
    panKnobEl.setAttribute('height', '0.05');
    panKnobEl.setAttribute('depth', '0.02');
    panKnobEl.setAttribute('color', '#00FFFF');
    panKnobEl.setAttribute('material', 'metalness:0.8;roughness:0.2;emissive:#00FFFF;emissiveIntensity:0.5');
    mixUI.appendChild(panKnobEl);
   
    createButton(mixUI, xPos + 0.055, -0.28, channelZ, 0.045, 0.06, 0.06, '#5588AA', `mix-pan-r-${i}`, 'R', 'white', true);

    // VOLUME SECTION
    createButton(mixUI, xPos, -0.36, channelZ, 0.10, 0.06, 0.06, '#55AA55', `mix-vol-up-${i}`, '+', 'white', true);
   
    // FADER TRACK (vertical bar) - Just visual, no duplicate code here
    createButton(mixUI, xPos, -0.50, channelZ, 0.10, 0.06, 0.06, '#AA5555', `mix-vol-dn-${i}`, '-', 'white', true);
  }
 
  // Hide drum selection buttons
  const drumContainer = document.getElementById('drumButtons');
  if (drumContainer) {
    drumContainer.object3D.visible = false;
    drumContainer.setAttribute('visible', 'false');
  }
  if (ui.drumButtons) {
    ui.drumButtons.forEach(btn => {
      if (btn && btn.object3D) {
        btn.object3D.visible = false;
        btn.setAttribute('visible', 'false');
      }
    });
  }

  // STEP BUTTONS
  ui.mixStepButtons = [];
  for (let i = 0; i < 16; i++) {
    const x = (i * 0.13) - 1.1;
    const btn = createButton(mixUI, x, -0.65, 0.05, 0.12, 0.12, 0.08, '#334455', `mix-step-${i}`, `${i + 1}`, 'white', true);
    ui.mixStepButtons.push(btn);
  }

  // LEFT SIDE CONTROLS
  createButton(mixUI, -1.75, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'mix-bpm-', 'BPM-', 'white', true);
  createButton(mixUI, -1.51, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'mix-bpm+', 'BPM+', 'white', true);
  createButton(mixUI, -1.75, -0.42, 0.04, 0.22, 0.13, 0.08, '#33AA55', 'mix-play', 'PLAY', 'white', true);
  createButton(mixUI, -1.51, -0.42, 0.04, 0.22, 0.13, 0.08, '#DD3333', 'mix-stop', 'STOP', 'white', true);
  createButton(mixUI, -1.75, -0.59, 0.04, 0.22, 0.13, 0.08, '#CC3333', 'mix-rec', 'REC', 'white', true);
  createButton(mixUI, -1.51, -0.59, 0.04, 0.22, 0.13, 0.08, '#AA55DD', 'mix-playblk', 'PLYBLK', 'white', true);

  // RIGHT SIDE CONTROLS
  ui.mixViewButtons = [];
  ui.mixViewButtons.push(createButton(mixUI, 1.20, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'mix-v1', '1-16', 'white', true));
  ui.mixViewButtons.push(createButton(mixUI, 1.42, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'mix-v2', '17-32', 'white', true));
  ui.mixViewButtons.push(createButton(mixUI, 1.20, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'mix-v3', '33-48', 'white', true));
  ui.mixViewButtons.push(createButton(mixUI, 1.42, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'mix-v4', '49-64', 'white', true));
  createButton(mixUI, 1.20, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'mix-pat-', 'PAT-', 'white', true);
  createButton(mixUI, 1.42, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'mix-pat+', 'PAT+', 'white', true);
  createButton(mixUI, 1.20, -0.60, 0.05, 0.20, 0.12, 0.08, '#0000AA', 'mix-write', 'WRITE', 'white', true);
  createButton(mixUI, 1.42, -0.60, 0.05, 0.20, 0.12, 0.08, '#AA3333', 'mix-clear', 'CLEAR', 'white', true);

  console.log('‚úÖ Visual faders mixer built');
if (state.currentPage !== 'mix') return;
  updateMixerDisplays();
  updateMixSteps();
   updateMixerPianoKeys();
}

function updateMixSteps() {
  if (!ui.mixStepButtons) return;

  const offset = state.currentStepView * 16;
  const pat = patterns[state.currentPattern];

  // 1. Update the Step Buttons (Bottom Row)
  ui.mixStepButtons.forEach((btn, i) => {
    const step = offset + i;
    const hasMixData = pat.mix && pat.mix[step];
    const label = btn.querySelector('a-text');

    if (label) {
      label.setAttribute('value', `${i + 1}`);
      label.setAttribute('color', 'white');
    }

    if (state.isPlaying && step === state.currentStep) {
      btn.setAttribute('color', '#00FF00');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:2.0');
    } else if (step === state.highlightedStep) {
      btn.setAttribute('color', '#9b5cff');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#9b5cff;emissiveIntensity:1.5');
      btn.setAttribute('scale', '1.1 1.1 1.1');
    } else if (hasMixData) {
      btn.setAttribute('color', '#0055AA');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#0055AA;emissiveIntensity:1.0');
    } else {
      btn.setAttribute('color', '#334455');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      btn.setAttribute('scale', '1 1 1');
    }
  });

  // 2. Update the View Buttons (1-16, 17-32, etc.)
  if (ui.mixViewButtons) {
    ui.mixViewButtons.forEach((btn, i) => {
      if (i === state.currentStepView) {
        btn.setAttribute('color', '#9b5cff');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#9b5cff;emissiveIntensity:1.2');
      } else {
        btn.setAttribute('color', '#336688');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      }
    });
  }

  // **3. CRITICAL: Update Piano Keys**
  console.log('üéπ updateMixSteps calling updateMixerPianoKeys...');
  updateMixerPianoKeys();
}

function updateMixerPianoKeys() {
  // Only run if we are actually on the mixer page
  if (state.currentPage !== 'mix') return;
 
  // Safety check
  if (!ui.pianoKeys || ui.pianoKeys.length === 0) return;

  const pat = patterns[state.currentPattern];
  // Use currentStep for playback visualization, highlightedStep for editing
  const step = state.isPlaying ? state.currentStep : state.highlightedStep;

  // 1. Get the target color
  const mixerColors = ['#DD3333', '#DD8833', '#33AADD', '#AA55DD', '#CC3333', '#CC8822', '#33CC55', '#3399DD', '#9b5cff'];
  const currentColor = mixerColors[state.mixerSelectedTrack] || '#FFFFFF';

  // 2. NUCLEAR RESET: Turn OFF every single key first
  ui.pianoKeys.forEach(btn => {
    // Clear any pending timeouts on the element object itself
    if (btn.flashTimeout) {
      clearTimeout(btn.flashTimeout);
      btn.flashTimeout = null;
    }

    const isWhite = btn.dataset.isWhite === 'true';
    const originalColor = isWhite ? '#F8F8F8' : '#050508';
   
    // Force attributes back to idle state
    btn.setAttribute('color', originalColor);
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1'); // Reset scale in case it was stuck "pressed"

    // Reset underglow LED if it exists
    const note = btn.dataset.note;
    if (note) {
      const glowEl = document.getElementById(`glow-${note}`);
      if (glowEl) {
        glowEl.setAttribute('material', 'opacity: 0');
      }
    }
  });

  // 3. Determine which note should be lit (if any)
  let activeNote = null;

  if (state.mixerSelectedTrack < 4) {
    // DRUMS
    const drumNames = ['kick', 'snare', 'hihat', 'open'];
    const drumName = drumNames[state.mixerSelectedTrack];
    const drumNoteMap = { 'kick': 'C3', 'snare': 'D3', 'hihat': 'E3', 'open': 'F3' };
   
    if (pat.drums[drumName][step]) {
      activeNote = drumNoteMap[drumName];
    }
  } else if (state.mixerSelectedTrack < 8) {
    // MELODIC
    const trackKeys = ['bass', 'lead', 'pad', 'arp'];
    const trackKey = trackKeys[state.mixerSelectedTrack - 4];
    activeNote = pat[trackKey][step];
  }

  // 4. Light up ONLY the active note
  if (activeNote && activeNote !== '' && activeNote !== 'TIE' && activeNote !== 'REST' && activeNote !== '-' && activeNote !== '^') {
    const keyBtn = ui.pianoKeys.find(btn => btn.dataset.note === activeNote);
   
    if (keyBtn) {
      keyBtn.setAttribute('color', currentColor);
      keyBtn.setAttribute('material', `metalness:.1;roughness:.3;emissive:${currentColor};emissiveIntensity:2.0`);
     
      // Light up LED
      const glowEl = document.getElementById(`glow-${activeNote}`);
      if (glowEl) {
        glowEl.setAttribute('color', currentColor);
        glowEl.setAttribute('material', `shader:flat; transparent:true; opacity:0.4; color:${currentColor}`);
      }
    }
  }
}

function updateMixerDisplays() {
  for (let i = 0; i < 9; i++) {
    let volume, pan;
   
    if (i < 4) {
      // Drums - ensure values exist and are in bounds
      if (typeof state.drumVolumes[i] === 'undefined') state.drumVolumes[i] = 0.8;
      if (typeof state.drumPans[i] === 'undefined') state.drumPans[i] = 0;
     
      volume = Math.max(0, Math.min(1, state.drumVolumes[i]));
      pan = Math.max(-7, Math.min(7, state.drumPans[i]));
     
      // Update state with clamped values
      state.drumVolumes[i] = volume;
      state.drumPans[i] = pan;
    } else if (i < 8) {
      // Tracks - ensure values exist and are in bounds
      const trackIdx = i - 3;
      if (typeof state.trackVolumes[trackIdx] === 'undefined') state.trackVolumes[trackIdx] = 0.8;
      if (typeof state.trackPans[trackIdx] === 'undefined') state.trackPans[trackIdx] = 0;
     
      volume = Math.max(0, Math.min(1, state.trackVolumes[trackIdx]));
      pan = Math.max(-7, Math.min(7, state.trackPans[trackIdx]));
     
      // Update state with clamped values
      state.trackVolumes[trackIdx] = volume;
      state.trackPans[trackIdx] = pan;
    } else {
      // Master
      if (typeof state.masterVolume === 'undefined') state.masterVolume = 0.8;
      volume = Math.max(0, Math.min(1, state.masterVolume));
      state.masterVolume = volume;
      pan = 0;
    }
   
    // Update fader position (volume) - MUCH LARGER RANGE
    const fader = document.getElementById(`mix-fader-${i}`);
    if (fader) {
      const channelStartX = -1.00 + (i * 0.220);
      // EXPANDED: Map volume 0-1 to Y position -0.52 to -0.34 (0.18 range)
      const yPos = -0.52 + (volume * 0.18);
      fader.setAttribute('position', `${channelStartX} ${yPos} 0.11`);
     
      // Also make the fader cap bigger and brighter
      fader.setAttribute('width', '0.06');
      fader.setAttribute('height', '0.02');
     
      // Add glow based on volume
      const track = fader.getAttribute('color');
      const intensity = 0.3 + (volume * 1.5);
      fader.setAttribute('material', `metalness:0.8;roughness:0.2;emissive:${track};emissiveIntensity:${intensity}`);
    }
   
    // Update pan knob position (pan) - MUCH LARGER RANGE
    const panKnob = document.getElementById(`mix-pan-knob-${i}`);
    if (panKnob) {
      const channelStartX = -1.00 + (i * 0.220);
      // EXPANDED: Map pan -7 to +7 to X offset -0.06 to +0.06
      const xOffset = (pan / 7) * 0.06;
      panKnob.setAttribute('position', `${channelStartX + xOffset} -0.28 0.11`);
     
      // Make pan knob bigger and brighter
      panKnob.setAttribute('width', '0.020');
      panKnob.setAttribute('height', '0.05');
     
      // Add color coding: cyan = center, magenta = left, yellow = right
      let panColor = '#00FFFF'; // Center
      let panIntensity = 0.5;
     
      if (pan < 0) {
        panColor = '#FF00FF'; // Magenta for left
        panIntensity = 0.5 + (Math.abs(pan) / 7) * 1.0;
      } else if (pan > 0) {
        panColor = '#FFFF00'; // Yellow for right
        panIntensity = 0.5 + (Math.abs(pan) / 7) * 1.0;
      }
     
      panKnob.setAttribute('color', panColor);
      panKnob.setAttribute('material', `metalness:0.8;roughness:0.2;emissive:${panColor};emissiveIntensity:${panIntensity}`);
    }
  }
}

// ============================================================================
// SECTION 6: FILE OPERATIONS & DEMO LOADER
// ============================================================================

function saveToFile() {
  console.log('üíæ Starting save operation...');
 
  try {
    // CRITICAL: Ensure each pattern has its length saved
    const patternsToSave = patterns.map(p => ({
      length: p.length || 64,  // Save the pattern length
      drums: p.drums,
      drumVelocity: p.drumVelocity,
      bass: p.bass,
      lead: p.lead,
      pad: p.pad,
      arp: p.arp,
      arpChords: p.arpChords,
      mix: p.mix,
      velocity: p.velocity
    }));
   
    const data = {
      version: '5.4',
      tempo: state.tempo,
      patterns: patternsToSave,
      arrangement: state.songArrangement,
      soundIndex: state.soundIndex,
      skin: state.skin,
      trackVolumes: state.trackVolumes,
      trackPans: state.trackPans,
      drumVolumes: state.drumVolumes,
      drumPans: state.drumPans,
      masterVolume: state.masterVolume,
      trackDecay: state.trackDecay,
      arp: state.arp  // Save arp settings
    };
   
    console.log('üì¶ Data prepared, serializing...');
    const json = JSON.stringify(data, null, 2);
    console.log('‚úÖ JSON created, size:', json.length, 'bytes');
   
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
   
    const a = document.createElement('a');
    a.href = url;
    a.download = `mobile5000_${Date.now()}.json`;
    a.style.display = 'none';
   
    // **CRITICAL: Must append to document for some browsers**
    document.body.appendChild(a);
   
    console.log('üñ±Ô∏è Triggering download...');
    a.click();
   
    // Clean up
   
   
    showMessage('üíæ SAVED TO FILE');
    console.log('‚úÖ Save operation complete');
   
  } catch (err) {
    console.error('‚ùå Save failed:', err);
    showMessage('‚ùå SAVE FAILED - CHECK CONSOLE');
  }
}

function setRandomSkyboxOnLoad() {
  const randomIndex = Math.floor(Math.random() * skyboxUrls.length);
  state.skin.skyboxUrl = skyboxUrls[randomIndex];
  console.log(`‚úÖ Random skybox selected: ${randomIndex + 1}/${skyboxUrls.length}`);
}

// LOAD DEMO - COMPLETE IMPLEMENTATION
async function loadDemoFromJSON() {
  console.log('üé¨ Loading demo from JSON...');
 
  try {
    // Fetch from CodePen
    const response = await fetch('https://assets.codepen.io/7273141/demo2.json');
   
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    }
   
    const demoData = await response.json();
   
    console.log('‚úÖ Demo JSON loaded from file');
   
    // Stop playback
    state.isPlaying = false;
    stopAllSources();
   
    // **NEW: Detect if this is old or new format**

    const firstPattern = demoData.patterns[Object.keys(demoData.patterns)[0]];
    const isOldFormat = firstPattern && firstPattern.track1 !== undefined;
   
    console.log('üìã Format detected:', isOldFormat ? 'OLD' : 'NEW');
   
    let converted;
   
    if (isOldFormat) {
      // Convert old format to new format
      converted = convertOldDemoFormat(demoData);
   } else {
  // Already in new format
  const newPatterns = [];
 
  // Handle both array and object formats
  const patternsArray = Array.isArray(demoData.patterns)
    ? demoData.patterns
    : Object.keys(demoData.patterns).map(k => demoData.patterns[k]);
 
  patternsArray.forEach((pat, patternIndex) => {
    if (!pat) return;
   
    // Ensure pattern has all required properties
    newPatterns[patternIndex] = {
      length: pat.length || 64,
      drums: pat.drums || {
        kick: new Array(64).fill(false),
        snare: new Array(64).fill(false),
        hihat: new Array(64).fill(false),
        open: new Array(64).fill(false)
      },
      drumVelocity: pat.drumVelocity || {
        kick: new Array(64).fill(1.0),
        snare: new Array(64).fill(1.0),
        hihat: new Array(64).fill(1.0),
        open: new Array(64).fill(1.0)
      },
      bass: pat.bass || new Array(64).fill(''),
      lead: pat.lead || new Array(64).fill(''),
      pad: pat.pad || new Array(64).fill(''),
      arp: pat.arp || new Array(64).fill(''),
      arpChords: pat.arpChords || new Array(64).fill(null),
      mix: pat.mix || new Array(64).fill(null),
      velocity: pat.velocity || {
        bass: new Array(64).fill(0.8),
        lead: new Array(64).fill(0.8),
        pad: new Array(64).fill(0.8),
        arp: new Array(64).fill(0.8)
      }
    };
  });
 
  converted = {
    patterns: newPatterns,
    state: {
      tempo: demoData.tempo || 85,
      songArrangement: demoData.songArrangement || demoData.arrangement || [],
      trackVolumes: demoData.trackVolumes || [0.8, 1.0, 0.9, 0.9, 0.3],
      drumVolumes: demoData.drumVolumes || [0.81, 0.81, 0.05, 0.225],
      trackPans: demoData.trackPans || [0, 0, 0, 0, 0],
      drumPans: demoData.drumPans || [0, 0, 0, 0],
      trackDecay: demoData.trackDecay || [1.0, 1.0, 1.0, 1.0, 1.0],
      arp: demoData.arp || {
        pattern: 0,
        enabled: false,
        currentArpIndex: 0,
        mode: 0,
        randomInversions: false,
        strumPattern: 0,
        timeSubdivision: 2
      }
    }
  };
}
   
    // Load patterns
    converted.patterns.forEach((pat, i) => {
      if (pat) patterns[i] = JSON.parse(JSON.stringify(pat));
    });
   
    // Load state
    if (converted.state.tempo) state.tempo = converted.state.tempo;
    if (converted.state.trackVolumes) state.trackVolumes = [...converted.state.trackVolumes];
    if (converted.state.drumVolumes) state.drumVolumes = [...converted.state.drumVolumes];
    if (converted.state.trackPans) state.trackPans = [...converted.state.trackPans];
    if (converted.state.drumPans) state.drumPans = [...converted.state.drumPans];
    if (converted.state.songArrangement) state.songArrangement = [...converted.state.songArrangement];
    if (converted.state.arp) state.arp = {...converted.state.arp};
    if (converted.state.trackDecay) state.trackDecay = [...converted.state.trackDecay];
   
    // Start at pattern 1 (index 0)
    // Load the first pattern from the song arrangement
const firstPatternNum = converted.state.songArrangement[0] || 1;
state.currentPattern = firstPatternNum - 1;  // Convert 1-indexed to 0-indexed
state.currentTrack = 1;
state.currentStep = 0;
state.currentStepView = 0;
state.highlightedStep = 0;

console.log(`üé¨ Starting demo at pattern ${firstPatternNum} (array index ${state.currentPattern})`);
   
    console.log('üì¶ Loading instrument samples...');
    await Promise.all([
      loadInstrumentBank('bass', 0),
      loadInstrumentBank('lead', 0),
      loadInstrumentBank('pad', 0),
      loadInstrumentBank('arp', 0)
    ]);
   
    showPage('seq');
    updateUI();
    updateSteps();
   
    // Start playback
    setTimeout(() => {
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
     
      state.arrangementMode = true;
      state.currentArrangementIndex = 0;
      state.isPlaying = true;
      state.currentStep = 0;
     
      if (audioContext) {
        nextNoteTime = audioContext.currentTime;
      }
     
      showMessage('‚ñ∂ PLAYING DEMO 2');
      updateUI();
      updateSteps();
     
      console.log('‚úÖ Demo playback initiated');
    }, 500);
   
  } catch (err) {
    console.error('‚ùå Demo load failed:', err);
    showMessage('‚ùå DEMO LOAD FAILED - ' + err.message);
  }
}
// ============================================================================
// SECTION 7: COMPLETE BUTTON HANDLER
// ============================================================================

async function handleButtonClick(id, btn) {

  console.log('üñ±Ô∏è Button clicked, ID:', id);
  console.log('   Current page:', state.currentPage);

 // FM PRESET NAVIGATION - Track-specific buttons
if (id.startsWith('fm-prev-') || id.startsWith('fm-next-')) {
  console.log('üéõÔ∏è FM PRESET BUTTON - Full ID:', id);  // ADD THIS
  flashButton(btn);
 
  const direction = id.startsWith('fm-next-') ? 1 : -1;
  const trackName = id.split('-')[2];
    console.log('   Extracted track name:', trackName);  // ADD THIS
  if (window.changeFMPreset) {
    const trackNames = ['kick', 'snare', 'hihat', 'open', 'bass', 'lead', 'pad', 'arp'];
    const trackIndex = trackNames.indexOf(trackName);
   
    if (trackIndex !== -1) {
      window.FM.currentTrack = trackIndex;
      window.changeFMPreset(direction);
    }
  }
    console.error('‚ùå Track name not found in trackNames array!');  // ADD THIS
  return;
}

// FM DECAY ADJUSTMENT - ADD THIS NEW SECTION

// FM PRESET NAVIGATION - Track-specific buttons
if (id.startsWith('fm-prev-') || id.startsWith('fm-next-')) {
  flashButton(btn);
 
  const direction = id.startsWith('fm-next-') ? 1 : -1;
  const trackName = id.split('-')[2]; // Extract 'kick', 'snare', 'lead', etc.
 
  console.log('üéõÔ∏è FM preset button clicked:', id);
  console.log('   Direction:', direction);
  console.log('   Track:', trackName);
 
  if (window.changeFMPreset) {
    // First, set the current track in FM state
    const trackNames = ['kick', 'snare', 'hihat', 'open', 'bass', 'lead', 'pad', 'arp'];
    const trackIndex = trackNames.indexOf(trackName);
   
    if (trackIndex !== -1) {
      window.FM.currentTrack = trackIndex;
      window.changeFMPreset(direction);
    }
  }
  return;
}

  if (!audioInitialized) {
    console.log('üéµ Initializing audio on first click...');
    try {
      await initAudio();
      console.log('‚úÖ Audio ready!');
    } catch (err) {
      console.error('‚ùå Audio init failed:', err);
    }
  }

if (id === 'misc-fm-toggle') {
  console.log('üîò FM button clicked');
  console.log('Type of toggleFMMode:', typeof window.toggleFMMode);
  console.log('window.FM:', window.FM);
 
  // Call FM.toggle directly if it exists
  if (window.FM && typeof window.FM.toggle === 'function') {
    window.FM.toggle();
  } else {
    // Manual toggle
    if (window.FM) {
      window.FM.enabled = !window.FM.enabled;
      console.log('FM enabled:', window.FM.enabled);
     
      if (window.FM.enabled) {
        // Turn FM ON
        if (!window.FM.presets || !window.FM.presets.kick) {
          console.log('Loading presets...');
          if (typeof loadFMPresets === 'function') loadFMPresets();
          if (typeof window.loadFMPresets === 'function') window.loadFMPresets();
        }
        if (typeof buildFMUI === 'function') buildFMUI();
        if (typeof window.buildFMUI === 'function') window.buildFMUI();
      } else {
        // Turn FM OFF
        if (typeof restoreMiscUI === 'function') restoreMiscUI();
        if (typeof window.restoreMiscUI === 'function') window.restoreMiscUI();
      }
    }
  }
  return;
}
 

// FM DECAY ADJUSTMENT - ADD THIS RIGHT AFTER THE PRESET BUTTON HANDLER
if (id.startsWith('fm-decay-') || id.startsWith('fm-decay+')) {
  flashButton(btn);
 
  const direction = id.startsWith('fm-decay+') ? 1 : -1;
  const trackName = id.includes('decay+') ? id.split('+')[1] : id.split('-')[2];
 
  console.log('üéõÔ∏è FM decay button clicked:', id);
  console.log('   Direction:', direction);
  console.log('   Track:', trackName);
 
  if (window.adjustFMDecay) {
    const trackNames = ['kick', 'snare', 'hihat', 'open', 'bass', 'lead', 'pad', 'arp'];
    const trackIndex = trackNames.indexOf(trackName);
   
    if (trackIndex !== -1) {
      window.FM.currentTrack = trackIndex;
      window.adjustFMDecay(direction);
    }
  }
  return;
}

// MISC PAGE BANK SELECTION
if (id === 'misc-bank-prev') {
  flashButton(btn);
  state.currentBankNumber = Math.max(1, state.currentBankNumber - 1);
  console.log('üîò BANK- clicked, calling switchBank(' + state.currentBankNumber + ')');
  await switchBank(state.currentBankNumber);  // ‚Üê ADD AWAIT HERE!
  updateMiscButtons();
  showMessage(`üéµ BANK ${state.currentBankNumber}`);
  return;
}

if (id === 'misc-bank-next') {
  flashButton(btn);
  state.currentBankNumber = Math.min(8, state.currentBankNumber + 1);
  console.log('üîò BANK+ clicked, calling switchBank(' + state.currentBankNumber + ')');
  await switchBank(state.currentBankNumber);  // ‚Üê ADD AWAIT HERE!
  updateMiscButtons();
  showMessage(`üéµ BANK ${state.currentBankNumber}`);
  return;
}


  // POWER BUTTON - ADD HERE
  if (id === 'powerButtonCap' || btn.id === 'powerButtonCap') {
    if (!state.powered) {
      state.powered = true;
      const powerCap = document.getElementById('powerButtonCap');
      if (powerCap) {
        powerCap.classList.remove('power-pulse');
        powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#00FF00;emissiveIntensity:2.0');
        powerCap.setAttribute('color', '#00FF00');
      }
      runStartupSequence();
    } else {
      state.powered = false;
      powerDown();
    }
    return;
  }

  // Rest of handlers continue here...
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // MIXER CONTROLS - NEW SIMPLE BUTTON SYSTEM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 // MISC PAGE HANDLERS
// MISC PAGE HANDLERS - FIXED
if (id === 'misc-midi-out') {
  // Toggle state
  state.midiOutEnabled = !state.midiOutEnabled;
 
  // Initialize MIDI if turning on for first time
  if (state.midiOutEnabled && !midiOutputInitialized) {
    initMIDIOutput();
  }
 
  // Update button appearance immediately
  const label = btn.querySelector('a-text');
 
  if (state.midiOutEnabled) {
    // ON state - green with glow
    btn.setAttribute('color', '#00FF00');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.5');
    btn.setAttribute('scale', '1.1 1.1 1.1');
    if (label) label.setAttribute('color', '#000000'); // Black text on green
  } else {
    // OFF state - normal
    btn.setAttribute('color', '#AA55DD');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
    if (label) label.setAttribute('color', 'white'); // White text
  }
 
  showMessage(state.midiOutEnabled ? 'üì§ MIDI OUT ON' : 'üì§ MIDI OUT OFF');
  return;
}

if (id === 'misc-skybox-toggle') {
  flashButton(btn);
  state.skyboxEnabled = !state.skyboxEnabled;
 
  console.log('üîò Skybox toggle clicked, now:', state.skyboxEnabled);
 
  applySkybox();
  updateMiscButtons();
 
  return;
}

if (id === 'misc-skybox-prev') {
  flashButton(btn);
  state.currentSkyboxIndex = (state.currentSkyboxIndex - 1 + skyboxUrls.length) % skyboxUrls.length;
  if (state.skyboxEnabled) applySkybox();  // ‚Üê Make sure this line is here
  updateMiscButtons();
  showMessage(`SKYBOX ${state.currentSkyboxIndex + 1}/${skyboxUrls.length}`);
  return;
}

if (id === 'misc-skybox-next') {
  flashButton(btn);
  state.currentSkyboxIndex = (state.currentSkyboxIndex + 1) % skyboxUrls.length;
  if (state.skyboxEnabled) applySkybox();  // ‚Üê Make sure this line is here
  updateMiscButtons();
  showMessage(`SKYBOX ${state.currentSkyboxIndex + 1}/${skyboxUrls.length}`);
  return;
}

if (id === 'misc-lighting-toggle') {
  flashButton(btn);
  state.lightingEnabled = !state.lightingEnabled;
 
  if (!state.lightingEnabled) {
    resetLighting();
  }
 
  updateMiscButtons();
  showMessage(state.lightingEnabled ? 'üí° LIGHTING ON' : 'üí° LIGHTING OFF');
  return;
}

if (id === 'misc-lighting-rand') {
  flashButton(btn);
  if (state.lightingEnabled) {
    randomizeLighting();
  }
  return;
}
  // MIXER TRACK SELECTION
 // MIXER TRACK SELECTION
// AROUND LINE 2866 - Update the mixer track selection
// MIXER TRACK SELECTION
if (id.startsWith('mix-track-')) {
  try {
    const trackIdx = parseInt(id.split('-')[2]);
    const now = Date.now();
   
    // Double-click detection
    if (!window.lastMixTrackClick) window.lastMixTrackClick = {};
    const lastClick = window.lastMixTrackClick[trackIdx] || 0;
    const isDoubleClick = (now - lastClick) < 500;
    window.lastMixTrackClick[trackIdx] = now;
   
    // Around line 2866 in handleButtonClick - MIXER TRACK SELECTION
if (trackIdx < 4) {
  // Drums
  state.mixerSelectedTrack = trackIdx;
  state.currentTrack = 0;
  const drumNames = ['kick', 'snare', 'hihat', 'open'];
  state.selectedDrum = drumNames[trackIdx];
  if (!state.isPlaying) {
    playDrum(drumNames[trackIdx]);
  }
  showMessage(`DRUM: ${drumNames[trackIdx].toUpperCase()}`);
} else if (trackIdx < 8) {
  // Instruments
  const instIdx = trackIdx - 4;
  const types = ['bass', 'lead', 'pad', 'arp'];
  const type = types[instIdx];
 
  // **UPDATED: Double-click cycles through BANKS**
  if (isDoubleClick) {
    const totalBanks = SOUNDSETS.length;
    state.currentBankNumber = (state.currentBankNumber % totalBanks) + 1;
   
    // Switch to new bank (await only works if handleButtonClick is async)
    switchBank(state.currentBankNumber).then(() => {
      const newBankName = SOUNDSETS[state.currentBankNumber - 1].name;
      showMessage(`${type.toUpperCase()}: ${newBankName}`);
    }).catch(err => {
      console.error('Bank switch failed:', err);
      showMessage('‚ùå BANK SWITCH FAILED');
    });
  } else {
    // Single click - just select and preview
    state.mixerSelectedTrack = trackIdx;
    state.currentTrack = instIdx + 1;
    showMessage(`${type.toUpperCase()} SELECTED`);
  }
 
  // Preview sound
  setTimeout(() => {
    const currentSoundIdx = state.soundIndex[type];
    if (!buffers[type] || !buffers[type][currentSoundIdx]) {
      console.log(`‚ö° Loading sound: ${type} #${currentSoundIdx}`);
      loadInstrumentBank(type, currentSoundIdx).catch(err =>
        console.error('Failed to load sound:', err)
      );
    } else if (!state.isPlaying) {
      const previewNote = type === 'bass' ? 'C2' : 'C4';
      playInstrument(instIdx, previewNote);
    }
  }, 100);
} else {
  state.mixerSelectedTrack = trackIdx;
  showMessage('MASTER CHANNEL');
}

// Update button highlights - FIX TEXT COLOR HERE
for (let i = 0; i < 9; i++) {
  const trackBtn = document.getElementById(`mix-track-${i}`);
  if (trackBtn) {
    const label = trackBtn.querySelector('a-text');
   
    if (i === state.mixerSelectedTrack) {
      // SELECTED - white background, BLACK text
      trackBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:1.5');
      trackBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) {
        label.setAttribute('color', '#000000');
      }
    } else {
      // NOT SELECTED - colored background, white text
      trackBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      trackBtn.setAttribute('scale', '1 1 1');
      if (label) {
        label.setAttribute('color', 'white');
      }
    }
  }
}

updateSynthBodyColor();
updateSteps();
updateUI();
   
  } catch (err) {
    console.error('Error in mixer track click:', err);
    showMessage('‚ùå ERROR - CHECK CONSOLE');
  }
  return;
}
 
  // MIXER PAN LEFT/RIGHT
  if (id.startsWith('mix-pan-l-') || id.startsWith('mix-pan-r-')) {
    const trackIdx = parseInt(id.match(/\d+/)[0]);
    const isRight = id.includes('-r-');
   
    flashButton(btn);
   
    if (trackIdx < 4) {
      const currentPan = state.drumPans[trackIdx] || 0;
      state.drumPans[trackIdx] = Math.max(-7, Math.min(7, currentPan + (isRight ? 1 : -1)));
    } else if (trackIdx < 8) {
      const currentPan = state.trackPans[trackIdx - 3] || 0;
      state.trackPans[trackIdx - 3] = Math.max(-7, Math.min(7, currentPan + (isRight ? 1 : -1)));
    }
   if (state.currentPage !== 'mix') return;
    updateMixerDisplays();
    const newPan = trackIdx < 4 ? state.drumPans[trackIdx] : state.trackPans[trackIdx - 3];
    if (newPan === 0) {
      showMessage('PAN: CENTER');
    } else if (newPan < 0) {
      showMessage(`PAN: L${Math.abs(newPan)}`);
    } else {
      showMessage(`PAN: R${newPan}`);
    }
    return;
  }
 
  // MIXER VOLUME UP/DOWN
  if (id.startsWith('mix-vol-up-') || id.startsWith('mix-vol-dn-')) {
    const trackIdx = parseInt(id.match(/\d+/)[0]);
    const isUp = id.includes('-up-');
   
    flashButton(btn);
   
    if (trackIdx < 4) {
      const current = state.drumVolumes[trackIdx] || 0.8;
      state.drumVolumes[trackIdx] = Math.max(0, Math.min(1, current + (isUp ? 0.05 : -0.05)));
    } else if (trackIdx < 8) {
      const current = state.trackVolumes[trackIdx - 3] || 0.8;
      state.trackVolumes[trackIdx - 3] = Math.max(0, Math.min(1, current + (isUp ? 0.05 : -0.05)));
    } else {
      const current = state.masterVolume || 0.8;
      state.masterVolume = Math.max(0, Math.min(1, current + (isUp ? 0.05 : -0.05)));
      if (masterGain) masterGain.gain.value = state.masterVolume;
    }
   if (state.currentPage !== 'mix') return;
    updateMixerDisplays();
   
    const newVol = trackIdx < 4
      ? state.drumVolumes[trackIdx]
      : (trackIdx < 8 ? state.trackVolumes[trackIdx - 3] : state.masterVolume);
    showMessage(`VOL: ${Math.round(newVol * 100)}%`);
    return;
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // (REST OF YOUR EXISTING HANDLERS CONTINUE HERE)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MIXER PAN/VOLUME BUTTONS
 // MIXER PAN/VOLUME BUTTONS
  // MIXER PAN/VOLUME BUTTONS
 // MIXER PAN BUTTONS (L/R)
  if (id.startsWith('mix-pan-l-') || id.startsWith('mix-pan-r-')) {
    const trackIdx = parseInt(id.match(/\d+/)[0]);
    const isRight = id.includes('-r-');
   
    let currentPan;
    if (trackIdx < 4) {
      currentPan = state.drumPans[trackIdx] || 0;
      state.drumPans[trackIdx] = Math.max(-7, Math.min(7, currentPan + (isRight ? 1 : -1)));
    } else if (trackIdx < 8) {
      currentPan = state.trackPans[trackIdx - 3] || 0;
      state.trackPans[trackIdx - 3] = Math.max(-7, Math.min(7, currentPan + (isRight ? 1 : -1)));
    }
   if (state.currentPage !== 'mix') return;
    updateMixerDisplays();
    flashButton(btn);
    return;
  }
 
  // MIXER VOLUME BUTTONS (-/+)
  if (id.startsWith('mix-vol-up-') || id.startsWith('mix-vol-dn-')) {
    const trackIdx = parseInt(id.match(/\d+/)[0]);
    const isUp = id.includes('-up-');
   
    if (trackIdx < 4) {
      const current = state.drumVolumes[trackIdx] || 0.8;
      state.drumVolumes[trackIdx] = Math.max(0, Math.min(1, current + (isUp ? 0.05 : -0.05)));
    } else if (trackIdx < 8) {
      const current = state.trackVolumes[trackIdx - 3] || 0.8;
      state.trackVolumes[trackIdx - 3] = Math.max(0, Math.min(1, current + (isUp ? 0.05 : -0.05)));
    } else {
      const current = state.masterVolume || 0.8;
      state.masterVolume = Math.max(0, Math.min(1, current + (isUp ? 0.05 : -0.05)));
      if (masterGain) masterGain.gain.value = state.masterVolume;
    }
   if (state.currentPage !== 'mix') return;
    updateMixerDisplays();
    flashButton(btn);
    return;
  }
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ARP CONTROLS - MUST BE EARLY TO AVOID STEP BUTTON CONFLICTS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EDIT PAGE - COPY/PASTE/CLEAR BUTTONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHORD COPY BLOCK


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BLOCK COPY/PASTE BUTTONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COPY BLOCK - All tracks in current view (16 steps)
if (id === 'edit-copy-block') {
  flashButton(btn);
 
  const blockStart = state.currentStepView * 16;
  const blockEnd = blockStart + 16;
 
  clipboard.block = {
    drums: {},
    drumVelocity: {},
    bass: [],
    lead: [],
    pad: [],
    arp: [],
    arpChords: [],
    velocity: {
      bass: [],
      lead: [],
      pad: [],
      arp: []
    }
  };
 
  const pat = patterns[state.currentPattern];
 
  // Copy drums
  ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
    clipboard.block.drums[drum] = [];
    clipboard.block.drumVelocity[drum] = [];
    for (let i = blockStart; i < blockEnd; i++) {
      clipboard.block.drums[drum].push(pat.drums[drum][i]);
      clipboard.block.drumVelocity[drum].push(pat.drumVelocity[drum][i]);
    }
  });
 
  // Copy melodic tracks
  ['bass', 'lead', 'pad', 'arp'].forEach(trackKey => {
    for (let i = blockStart; i < blockEnd; i++) {
      clipboard.block[trackKey].push(pat[trackKey][i]);
      clipboard.block.velocity[trackKey].push(pat.velocity[trackKey][i]);
      if (trackKey === 'arp') {
        clipboard.block.arpChords.push(pat.arpChords[i] ? JSON.parse(JSON.stringify(pat.arpChords[i])) : null);
      }
    }
  });
 
  showMessage(`üìã BLOCK ${state.currentStepView + 1} COPIED (ALL TRACKS)`);
  return;
}

// PASTE BLOCK - All tracks to current view
if (id === 'edit-paste-block') {
  if (!clipboard.block) {
    showMessage('‚ùå NO BLOCK IN CLIPBOARD');
    return;
  }
 
  flashButton(btn);
  saveUndoState();
 
  const blockStart = state.currentStepView * 16;
  const blockEnd = blockStart + 16;
  const pat = patterns[state.currentPattern];
 
  // Paste drums
  ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
    for (let i = 0; i < 16; i++) {
      pat.drums[drum][blockStart + i] = clipboard.block.drums[drum][i];
      pat.drumVelocity[drum][blockStart + i] = clipboard.block.drumVelocity[drum][i];
    }
  });
 
  // Paste melodic tracks
  ['bass', 'lead', 'pad', 'arp'].forEach(trackKey => {
    for (let i = 0; i < 16; i++) {
      pat[trackKey][blockStart + i] = clipboard.block[trackKey][i];
      pat.velocity[trackKey][blockStart + i] = clipboard.block.velocity[trackKey][i];
      if (trackKey === 'arp') {
        pat.arpChords[blockStart + i] = clipboard.block.arpChords[i] ? JSON.parse(JSON.stringify(clipboard.block.arpChords[i])) : null;
      }
    }
  });
 
  updateSteps();
  updateUI();
  showMessage(`üìã BLOCK PASTED ‚Üí VIEW ${state.currentStepView + 1} (ALL TRACKS)`);
  return;
}

if (id === 'chord-cpyb') {
  flashButton(btn);
  const pat = patterns[state.currentPattern];
  const blockStart = state.currentStepView * 16;
  const blockEnd = blockStart + 16;
 
  clipboard.chordBlock = [];
  for (let i = blockStart; i < blockEnd; i++) {
    clipboard.chordBlock.push(pat.arpChords[i] ? JSON.parse(JSON.stringify(pat.arpChords[i])) : null);
  }
 
  showMessage(`üìã BLOCK ${state.currentStepView + 1} COPIED`);
  return;
}

// CHORD PASTE BLOCK
if (id === 'chord-pstb') {
  if (!clipboard.chordBlock) {
    showMessage('‚ùå NO BLOCK IN CLIPBOARD');
    return;
  }
 
  flashButton(btn);
  saveUndoState();
 
  const pat = patterns[state.currentPattern];
  const blockStart = state.currentStepView * 16;
 
  for (let i = 0; i < 16; i++) {
    pat.arpChords[blockStart + i] = clipboard.chordBlock[i] ? JSON.parse(JSON.stringify(clipboard.chordBlock[i])) : null;
  }
 
  updateChordSteps();
  showMessage(`üìã BLOCK PASTED ‚Üí ${state.currentStepView + 1}`);
  return;
}

// CHORD COPY PATTERN
if (id === 'chord-cpyp') {
  flashButton(btn);
  const pat = patterns[state.currentPattern];
 
  clipboard.chordPattern = [];
  for (let i = 0; i < 64; i++) {
    clipboard.chordPattern.push(pat.arpChords[i] ? JSON.parse(JSON.stringify(pat.arpChords[i])) : null);
  }
 
  showMessage(`üìã PATTERN ${state.currentPattern + 1} CHORDS COPIED`);
  return;
}

// CHORD PASTE PATTERN
if (id === 'chord-pstp') {
  if (!clipboard.chordPattern) {
    showMessage('‚ùå NO PATTERN IN CLIPBOARD');
    return;
  }
 
  flashButton(btn);
  saveUndoState();
 
  const pat = patterns[state.currentPattern];
 
  for (let i = 0; i < 64; i++) {
    pat.arpChords[i] = clipboard.chordPattern[i] ? JSON.parse(JSON.stringify(clipboard.chordPattern[i])) : null;
  }
 
  updateChordSteps();
  showMessage(`üìã CHORDS PASTED ‚Üí PAT ${state.currentPattern + 1}`);
  return;
}
// COPY PATTERN
if (id === 'edit-copy-pat') {
  flashButton(btn);
  clipboard.pattern = JSON.parse(JSON.stringify(patterns[state.currentPattern]));
  showMessage(`üìã PATTERN ${state.currentPattern + 1} COPIED`);
  return;
}

// PASTE PATTERN
if (id === 'edit-paste-pat') {
  if (!clipboard.pattern) {
    showMessage('‚ùå NO PATTERN IN CLIPBOARD');
    return;
  }
  flashButton(btn);
  saveUndoState();
  patterns[state.currentPattern] = JSON.parse(JSON.stringify(clipboard.pattern));
  updateSteps();
  updateUI();
  showMessage(`üìã PATTERN PASTED ‚Üí ${state.currentPattern + 1}`);
  return;
}

// COPY TRACK
if (id === 'edit-copy-trk') {
  flashButton(btn);
  const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
  const trackKey = trackKeys[state.currentTrack];
 
  if (state.currentTrack === 0) {
    // Copy all drums
    clipboard.track = {
      drums: JSON.parse(JSON.stringify(patterns[state.currentPattern].drums)),
      drumVelocity: JSON.parse(JSON.stringify(patterns[state.currentPattern].drumVelocity))
    };
    showMessage(`üìã DRUMS COPIED (1-${patterns[state.currentPattern].length})`);
  } else {
    // Copy melodic track
    clipboard.track = {
      notes: [...patterns[state.currentPattern][trackKey]],
      velocity: [...patterns[state.currentPattern].velocity[trackKey]],
      chords: state.currentTrack === 4 ? [...patterns[state.currentPattern].arpChords] : null
    };
    showMessage(`üìã ${trackKey.toUpperCase()} COPIED (1-${patterns[state.currentPattern].length})`);
  }
  return;
}

// PASTE TRACK
if (id === 'edit-paste-trk') {
  if (!clipboard.track) {
    showMessage('‚ùå NO TRACK IN CLIPBOARD');
    return;
  }
  flashButton(btn);
  saveUndoState();
 
  const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
  const trackKey = trackKeys[state.currentTrack];
 
  if (state.currentTrack === 0 && clipboard.track.drums) {
    // Paste drums
    patterns[state.currentPattern].drums = JSON.parse(JSON.stringify(clipboard.track.drums));
    patterns[state.currentPattern].drumVelocity = JSON.parse(JSON.stringify(clipboard.track.drumVelocity));
    showMessage(`üìã DRUMS PASTED (1-${patterns[state.currentPattern].length})`);
  } else if (state.currentTrack > 0 && clipboard.track.notes) {
    // Paste melodic track
    patterns[state.currentPattern][trackKey] = [...clipboard.track.notes];
    patterns[state.currentPattern].velocity[trackKey] = [...clipboard.track.velocity];
    if (state.currentTrack === 4 && clipboard.track.chords) {
      patterns[state.currentPattern].arpChords = [...clipboard.track.chords];
    }
    showMessage(`üìã ${trackKey.toUpperCase()} PASTED (1-${patterns[state.currentPattern].length})`);
  } else {
    showMessage('‚ùå TRACK TYPE MISMATCH');
    return;
  }
 
  updateSteps();
  updateUI();
  return;
}

// CLEAR PATTERN
if (id === 'edit-clear-pat') {
  flashButton(btn);
  saveUndoState();
 
  // Clear entire pattern
  patterns[state.currentPattern] = createEmptyPattern();
 
  updateSteps();
  updateUI();
  showMessage(`üóëÔ∏è PATTERN ${state.currentPattern + 1} CLEARED`);
  return;
}

// CLEAR TRACK
if (id === 'edit-clear-trk') {
  flashButton(btn);
  saveUndoState();
 
  const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
  const trackKey = trackKeys[state.currentTrack];
 
  if (state.currentTrack === 0) {
    // Clear all drums
    ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
      patterns[state.currentPattern].drums[drum] = new Array(64).fill(false);
      patterns[state.currentPattern].drumVelocity[drum] = new Array(64).fill(1.0);
    });
    showMessage(`üóëÔ∏è DRUMS CLEARED (1-${patterns[state.currentPattern].length})`);
  } else {
    // Clear melodic track
    patterns[state.currentPattern][trackKey] = new Array(64).fill('');
    patterns[state.currentPattern].velocity[trackKey] = new Array(64).fill(0.8);
    if (state.currentTrack === 4) {
      patterns[state.currentPattern].arpChords = new Array(64).fill(null);
    }
    showMessage(`üóëÔ∏è ${trackKey.toUpperCase()} CLEARED (1-${patterns[state.currentPattern].length})`);
  }
 
  updateSteps();
  updateUI();
  return;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TRANSPOSE BUTTONS - FIXED WITH FLASH
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

if (id.startsWith('edit-trans')) {
  const semitones = id === 'edit-trans+1' ? 1 :
                    id === 'edit-trans+12' ? 12 :
                    id === 'edit-trans-1' ? -1 :
                    id === 'edit-trans-12' ? -12 : 0;
 
  if (semitones === 0) return;
 
  flashButton(btn);
 
  if (state.currentTrack === 0) {
    showMessage('‚ùå CANNOT TRANSPOSE DRUMS');
    return;
  }
 
  saveUndoState();
  const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
  const trackKey = trackKeys[state.currentTrack];
  const pat = patterns[state.currentPattern];
 
  let transposed = 0;
  for (let i = 0; i < patterns[state.currentPattern].length; i++) {
    const note = pat[trackKey][i];
    if (note && note !== '' && note !== 'TIE' && note !== 'REST' && note !== '-' && note !== '^') {
      pat[trackKey][i] = transposeNote(note, semitones);
      transposed++;
    }
  }
 
  updateSteps();
  showMessage(`üéµ ${transposed} NOTES TRANSPOSED ${semitones > 0 ? '+' : ''}${semitones}`);
  return;
}
// PATTERN LENGTH BUTTON
// PATTERN LENGTH BUTTON
if (id === 'patlen') {
  const lengths = [64, 32, 16, 8, 4, 2, 1];
  const currentIndex = lengths.indexOf(patterns[state.currentPattern].length);  // ‚Üê CHANGED
  const nextIndex = (currentIndex + 1) % lengths.length;
  patterns[state.currentPattern].length = lengths[nextIndex];  // ‚Üê CHANGED
 
  // Reset highlighted step if beyond new length
  if (state.highlightedStep >= patterns[state.currentPattern].length) {  // ‚Üê CHANGED
    state.highlightedStep = patterns[state.currentPattern].length - 1;  // ‚Üê CHANGED
  }
 
  // Reset current step if playing and beyond length
  if (state.currentStep >= patterns[state.currentPattern].length) {  // ‚Üê CHANGED
    state.currentStep = 0;
  }
 
  updatePatternLengthButton();
  updateSteps();
  updateHUD();
  showMessage(`LENGTH: ${patterns[state.currentPattern].length}`);  // ‚Üê CHANGED
  return;
}

if (id === 'edit-arp-toggle') {
    state.arp.enabled = !state.arp.enabled;
    updateEditArpDisplay();
    showMessage(state.arp.enabled ? '‚ô™ ARP ON' : '‚ô™ ARP OFF');
    return;
  }

  // SCOPE MODE TOGGLE
  if (id === 'scope-toggle') {
    state.scopeMode = (state.scopeMode + 1) % 2;
    showMessage(state.scopeMode === 0 ? 'üìä BAR MODE' : '„Ä∞Ô∏è WAVEFORM MODE');
    return;
  }
if (id === 'osc1') {
  flashButton(btn);
  state.scopeMode = 0;
  updateOscButtons();
  showMessage('üìä OSC1: BAR MODE');
  return;
}
// OSC2 BUTTON - Waveform mode
if (id === 'osc2') {
  flashButton(btn);
  state.scopeMode = 1;
  updateOscButtons();
  showMessage('„Ä∞Ô∏è OSC2: WAVEFORM');
  return;
}

  if (id === 'edit-arp-time') {
    state.arp.timeSubdivision = (state.arp.timeSubdivision + 1) % arpTimeSubdivisions.length;
    const timeLabel = document.getElementById('edit-arp-time-label');
    if (timeLabel) {
      timeLabel.setAttribute('value', arpTimeSubdivisions[state.arp.timeSubdivision]);
    }
    showMessage(`‚ô™ ARP TIME: ${arpTimeSubdivisions[state.arp.timeSubdivision]}`);
    return;
  }

  if (id === 'edit-arp-type') {
    state.arp.pattern = (state.arp.pattern + 1) % arpPatterns.length;
    const typeLabel = document.getElementById('edit-arp-type-label');
    if (typeLabel) {
      typeLabel.setAttribute('value', arpPatterns[state.arp.pattern]);
    }
    showMessage(`‚ô™ ARP TYPE: ${arpPatterns[state.arp.pattern]}`);
    return;
  }

  // ARP WRITE
  if (id === 'edit-arp-write') {
    console.log('‚úçÔ∏è WRITE ARP clicked');
    btn.setAttribute('color', '#00FF00');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:3.0');
    btn.setAttribute('scale', '1.15 1.15 1.15');
    setTimeout(() => {
      btn.setAttribute('color', '#00AA00');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      btn.setAttribute('scale', '1 1 1');
    }, 300);
   
    saveUndoState();
    const pat = patterns[state.currentPattern];
    let notesWritten = 0;
    const stepIntervals = [1, 1.5, 2, 3, 4, 8];
    const stepInterval = stepIntervals[state.arp.timeSubdivision];
   
    for (let step = 0; step < patterns[state.currentPattern].length; step += stepInterval) {
      const actualStep = Math.floor(step);
      const chord = pat.arpChords[actualStep];
     
      if (chord && chord.root !== undefined) {
        const chordType = chordTypes[chord.type];
        const intervals = chordIntervals[chordType] || [0, 4, 7];
        let rootNote = pat.arp[actualStep];
        if (!rootNote || rootNote === '' || rootNote === 'TIE' || rootNote === 'REST') {
          const rootNoteName = chordRoots[chord.root];
          rootNote = rootNoteName + '4';
        }
        const rootMidi = midiOf(rootNote);
        const firstNote = midiToNote(rootMidi + intervals[0]);
        pat.arp[actualStep] = firstNote;
        notesWritten++;
      }
    }
    updateSteps();
    showMessage(`‚úçÔ∏è WROTE ${notesWritten} NOTES @ ${arpTimeSubdivisions[state.arp.timeSubdivision]}`);
    return;
  }

  // GENERATOR BUTTONS
  if (id === 'edit-gen-beat') {
    saveUndoState();
    generateRandomBeat();
    updateEditSteps();
    showMessage('üé≤ RANDOM BEAT GENERATED');
    return;
  }
 
  if (id === 'edit-gen-fill') {
    saveUndoState();
    generateRandomFill();
    updateEditSteps();
    showMessage('üé≤ RANDOM FILL GENERATED');
    return;
  }
 
  if (id === 'edit-gen-bass') {
    saveUndoState();
    generateBassline();
    updateEditSteps();
    showMessage('üé≤ BASSLINE GENERATED');
    return;
  }
 
  if (id === 'edit-gen-rand') {
    saveUndoState();
    generateRandomPattern();
    updateEditSteps();
    showMessage('üé≤ PATTERN RANDOMIZED');
    return;
  }

  // DECAY BUTTONS
// DECAY BUTTONS
// DECAY BUTTONS - MUST BE CHECKED BEFORE OCTAVE BUTTONS
if (id === 'edit-decay+' || id === 'edit-decay-') {
  flashButton(btn);
  const isUp = id === 'edit-decay+';
 
  state.trackDecay[state.currentTrack] = Math.max(0.1, Math.min(2.0,
    state.trackDecay[state.currentTrack] + (isUp ? 0.1 : -0.1)
  ));
 
  showMessage(`DECAY: ${state.trackDecay[state.currentTrack].toFixed(1)}`);
  return;  // ‚Üê CRITICAL: Return immediately to prevent octave handler from running
}

  // GLOBAL UNDO
  if (id === 'global-undo') {
    performUndo();
    return;
  }

  // DEMO BUTTON
  if (id === 'demo-1') {
    console.log('üîò DEMO1 button clicked');
    btn.setAttribute('color', '#FFFF00');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FFFF00;emissiveIntensity:3.0');
    btn.setAttribute('scale', '1.1 1.1 1.1');
    showMessage('‚è≥ LOADING DEMO...');
    if (audioContext && audioContext.state === 'suspended') {
      audioContext.resume();
    }
    await loadDemoFromJSON();
    btn.setAttribute('color', '#CC9933');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
    return;
  }

  // PAGE NAVIGATION
  if (id.startsWith('page-')) {
    const page = id.split('-')[1];
    showPage(page);
    return;
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CHORD PAGE HANDLERS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SONG MODE CONTROL BUTTONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// SONG PAT +/-
if (id === 'song-pat-') {
  flashButton(btn);
  state.currentPattern = (state.currentPattern - 1 + 16) % 16;
  updateUI();
  showMessage(`PATTERN ${state.currentPattern + 1}`);
  return;
}

if (id === 'song-pat+') {
  flashButton(btn);
  state.currentPattern = (state.currentPattern + 1) % 16;
  updateUI();
  showMessage(`PATTERN ${state.currentPattern + 1}`);
  return;
}

// SONG ADD - Places current pattern at selected slot
// SONG ADD - NEW CODE (AUTO-ADVANCE CURSOR)
if (id === 'song-add') {
  saveUndoState();
  flashButton(btn);
 
  // Add pattern to current slot
  state.songArrangement[ui.selectedSongSlot] = state.currentPattern + 1;
 
  const currentSlot = ui.selectedSongSlot + 1;
 
  // Auto-advance to next slot (wrap at 64)
  ui.selectedSongSlot = (ui.selectedSongSlot + 1) % 64;
 
  updateSongSlots();
  updateHUD();
  showMessage(`‚úÖ PAT ${state.currentPattern + 1} ‚Üí SLOT ${currentSlot} (NEXT: ${ui.selectedSongSlot + 1})`);
  return;
}

// SONG CLEAR - Clears selected slot
if (id === 'song-clear') {
  saveUndoState();
  flashButton(btn);
  state.songArrangement[ui.selectedSongSlot] = 0;
  updateSongSlots();
  showMessage(`üóëÔ∏è CLEARED SLOT ${ui.selectedSongSlot + 1}`);
  return;
}

// SONG INSERT - Inserts current pattern and shifts everything right
if (id === 'song-ins') {
  saveUndoState();
  flashButton(btn);
 
  // Shift everything from selected slot to the right
  for (let i = 63; i > ui.selectedSongSlot; i--) {
    state.songArrangement[i] = state.songArrangement[i - 1];
  }
 
  // Insert current pattern at selected slot
  state.songArrangement[ui.selectedSongSlot] = state.currentPattern + 1;
 
  updateSongSlots();
  showMessage(`‚è© INSERTED PAT ${state.currentPattern + 1} AT ${ui.selectedSongSlot + 1}`);
  return;
}

// SONG REMOVE - Removes selected slot and shifts everything left
if (id === 'song-rem') {
  saveUndoState();
  flashButton(btn);
 
  // Shift everything from selected slot to the left
  for (let i = ui.selectedSongSlot; i < 63; i++) {
    state.songArrangement[i] = state.songArrangement[i + 1];
  }
 
  // Clear the last slot
  state.songArrangement[63] = 0;
 
  updateSongSlots();
  showMessage(`‚è™ REMOVED SLOT ${ui.selectedSongSlot + 1}`);
  return;
}

// SONG BPM CONTROLS
if (id === 'song-bpm-') {
  flashButton(btn);
  state.tempo = Math.max(40, state.tempo - 5);
  showMessage(`BPM: ${state.tempo}`);
  return;
}

if (id === 'song-bpm+') {
  flashButton(btn);
  state.tempo = Math.min(240, state.tempo + 5);
  showMessage(`BPM: ${state.tempo}`);
  return;
}

// SONG TRANSPORT
// SONG PLAY - NEW CODE (START FROM SELECTED SLOT)
// SONG PLAY - NEW CODE (START FROM SELECTED SLOT)
if (id === 'song-play') {
  console.log('üéº SONG-PLAY BUTTON CLICKED!');
  flashButton(btn);
  state.isPlaying = true;
  state.arrangementMode = true;  // <-- CRITICAL LINE
  state.currentArrangementIndex = ui.selectedSongSlot;
  state.currentStep = 0;
 
  // Load the pattern at the selected slot
  const patternNum = state.songArrangement[ui.selectedSongSlot];
  if (patternNum > 0) {
    state.currentPattern = patternNum - 1;
  }
 
  if (audioContext) nextNoteTime = audioContext.currentTime;
  showMessage(`‚ñ∂ PLAYING FROM SLOT ${ui.selectedSongSlot + 1}`);
  console.log(`üéº Arrangement mode set to: ${state.arrangementMode}`);
  console.log(`üéº Starting at slot: ${state.currentArrangementIndex}`);
  return;
}

if (id === 'song-stop') {
  flashButton(btn);
  state.isPlaying = false;
  state.arrangementMode = false;
  stopAllSources();
  showMessage('‚èπ STOPPED');
  return;
}

if (id === 'song-rec') {
  state.isRecording = !state.isRecording;
  updateUI();
  showMessage(state.isRecording ? '‚è∫ RECORDING' : '‚èπ REC OFF');
  return;
}

if (id === 'song-playblk') {
  flashButton(btn);
  state.playBlockMode = !state.playBlockMode;
  showMessage(state.playBlockMode ? 'üîí BLOCK MODE' : 'üîì FREE MODE');
  return;
}

  // CHORD VIEW BUTTONS
  // CHORD VIEW BUTTONS - ADD THIS HANDLER
if (id.startsWith('chord-v')) {
  const viewIndex = parseInt(id.split('-v')[1]) - 1;
  state.currentStepView = viewIndex;
 
  // Highlight the selected view button
  if (ui.chordViewButtons) {
    ui.chordViewButtons.forEach((btn, i) => {
      if (i === viewIndex) {
        btn.setAttribute('color', purple);
        btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:1.2`);
      } else {
        btn.setAttribute('color', '#336688');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      }
    });
  }
 
  updateChordSteps();
  updateHUD();
  showMessage(`VIEW ${viewIndex + 1} (${viewIndex * 16 + 1}-${viewIndex * 16 + 16})`);
  return;
}
 
  if (id === 'chord-pat-') {
    state.currentPattern = (state.currentPattern - 1 + 16) % 16;
    updateChordSteps();
    updateUI();
    showMessage(`PATTERN ${state.currentPattern + 1}`);
    return;
  }
 
  if (id === 'chord-pat+') {
    state.currentPattern = (state.currentPattern + 1) % 16;
    updateChordSteps();
    updateUI();
    showMessage(`PATTERN ${state.currentPattern + 1}`);
    return;
  }

  // CHORD CLEAR BUTTON
  if (id === 'chord-clear') {
    saveUndoState();
    const pat = patterns[state.currentPattern];
    const clickedStep = state.highlightedStep;
    const hadChord = pat.arpChords[clickedStep] && pat.arpChords[clickedStep].root !== undefined;
   
    if (!hadChord) {
      state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
      const newView = Math.floor(state.highlightedStep / 16);
      if (newView !== state.currentStepView) state.currentStepView = newView;
      updateChordSteps();
      updateHUD();
      showMessage(`‚è≠Ô∏è STEP ${clickedStep + 1} EMPTY - ADVANCING`);
      return;
    }
   
    btn.setAttribute('color', '#FF0000');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FF0000;emissiveIntensity:3.0');
    btn.setAttribute('scale', '1.15 1.15 1.15');
    setTimeout(() => {
      btn.setAttribute('color', '#AA3333');
      btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      btn.setAttribute('scale', '1 1 1');
    }, 300);
   
    pat.arpChords[clickedStep] = null;
    const oldStep = state.highlightedStep;
    state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
    const newView = Math.floor(state.highlightedStep / 16);
    if (newView !== state.currentStepView) state.currentStepView = newView;
   
    updateChordSteps();
    updateHUD();
    showMessage(`üóëÔ∏è CLEARED ${oldStep + 1} ‚Üí STEP ${state.highlightedStep + 1}`);
    return;
  }

  // CHORD BPM/TRANSPORT
  if (id === 'chord-bpm-') {
    state.tempo = Math.max(40, state.tempo - 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'chord-bpm+') {
    state.tempo = Math.min(240, state.tempo + 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'chord-play2') {
    state.isPlaying = true;
    state.currentStep = 0;
    if (audioContext) nextNoteTime = audioContext.currentTime;
    showMessage('‚ñ∂ PLAYING');
    return;
  }
  if (id === 'chord-stop2') {
    state.isPlaying = false;
    stopAllSources();
    showMessage('‚èπ STOPPED');
    return;
  }
  if (id === 'chord-rec') {
    state.isRecording = !state.isRecording;
    updateUI();
    showMessage(state.isRecording ? '‚è∫ RECORDING' : '‚èπ REC OFF');
    return;
  }
  if (id === 'chord-playblk') {
    state.playBlockMode = !state.playBlockMode;
    showMessage(state.playBlockMode ? 'üîí BLOCK MODE' : 'üîì FREE MODE');
    return;
  }
 
  // CHORD ROOT SELECTION
  if (id.startsWith('chord-root-')) {
    const rootIdx = parseInt(id.split('-')[2]);
    state.chordSelectionRoot = rootIdx;
   
    for (let i = 0; i < 12; i++) {
      const btn = document.getElementById(`chord-root-${i}`);
      if (btn) {
        if (i === rootIdx) {
          btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:2.0`);
          btn.setAttribute('scale', '1.15 1.15 1.15');
        } else {
          btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
          btn.setAttribute('scale', '1 1 1');
        }
      }
    }
   
    updateChordSteps();
    updateHUD();
    showMessage(`ROOT: ${chordRoots[rootIdx]}`);
    return;
  }
 
  // CHORD TYPE SELECTION
 // CHORD TYPE SELECTION
if (id.startsWith('chord-type-')) {
  const typeIdx = parseInt(id.split('-')[2]);
  state.chordSelectionType = typeIdx;
 
  for (let i = 0; i < 8; i++) {
    const typeBtn = document.getElementById(`chord-type-${i}`);
    if (typeBtn) {
      const label = typeBtn.querySelector('a-text');
     
      if (i === typeIdx) {
        typeBtn.setAttribute('color', '#00FFAA');
        typeBtn.setAttribute('material', `metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:2.0`);
        typeBtn.setAttribute('scale', '1.15 1.15 1.15');
        if (label) label.setAttribute('color', '#000000'); // BLACK TEXT
      } else {
        typeBtn.setAttribute('color', '#5588AA');
        typeBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
        typeBtn.setAttribute('scale', '1 1 1');
        if (label) label.setAttribute('color', 'white'); // WHITE TEXT
      }
    }
  }
   
    updateChordSteps();
    updateHUD();
    showMessage(`TYPE: ${chordTypes[typeIdx]}`);
    return;
  }
 
  // CHORD STEP BUTTONS - SINGLE HANDLER ONLY
  if (id.startsWith('chord-step-')) {
    const stepIndex = parseInt(id.split('-')[2]);
    const clickedStep = (state.currentStepView * 16) + stepIndex;
    const pat = patterns[state.currentPattern];
   
    state.highlightedStep = clickedStep;
    updateChordSteps();
    updateHUD();
   
    const existingChord = pat.arpChords[clickedStep];
    const hasChordSelected = (state.chordSelectionRoot !== null && state.chordSelectionType !== null);
   
    if (!hasChordSelected) {
      if (existingChord && existingChord.root !== undefined) {
        const chordName = chordRoots[existingChord.root] + chordTypes[existingChord.type];
        showMessage(`üìç STEP ${clickedStep + 1}: ${chordName}`);
      } else {
        showMessage(`üìç STEP ${clickedStep + 1}: EMPTY`);
      }
      return;
    }

    const hasSameChord = existingChord &&
                         existingChord.root === state.chordSelectionRoot &&
                         existingChord.type === state.chordSelectionType;
   
    if (hasSameChord) {
      saveUndoState();
      const rootToClear = existingChord.root;
      const typeToClear = existingChord.type;
      pat.arpChords[clickedStep] = null;
     
      let cleared = 1;
      for (let i = clickedStep + 1; i < patterns[state.currentPattern].length; i++) {
        const nextChord = pat.arpChords[i];
        if (!nextChord || nextChord.root !== rootToClear || nextChord.type !== typeToClear) {
          break;
        }
        pat.arpChords[i] = null;
        cleared++;
      }
     
      updateChordSteps();
      updateHUD();
      showMessage(`üóëÔ∏è ${cleared} STEPS CLEARED`);
     
    } else {
      saveUndoState();
      const chordTypeName = chordTypes[state.chordSelectionType];
      const chordObj = {
        root: state.chordSelectionRoot,
        type: state.chordSelectionType,
        intervals: chordIntervals[chordTypeName]
      };
     
      pat.arpChords[clickedStep] = { ...chordObj };
     
      let filled = 0;
      for (let i = clickedStep + 1; i < patterns[state.currentPattern].length; i++) {
        const nextChord = pat.arpChords[i];
        if (nextChord && nextChord.root !== null &&
            (nextChord.root !== chordObj.root || nextChord.type !== chordObj.type)) {
          break;
        }
        pat.arpChords[i] = { ...chordObj };
        filled++;
      }
     
      updateChordSteps();
      updateHUD();
      showMessage(`‚ô™ ${chordRoots[chordObj.root]} ${chordTypeName} PLACED`);
    }
    return;
  }

 // SONG SLOT BUTTONS
// SONG SLOT BUTTONS - NEW CODE (LOAD PATTERN TOO!)
if (id.startsWith('song-slot-')) {
  const slotIndex = parseInt(id.split('-')[2]);
  ui.selectedSongSlot = slotIndex;
  state.highlightedStep = slotIndex;
 
  // ‚ú® CRITICAL FIX: Load the pattern from this slot into state.currentPattern
  const patternNum = state.songArrangement[slotIndex];
  if (patternNum > 0) {
    state.currentPattern = patternNum - 1;  // ‚Üê Load pattern into current!
    showMessage(`SLOT ${slotIndex + 1}: PATTERN ${patternNum} LOADED`);
  } else {
    showMessage(`SLOT ${slotIndex + 1}: EMPTY`);
  }
 
  updateSongSlots();
  updateHUD();
  return;
}

  // MIXER MODE
  // MIXER MODE
if (id.startsWith('mix-step-')) {
  const stepIndex = parseInt(id.split('-')[2]);
  state.highlightedStep = (state.currentStepView * 16) + stepIndex;
  console.log('üéπ Mixer step clicked, new highlightedStep:', state.highlightedStep);
  updateMixSteps();
  updateUI();
  return;
}
  if (id.startsWith('mix-fader-')) {
    const parts = id.split('-');
    const trackIdx = parseInt(parts[2]);
    const level = parseFloat(btn.dataset.level);
    if (trackIdx < 4) {
      state.drumVolumes[trackIdx] = level;
    } else if (trackIdx < 8) {
      state.trackVolumes[trackIdx - 3] = level;
    } else {
      state.masterVolume = level;
      if (masterGain) masterGain.gain.value = level;
    }
if (state.currentPage !== 'mix') return;
    updateMixerDisplays();
    updateMixerFaders();
    showMessage(`üéöÔ∏è VOL: ${Math.round(level * 100)}%`);
    return;
  }
  if (id.startsWith('mix-track-')) {
    try {
      const trackIdx = parseInt(id.split('-')[2]);
      const now = Date.now();
     
      // Double-click detection
      if (!window.lastMixTrackClick) window.lastMixTrackClick = {};
      const lastClick = window.lastMixTrackClick[trackIdx] || 0;
      const isDoubleClick = (now - lastClick) < 500;
      window.lastMixTrackClick[trackIdx] = now;
     
      if (trackIdx < 4) {
        // Drums
        state.mixerSelectedTrack = trackIdx;
        state.currentTrack = 0;
        const drumNames = ['kick', 'snare', 'hihat', 'open'];
        state.selectedDrum = drumNames[trackIdx];
        // Only preview drum if NOT playing to avoid conflicts
        if (!state.isPlaying) {
          playDrum(drumNames[trackIdx]);
        }
        showMessage(`DRUM: ${drumNames[trackIdx].toUpperCase()}`);
      } else if (trackIdx < 8) {
        // Instruments
        const instIdx = trackIdx - 4;
        const types = ['bass', 'lead', 'pad', 'arp'];
        const type = types[instIdx];
       
        // Double-click cycles sounds
        if (isDoubleClick) {
          const bankSize = SAMPLE_BANKS[type].length;
          state.soundIndex[type] = (state.soundIndex[type] + 1) % bankSize;
          const soundNum = state.soundIndex[type] + 1;
          const soundName = SAMPLE_BANKS[type][state.soundIndex[type]].file.split('/').pop();
          showMessage(`${type.toUpperCase()}: ${soundName}`);
         
          // Load new sound in background - completely non-blocking
          setTimeout(() => {
            try {
              if (!buffers[type] || !buffers[type][state.soundIndex[type]]) {
                console.log(`‚ö° Loading new sound: ${type} #${state.soundIndex[type]}`);
                loadInstrumentBank(type, state.soundIndex[type]).catch(err =>
                  console.error('Failed to load sound:', err)
                );
              }
            } catch (err) {
              console.error('Error loading sound:', err);
            }
          }, 0);
        } else {
          // Single click selects
          state.mixerSelectedTrack = trackIdx;
          state.currentTrack = instIdx + 1;
          showMessage(`${type.toUpperCase()} SELECTED`);
        }
       
        // Load and preview current sound in background - completely non-blocking
        setTimeout(() => {
          try {
            const currentSoundIdx = state.soundIndex[type];
            if (!buffers[type] || !buffers[type][currentSoundIdx]) {
              console.log(`‚ö° Loading sound: ${type} #${currentSoundIdx}`);
              loadInstrumentBank(type, currentSoundIdx).catch(err =>
                console.error('Failed to load sound:', err)
              );
            } else if (!state.isPlaying) {
              // Only preview if NOT playing to avoid conflicts
              const previewNote = type === 'bass' ? 'C2' : 'C4';
              playInstrument(instIdx, previewNote);
            }
          } catch (err) {
            console.error('Error in preview:', err);
          }
        }, 0);
      } else {
        state.mixerSelectedTrack = trackIdx;
        showMessage('MASTER CHANNEL');
      }
      for (let i = 0; i < 9; i++) {
        const trackBtn = document.getElementById(`mix-track-${i}`);
        if (trackBtn) {
          if (i === state.mixerSelectedTrack) {
            trackBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:1.5');
            trackBtn.setAttribute('scale', '1.1 1.1 1.1');
          } else {
            trackBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
            trackBtn.setAttribute('scale', '1 1 1');
          }
        }
      }
      updateSynthBodyColor();
    } catch (err) {
      console.error('Error in mixer track click:', err);
      showMessage('‚ùå ERROR - CHECK CONSOLE');
    }
    return;
  }
 
  // MIX WRITE/CLEAR BUTTONS
  // MIX WRITE/CLEAR BUTTONS
if (id === 'mix-write') {
  flashButton(btn);  // ‚Üê ADD THIS LINE
  saveUndoState();
  const pat = patterns[state.currentPattern];
  const step = state.highlightedStep;
  pat.mix[step] = {
    drumVolumes: [...state.drumVolumes],
    drumPans: [...state.drumPans],
    trackVolumes: [...state.trackVolumes],
    trackPans: [...state.trackPans],
    masterVolume: state.masterVolume
  };
  updateMixSteps();
  showMessage(`üíæ MIX DATA SAVED AT STEP ${step + 1}`);
  return;
}
if (id === 'mix-clear') {
  flashButton(btn);  // ‚Üê ADD THIS LINE
  saveUndoState();
  const pat = patterns[state.currentPattern];
  const step = state.highlightedStep;
  pat.mix[step] = null;
  updateMixSteps();
  showMessage(`üóëÔ∏è MIX DATA CLEARED AT STEP ${step + 1}`);
  return;
}

  // STEP BUTTONS
  if (id.startsWith('step-')) {
    if (state.currentPage === 'mix') {
      const stepIndex = parseInt(id.split('-')[1]);
      state.highlightedStep = (state.currentStepView * 16) + stepIndex;
      updateMixSteps();
      return;
    }
    if (state.tieMode) {
      saveUndoState();
      const stepIndex = parseInt(id.split('-')[1]);
      const clickedStep = (state.currentStepView * 16) + stepIndex;
     
      if (state.currentTrack === 0) {
        showMessage('‚ö†Ô∏è CANNOT TIE DRUMS');
      } else {
        const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
        patterns[state.currentPattern][trackKey][clickedStep] = 'TIE';
        showMessage(`‚ûñ TIE at step ${clickedStep + 1}`);
      }
      updateSteps();
      return;
    }
    if (state.restMode) {
      saveUndoState();
      const stepIndex = parseInt(id.split('-')[1]);
      const clickedStep = (state.currentStepView * 16) + stepIndex;
     
      if (state.currentTrack === 0) {
        ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
          patterns[state.currentPattern].drums[drum][clickedStep] = false;
        });
        showMessage(`üîá REST at step ${clickedStep + 1}`);
      } else {
        const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
        patterns[state.currentPattern][trackKey][clickedStep] = 'REST';
        showMessage(`üîá REST at step ${clickedStep + 1}`);
      }
      updateSteps();
      return;
    }
    if (state.clearStepMode) {
      saveUndoState();
      if (state.currentTrack === 0) {
        ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
          patterns[state.currentPattern].drums[drum][state.highlightedStep] = false;
        });
      } else {
        const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
        patterns[state.currentPattern][trackKey][state.highlightedStep] = '';
        if (state.currentTrack === 4) {
          patterns[state.currentPattern].arpChords[state.highlightedStep] = null;
        }
      }
      state.clearStepMode = false;
      updateClearStepButton();
    }
   if (state.copyStepMode) {
  saveUndoState();
  const prevStep = state.highlightedStep - 1;
  if (prevStep >= 0) {
    if (state.currentTrack === 0) {
      ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
        patterns[state.currentPattern].drums[drum][state.highlightedStep] =
          patterns[state.currentPattern].drums[drum][prevStep];
        patterns[state.currentPattern].drumVelocity[drum][state.highlightedStep] =
          patterns[state.currentPattern].drumVelocity[drum][prevStep];
      });
    } else {
      const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
      patterns[state.currentPattern][trackKey][state.highlightedStep] =
        patterns[state.currentPattern][trackKey][prevStep];
      patterns[state.currentPattern].velocity[trackKey][state.highlightedStep] =
        patterns[state.currentPattern].velocity[trackKey][prevStep];
      if (state.currentTrack === 4) {
        patterns[state.currentPattern].arpChords[state.highlightedStep] =
          patterns[state.currentPattern].arpChords[prevStep];
      }
    }
    state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
  }
  state.copyStepMode = false;
  updateCopyStepButton();
}
   
    // DEFAULT: Just select/highlight the clicked step
    const stepIndex = parseInt(id.split('-')[1]);
    state.highlightedStep = (state.currentStepView * 16) + stepIndex;
   
    updateSteps();
    return;
  }

  // PIANO KEYS - FIXED RECORDING
  // PIANO KEYS - UPDATED WITH OCTAVE SHIFT
 // PIANO KEYS - UPDATED WITH VELOCITY FROM CLICK HEIGHT
// PIANO KEYS - UPDATED WITH VELOCITY FROM CLICK HEIGHT
// PIANO KEYS - FIXED VELOCITY DETECTION
// PIANO KEYS - FIXED TO USE Z-AXIS (DEPTH) FOR VELOCITY
// PIANO KEYS - USE STORED Z VALUE
if (id.startsWith('key-')) {
  let note = btn.dataset.note || id.substring(4);
 
  // APPLY OCTAVE SHIFT
  if (state.currentTrack > 0) {
    const shiftSemis = (state.octave - 3) * 12;
    if (shiftSemis !== 0) {
      note = transposeNote(note, shiftSemis);
    }
  }
 
  flashPianoKeyByNote(btn.dataset.note || id.substring(4), state.currentTrack);
 
  if (state.currentTrack === 0) {
    // DRUMS - full velocity
    const drumMap = { 'C3': 'kick', 'D3': 'snare', 'E3': 'hihat', 'F3': 'open' };
    const originalNote = btn.dataset.note || id.substring(4);
    const drum = drumMap[originalNote];
   
    if (drum) {
      playDrum(drum);
      if (state.isRecording) {
        saveUndoState();
        patterns[state.currentPattern].drums[drum][state.highlightedStep] = true;
        state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
        const newView = Math.floor(state.highlightedStep / 16);
        if (newView !== state.currentStepView) state.currentStepView = newView;
        updateSteps();
      }
    }
  } else {
    // MELODIC - Calculate velocity from Y position
   // MELODIC - Calculate velocity from Y position
const trackIdx = state.currentTrack - 1;
const trackKey = ['bass', 'lead', 'pad', 'arp'][trackIdx];
   
let velocity = 0.8; // Default
   
// **CALCULATE VELOCITY FROM Y POSITION - FIXED**
if (btn._lastClickY !== undefined) {
  const localY = btn._lastClickY;
     
  const isWhite = btn.dataset.isWhite === 'true';
  const keyHeight = isWhite ? 0.15 : 0.13;
  const halfHeight = keyHeight / 2;
     
  // localY ranges from -halfHeight (bottom, toward user) to +halfHeight (top, away from user)
  // We want: bottom (negative Y) = LOUD, top (positive Y) = QUIET
     
  // Normalize to 0-1 where 0 = bottom (loud), 1 = top (quiet)
  const normalizedY = (localY + halfHeight) / keyHeight;
     
  // Invert so bottom = 1.0, top = 0.0
 const normalizedDepth = (localY + halfHeight) / keyHeight;
velocity = Math.max(0.01, Math.min(1.0, normalizedDepth));
     
  // Snap to MIDI values (0-127) for consistency
  const midiVel = Math.round(velocity * 127);
  velocity = midiVel / 127;
     
  console.log(`üéπ VEL: ${midiVel}/127 | LocalY: ${localY.toFixed(3)} | Norm: ${normalizedY.toFixed(3)} | Final: ${velocity.toFixed(3)}`);
}
   
    // Store velocity temporarily
    const originalVel = patterns[state.currentPattern].velocity[trackKey][state.highlightedStep];
    patterns[state.currentPattern].velocity[trackKey][state.highlightedStep] = velocity;
  playInstrument(trackIdx, note, velocity);
   
    if (!state.isRecording) {
      // Restore original if not recording
      patterns[state.currentPattern].velocity[trackKey][state.highlightedStep] = originalVel;
    } else {
      // Record the note with velocity
      saveUndoState();
      patterns[state.currentPattern][trackKey][state.highlightedStep] = note;
      patterns[state.currentPattern].velocity[trackKey][state.highlightedStep] = velocity;
     
      if (state.currentTrack === 4) {
        patterns[state.currentPattern].arpChords[state.highlightedStep] = {
          root: state.chordSelectedRoot,
          type: state.chordSelectedType,
          color: chordColors[state.chordSelectedRoot]
        };
      }
     
      state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
      const newView = Math.floor(state.highlightedStep / 16);
      if (newView !== state.currentStepView) state.currentStepView = newView;
      updateSteps();
      updateVelocityLane();
    }
  }
  return;
}

  // DRUM SEQUENCER BUTTONS
 if (id.startsWith('drum-step-')) {
  const parts = id.split('-');
  const drumIdx = parseInt(parts[2]);
  const stepIdx = parseInt(parts[3]);
  const drumNames = ['kick', 'snare', 'hihat', 'open'];
  const drumName = drumNames[drumIdx];
  const step = (state.currentStepView * 16) + stepIdx;
 
  // Prevent double-clicks (debounce)
  if (btn.clickCooldown) return;
  btn.clickCooldown = true;
  setTimeout(() => { btn.clickCooldown = false; }, 150);
 
  saveUndoState();
  const pat = patterns[state.currentPattern];
  const wasActive = pat.drums[drumName][step];
 
  // Toggle the state
  pat.drums[drumName][step] = !wasActive;
 
  // Update display IMMEDIATELY (no delay)
  updateDrumSeqSteps();
 
  // Visual feedback AFTER update
  flashButton(btn, 100);
 
  // Play sound if turning ON
  if (!wasActive) {
    playDrum(drumName);
  }
 
  return;
}
 
  if (id.startsWith('drum-v')) {
    const viewIndex = parseInt(id.split('-v')[1]) - 1;
    state.currentStepView = viewIndex;
    updateDrumSeqSteps();
    return;
  }
 
  if (id === 'drum-play') {
    state.isPlaying = true;
    state.currentStep = 0;
    if (audioContext) nextNoteTime = audioContext.currentTime;
    showMessage('‚ñ∂ PLAYING');
    return;
  }
 
  if (id === 'drum-stop') {
    state.isPlaying = false;
    stopAllSources();
    showMessage('‚èπ STOPPED');
    updateDrumSeqSteps();
    return;
  }
 
  if (id === 'drum-bpm-') {
    state.tempo = Math.max(40, state.tempo - 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
 
  if (id === 'drum-bpm+') {
    state.tempo = Math.min(240, state.tempo + 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
 
  if (id === 'drum-pat-') {
    state.currentPattern = (state.currentPattern - 1 + 16) % 16;
    updateDrumSeqSteps();
    showMessage(`PATTERN ${state.currentPattern + 1}`);
    return;
  }
 
  if (id === 'drum-pat+') {
    state.currentPattern = (state.currentPattern + 1) % 16;
    updateDrumSeqSteps();
    showMessage(`PATTERN ${state.currentPattern + 1}`);
    return;
  }
 
  if (id === 'drum-clear-row') {
    saveUndoState();
    const drumNames = ['kick', 'snare', 'hihat', 'open'];
    const drumName = drumNames[0]; // Clear kick row by default, or you could add row selection
    patterns[state.currentPattern].drums[drumName] = new Array(64).fill(false);
    updateDrumSeqSteps();
    showMessage('üóëÔ∏è ROW CLEARED');
    return;
  }
 
  if (id === 'drum-clear-all') {
    saveUndoState();
    ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
      patterns[state.currentPattern].drums[drum] = new Array(64).fill(false);
    });
    updateDrumSeqSteps();
    showMessage('üóëÔ∏è ALL DRUMS CLEARED');
    return;
  }
 
  if (id === 'drum-rec') {
    state.isRecording = !state.isRecording;
    updateUI();
    showMessage(state.isRecording ? '‚è∫ RECORDING' : '‚èπ REC OFF');
    return;
  }
 
  if (id === 'drum-playblk') {
    state.playBlockMode = !state.playBlockMode;
    showMessage(state.playBlockMode ? 'üîí BLOCK MODE' : 'üîì FREE MODE');
    return;
  }

  // DRUM SELECTION BUTTONS (SEQ page)
if (id.startsWith('drumsel-')) {
  const drumIdx = parseInt(id.split('-')[1]);
  state.selectedDrum = ['kick', 'snare', 'hihat', 'open'][drumIdx];
  updateUI();
  updateSteps();
  return;
}

  // MIXER PAGE BPM/TRANSPORT BUTTONS
  if (id === 'mix-bpm-') {
    state.tempo = Math.max(40, state.tempo - 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'mix-bpm+') {
    state.tempo = Math.min(240, state.tempo + 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'mix-rec') {
    state.isRecording = !state.isRecording;
    updateUI();
    showMessage(state.isRecording ? '‚è∫ RECORDING' : '‚èπ REC OFF');
    return;
  }
  if (id === 'mix-playblk') {
    state.playBlockMode = !state.playBlockMode;
    showMessage(state.playBlockMode ? 'üîí BLOCK MODE' : 'üîì FREE MODE');
    return;
  }
// CHORD CLEAR BUTTON - Must be before generic clear handlers
if (id === 'chord-clear') {
  console.log('üóëÔ∏è CHORD CLEAR CLICKED on CHORD page');
  console.log('   Current step:', state.highlightedStep);
 
  saveUndoState();
  const pat = patterns[state.currentPattern];
  const clickedStep = state.highlightedStep;
 
  // Check if there's a chord at current step
  const hadChord = pat.arpChords[clickedStep] && pat.arpChords[clickedStep].root !== undefined;
 
  if (!hadChord) {
    // No chord to clear, just advance
    console.log('   No chord at this step, just advancing');
    state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
    const newView = Math.floor(state.highlightedStep / 16);
    if (newView !== state.currentStepView) state.currentStepView = newView;
    updateChordSteps();
    updateHUD();
    showMessage(`‚è≠Ô∏è STEP ${clickedStep + 1} EMPTY - ADVANCING`);
    return;
  }
 
  // Visual feedback
  btn.setAttribute('color', '#FF0000');
  btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#FF0000;emissiveIntensity:3.0');
  btn.setAttribute('scale', '1.15 1.15 1.15');
  setTimeout(() => {
    btn.setAttribute('color', '#AA3333');
    btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  }, 300);
 
  // Clear the chord
  console.log('   Clearing chord at step', clickedStep);
  pat.arpChords[clickedStep] = null;
 
  // Auto-advance to next step
  const oldStep = state.highlightedStep;
  state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
  const newView = Math.floor(state.highlightedStep / 16);
  if (newView !== state.currentStepView) {
    console.log('   Switching view from', state.currentStepView, 'to', newView);
    state.currentStepView = newView;
  }
 
  console.log('   Advanced from step', oldStep, 'to', state.highlightedStep);
 
  updateChordSteps();
  updateHUD();
  showMessage(`üóëÔ∏è CLEARED ${oldStep + 1} ‚Üí STEP ${state.highlightedStep + 1}`);
  return;
}
  // CHORD PAGE BPM/TRANSPORT BUTTONS
  if (id === 'chord-bpm-') {
    state.tempo = Math.max(40, state.tempo - 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'chord-bpm+') {
    state.tempo = Math.min(240, state.tempo + 5);
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'chord-play2') {
    state.isPlaying = true;
    state.currentStep = 0;
    if (audioContext) nextNoteTime = audioContext.currentTime;
    showMessage('‚ñ∂ PLAYING');
    return;
  }
  if (id === 'chord-stop2') {
    state.isPlaying = false;
    stopAllSources();
    showMessage('‚èπ STOPPED');
    return;
  }
  if (id === 'chord-rec') {
    state.isRecording = !state.isRecording;
    updateUI();
    showMessage(state.isRecording ? '‚è∫ RECORDING' : '‚èπ REC OFF');
    return;
  }
  if (id === 'chord-playblk') {
    state.playBlockMode = !state.playBlockMode;
    showMessage(state.playBlockMode ? 'üîí BLOCK MODE' : 'üîì FREE MODE');
    return;
  }
 
  // CHORD ROOT SELECTION
  if (id.startsWith('chord-root-')) {
    console.log('üéπüéπüéπ CHORD ROOT BUTTON CLICKED! ID:', id);
    const rootIdx = parseInt(id.split('-')[2]);
    console.log('üéπ Root index:', rootIdx, 'Root name:', chordRoots[rootIdx]);
    state.chordSelectionRoot = rootIdx;
    console.log('üéπ State updated, chordSelectionRoot now:', state.chordSelectionRoot);
   
    // Highlight selected root button
    for (let i = 0; i < 12; i++) {
      const btn = document.getElementById(`chord-root-${i}`);
      if (btn) {
        if (i === rootIdx) {
          btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:2.0`);
          btn.setAttribute('scale', '1.15 1.15 1.15');
          console.log('üéπ Highlighted root button', i);
        } else {
          btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
          btn.setAttribute('scale', '1 1 1');
        }
      }
    }
   
    updateChordSteps();
    updateHUD();
    showMessage(`ROOT: ${chordRoots[rootIdx]}`);
    console.log('üéπ Chord root selection complete!');
    return;
  }
 
  // CHORD TYPE SELECTION
  // CHORD TYPE SELECTION
if (id.startsWith('chord-type-')) {
  console.log('üéπ CHORD TYPE BUTTON CLICKED! ID:', id);
  const typeIdx = parseInt(id.split('-')[2]);
  console.log('üéπ Type index:', typeIdx, 'Type name:', chordTypes[typeIdx]);
  state.chordSelectionType = typeIdx;
  console.log('üéπ State updated, chordSelectionType now:', state.chordSelectionType);
 
  // Highlight selected type button
  for (let i = 0; i < 8; i++) {
    const typeBtn = document.getElementById(`chord-type-${i}`);
    if (typeBtn) {
      if (i === typeIdx) {
        typeBtn.setAttribute('color', '#00FFAA'); // Change color too!
        typeBtn.setAttribute('material', `metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:2.0`);
        typeBtn.setAttribute('scale', '1.15 1.15 1.15');
        console.log('üéπ Highlighted type button', i);
      } else {
        typeBtn.setAttribute('color', '#5588AA'); // Reset to original
        typeBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
        typeBtn.setAttribute('scale', '1 1 1');
      }
    }
  }
 
  updateChordSteps();
  updateHUD();
  showMessage(`TYPE: ${chordTypes[typeIdx]}`);
  console.log('üéπ Chord type selection complete!');
  return;
}
 
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHORD STEP BUTTONS - MUST BE BEFORE GENERIC STEP HANDLER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (id.startsWith('chord-step-')) {
  console.log('üéπ CHORD STEP BUTTON CLICKED! ID:', id);
 
  const stepIndex = parseInt(id.split('-')[2]);
  const clickedStep = (state.currentStepView * 16) + stepIndex;
  const pat = patterns[state.currentPattern];
 
  // ALWAYS update highlighted step first
  state.highlightedStep = clickedStep;
 
  // **IMMEDIATELY update display to show selection**
  updateChordSteps();
  updateHUD();
 
  console.log('üéπ Clicked step:', clickedStep);
  console.log('üéπ Selected chord: Root=' + state.chordSelectionRoot + ', Type=' + state.chordSelectionType);
 
  const existingChord = pat.arpChords[clickedStep];
  console.log('üéπ Existing chord at step:', existingChord);
 
  // Check if we have a chord selected
  const hasChordSelected = (state.chordSelectionRoot !== null && state.chordSelectionType !== null);
 
  // **CRITICAL: If no chord selected, just navigate - don't clear**
  if (!hasChordSelected) {
    console.log('üéπ No chord selected - just navigating');
    if (existingChord && existingChord.root !== undefined) {
      const chordName = chordRoots[existingChord.root] + chordTypes[existingChord.type];
      showMessage(`üìç STEP ${clickedStep + 1}: ${chordName}`);
    } else {
      showMessage(`üìç STEP ${clickedStep + 1}: EMPTY`);
    }
    return;
  }

  // Check if this step already has THIS EXACT chord
  const hasSameChord = existingChord &&
                       existingChord.root === state.chordSelectionRoot &&
                       existingChord.type === state.chordSelectionType;
 
  console.log('üéπ Has chord selected:', hasChordSelected);
  console.log('üéπ Has same chord:', hasSameChord);
 
  if (hasSameChord) {
    // **TOGGLE: Clicking same chord = CLEAR it**
    console.log('üóëÔ∏è CLEARING SAME CHORD!');
    saveUndoState();
   
    const rootToClear = existingChord.root;
    const typeToClear = existingChord.type;
   
    pat.arpChords[clickedStep] = null;
   
    // Clear all subsequent steps with the same chord
    let cleared = 1;
    for (let i = clickedStep + 1; i < patterns[state.currentPattern].length; i++) {
      const nextChord = pat.arpChords[i];
      if (!nextChord || nextChord.root !== rootToClear || nextChord.type !== typeToClear) {
        break;
      }
      pat.arpChords[i] = null;
      cleared++;
    }
   
    console.log('üóëÔ∏è Cleared', cleared, 'steps');
    updateChordSteps();
    updateHUD();
    showMessage(`üóëÔ∏è ${cleared} STEPS CLEARED`);
   
  } else {
    // **PLACE: Different chord or empty step**
    console.log('‚úÖ PLACING NEW CHORD!');
    saveUndoState();
   
    const chordTypeName = chordTypes[state.chordSelectionType];
    const chordObj = {
      root: state.chordSelectionRoot,
      type: state.chordSelectionType,
      intervals: chordIntervals[chordTypeName]
    };
   
    console.log('üéπ Placing chord:', chordRoots[chordObj.root], chordTypeName);
   
    // Place chord at clicked step
    pat.arpChords[clickedStep] = { ...chordObj };
   
    // **Fill forward ONLY until we hit a DIFFERENT chord (not empty, not same)**
    let filled = 0;
    for (let i = clickedStep + 1; i < patterns[state.currentPattern].length; i++) {
      const nextChord = pat.arpChords[i];
     
      // **Stop if we hit a step with a DIFFERENT chord**
      if (nextChord && nextChord.root !== null &&
          (nextChord.root !== chordObj.root || nextChord.type !== chordObj.type)) {
        console.log('üõë Stopped at step', i, '- different chord found:', chordRoots[nextChord.root], chordTypes[nextChord.type]);
        break;
      }
     
      pat.arpChords[i] = { ...chordObj };
      filled++;
    }
   
    console.log('üéπ Filled', filled, 'steps forward');
    updateChordSteps();
    updateHUD();
    showMessage(`‚ô™ ${chordRoots[chordObj.root]} ${chordTypeName} PLACED`);
  }
 
  return;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GENERIC STEP BUTTONS - FOR SEQ, MIX, EDIT PAGES (NOT CHORD)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GENERIC STEP BUTTONS - FOR SEQ, MIX, EDIT PAGES (NOT CHORD)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
if (id.startsWith('step-') || id.startsWith('mix-step-') || id.startsWith('edit-step-')) {
  console.log('üéµ Step button clicked, ID:', id, 'page:', state.currentPage);
 
  // Extract step index
  let stepIndex;
  if (id.startsWith('mix-step-')) {
    stepIndex = parseInt(id.split('-')[2]);
  } else if (id.startsWith('edit-step-')) {
    stepIndex = parseInt(id.split('-')[2]);
  } else {
    stepIndex = parseInt(id.split('-')[1]);
  }
 
  // **CRITICAL: Calculate clickedStep IMMEDIATELY**
  const clickedStep = (state.currentStepView * 16) + stepIndex;
 
  // **MIX PAGE - Handle mix step selection**
  if (state.currentPage === 'mix') {
    state.highlightedStep = clickedStep;
    updateMixSteps();
    updateUI();
    return;
  }
 
  // **SEQ/EDIT PAGE - Normal sequencer behavior**
  if (state.tieMode) {
    saveUndoState();
    if (state.currentTrack === 0) {
      showMessage('‚ö†Ô∏è CANNOT TIE DRUMS');
    } else {
      const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
      patterns[state.currentPattern][trackKey][clickedStep] = 'TIE';
      showMessage(`‚ûñ TIE at step ${clickedStep + 1}`);
    }
    updateSteps();
    return;
  }
 
  if (state.restMode) {
    saveUndoState();
    if (state.currentTrack === 0) {
      ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
        patterns[state.currentPattern].drums[drum][clickedStep] = false;
      });
    } else {
      const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
      patterns[state.currentPattern][trackKey][clickedStep] = 'REST';
    }
    updateSteps();
    return;
  }
 
  if (state.clearStepMode) {
  saveUndoState();
  if (state.currentTrack === 0) {
    ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
      patterns[state.currentPattern].drums[drum][state.highlightedStep] = false;
    });
  } else {
    const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
    patterns[state.currentPattern][trackKey][state.highlightedStep] = '';
    if (state.currentTrack === 4) {
      patterns[state.currentPattern].arpChords[state.highlightedStep] = null;
    }
  }
  updateSteps();
  // Mode stays on - user must click CLRS again to turn off
  return;
}
 
  if (state.copyStepMode) {
    saveUndoState();
    const prevStep = state.highlightedStep - 1;
    if (prevStep >= 0) {
      if (state.currentTrack === 0) {
        ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
          patterns[state.currentPattern].drums[drum][state.highlightedStep] =
            patterns[state.currentPattern].drums[drum][prevStep];
          patterns[state.currentPattern].drumVelocity[drum][state.highlightedStep] =
            patterns[state.currentPattern].drumVelocity[drum][prevStep];
        });
      } else {
        const trackKey = ['', 'bass', 'lead', 'pad', 'arp'][state.currentTrack];
        patterns[state.currentPattern][trackKey][state.highlightedStep] =
          patterns[state.currentPattern][trackKey][prevStep];
        patterns[state.currentPattern].velocity[trackKey][state.highlightedStep] =
          patterns[state.currentPattern].velocity[trackKey][prevStep];
        if (state.currentTrack === 4) {
          patterns[state.currentPattern].arpChords[state.highlightedStep] =
            patterns[state.currentPattern].arpChords[prevStep];
        }
      }
      state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
    }
    state.copyStepMode = false;
    updateCopyStepButton();
  }
 
  // Default: just select the step
  state.highlightedStep = clickedStep;
  updateSteps();
  return;
}
// EDIT VIEW BUTTONS
  if (id.startsWith('edit-v')) {
    const viewIndex = parseInt(id.split('-v')[1]) - 1;
    state.currentStepView = viewIndex;
    updateEditSteps();
    updateEditViewButtons();
    updateHUD();
    showMessage(`VIEW ${viewIndex + 1} (${viewIndex * 16 + 1}-${viewIndex * 16 + 16})`);
    return;
  }
  // VIEW BUTTONS
  // VIEW BUTTONS
// VIEW BUTTONS
 // VIEW BUTTONS
// VIEW BUTTONS
if (id === 'v1' || id === 'v2' || id === 'v3' || id === 'v4' ||
    id.startsWith('mix-v') || id.startsWith('chord-v') || id.startsWith('drum-v')) {
    let viewIndex;
    if (id.startsWith('mix-v')) viewIndex = parseInt(id.split('-v')[1]) - 1;
    else if (id.startsWith('chord-v')) viewIndex = parseInt(id.split('-v')[1]) - 1;
    else if (id.startsWith('drum-v')) viewIndex = parseInt(id.split('-v')[1]) - 1;
    else viewIndex = parseInt(id.substring(1)) - 1;

    state.currentStepView = viewIndex;
    updateSteps();
updateMixerPianoKeys()
    if (state.currentPage === 'mix') {
      updateMixSteps();
      updateMixerPianoKeys(); // ‚Üê ADD THIS LINE
    }
    if (state.currentPage === 'chord') updateChordSteps();
    if (state.currentPage === 'drum') updateDrumSeqSteps();
    if (state.currentPage === 'edit') {
      updateEditSteps();
      updateEditViewButtons();
    }
   
    return;
}

  // TRANSPORT
 // TRANSPORT
if (id === 'play' || id.startsWith('mix-play') || id === 'chord-play') {
  flashButton(btn);
  if (!state.isPlaying) {
    state.isPlaying = true;
    state.arrangementMode = true;  // ‚Üê ADD THIS LINE
    state.currentArrangementIndex = ui.selectedSongSlot || 0;  // ‚Üê ADD THIS LINE
    state.currentStep = 0;
    if (audioContext) nextNoteTime = audioContext.currentTime;
    showMessage('‚ñ∂ PLAYING SONG');  // ‚Üê UPDATED MESSAGE
  }
  return;
}
  if (id === 'stop' || id.startsWith('mix-stop') || id === 'chord-stop') {
     flashButton(btn);
    state.isPlaying = false;
    state.playBlockMode = false;
    state.arrangementMode = false;
    stopAllSources();
    showMessage('‚èπ STOPPED');
    updateSteps();
    return;
  }
  if (id === 'record' || id === 'mix-record') {
    state.isRecording = !state.isRecording;
    updateUI();
    showMessage(state.isRecording ? 'üî¥ RECORDING' : '‚ö´ REC OFF');
    return;
  }
  if (id === 'playblk' || id.startsWith('mix-playb')) {
 flashButton(btn);
    state.playBlockMode = !state.playBlockMode;
    if (state.playBlockMode && !state.isPlaying) {
      state.isPlaying = true;
      state.currentStep = state.currentStepView * 16;
      if (audioContext) nextNoteTime = audioContext.currentTime;
      showMessage('‚ñ∂ PLAY BLOCK');
    } else if (!state.playBlockMode) {
      showMessage('‚èπ BLOCK OFF');
    }
    return;
  }

  // BPM & PATTERN
  // BPM & PATTERN
  if (id === 'bpm-' || id.startsWith('mix-bpm-') || id.startsWith('edit-bpm-')) {
 flashButton(btn);
    state.tempo = Math.max(40, state.tempo - 5);
    updateHUD();
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'bpm+' || id.startsWith('mix-bpm+') || id.startsWith('edit-bpm+')) {
 flashButton(btn);
    state.tempo = Math.min(240, state.tempo + 5);
    updateHUD();
    showMessage(`BPM: ${state.tempo}`);
    return;
  }
  if (id === 'pat-' || id.startsWith('mix-pat-') || id.startsWith('edit-pat-')) {
 flashButton(btn);
    state.currentPattern = (state.currentPattern - 1 + 16) % 16;
    updateSteps();
    updateUI();
    if (state.currentPage === 'edit') updateEditViewButtons();
    showMessage(`PATTERN ${state.currentPattern + 1}`);
    return;
  }
  if (id === 'pat+' || id.startsWith('mix-pat+') || id.startsWith('edit-pat+')) {
 flashButton(btn);
    state.currentPattern = (state.currentPattern + 1) % 16;
    updateSteps();
    updateUI();
    if (state.currentPage === 'edit') updateEditViewButtons();
    showMessage(`PATTERN ${state.currentPattern + 1}`);
    return;
  }
  // OCTAVE
  if (id === 'oct-') {
 flashButton(btn);
    state.octave = Math.max(-2, state.octave - 1);
    updateHUD();
    showMessage(`OCTAVE: ${state.octave >= 0 ? '+' + state.octave : state.octave}`);
    return;
  }
  if (id === 'oct+') {
 flashButton(btn);
    state.octave = Math.min(3, state.octave + 1);
    updateHUD();
    showMessage(`OCTAVE: ${state.octave >= 0 ? '+' + state.octave : state.octave}`);
    return;
  }

// QUANTIZE
// QUANTIZE
if (id === 'quantize') {
  // Cycle through quantize values
  state.quantize = (state.quantize + 1) % 6; // 0-5: off, 32nd, 16th, 8th, 4th, 2nd
 
  const quantizeNames = ['OFF', '32ND', '16TH', '8TH', '4TH', '2ND'];
  showMessage(`‚ö° QUANTIZE: ${quantizeNames[state.quantize]}`);
 
  updateQuantizeButton();
  updateSteps(); // Just redraw - no data modification
  return;
}

// TIE/REST
if (id === 'tie') {
    state.tieMode = !state.tieMode;
    if (state.tieMode) {
      state.restMode = false;
      state.clearStepMode = false;
      state.copyStepMode = false;
    }
    updateTieRestButtons();
    updateClearStepButton();
    updateCopyStepButton();
    showMessage(state.tieMode ? '‚ûñ TIE MODE ON' : 'TIE MODE OFF');
    return;
  }
  if (id === 'rest') {
    state.restMode = !state.restMode;
    if (state.restMode) {
      state.tieMode = false;
      state.clearStepMode = false;
      state.copyStepMode = false;
    }
    updateTieRestButtons();
    updateClearStepButton();
    updateCopyStepButton();
    showMessage(state.restMode ? '^ REST MODE ON' : 'REST MODE OFF');
    return;
  }

  // CLEAR/COPY STEP
  // CLEAR/COPY STEP
// CLEAR STEP / CLEAR BLOCK
if (id === 'clrstep') {
  state.clearStepMode = !state.clearStepMode;
  updateClearStepButton();
  showMessage(state.clearStepMode ? 'üóëÔ∏è CLEAR STEP MODE' : 'CLEAR STEP OFF');
  return;
}
if (id === 'clrblock') {
  flashButton(btn);
  saveUndoState();
 
  const blockStart = state.currentStepView * 16;
  const blockEnd = blockStart + 16;
 
  if (state.currentTrack === 0) {
    // Clear drums in current block
    ['kick', 'snare', 'hihat', 'open'].forEach(drum => {
      for (let i = blockStart; i < blockEnd; i++) {
        patterns[state.currentPattern].drums[drum][i] = false;
      }
    });
    showMessage(`üóëÔ∏è DRUMS CLEARED (${blockStart + 1}-${blockEnd})`);
  } else {
    // Clear current track in current block
    const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
    const trackKey = trackKeys[state.currentTrack];
    for (let i = blockStart; i < blockEnd; i++) {
      patterns[state.currentPattern][trackKey][i] = '';
      if (state.currentTrack === 4) {
        patterns[state.currentPattern].arpChords[i] = null;
      }
    }
    showMessage(`üóëÔ∏è ${trackKey.toUpperCase()} CLEARED (${blockStart + 1}-${blockEnd})`);
  }
 
  updateSteps();
  return;
}
if (id === 'cpystep') {
  state.copyStepMode = !state.copyStepMode;
  if (state.copyStepMode) state.clearStepMode = false;
  updateCopyStepButton();
  updateClearStepButton();
  showMessage(state.copyStepMode ? 'üìã COPY STEP MODE' : 'COPY OFF');
  return;
}

  // SOUND SELECTOR
  if (id === 'snd-prev' || id === 'snd-next') {
    if (state.currentTrack === 0) return;
    const dir = id === 'snd-next' ? 1 : -1;
    const map = ['bass', 'lead', 'pad', 'arp'];
    const typ = map[state.currentTrack - 1];
    const bank = SAMPLE_BANKS[typ];
    if (!bank || bank.length === 0) return;
    state.soundIndex[typ] = (state.soundIndex[typ] + dir + bank.length) % bank.length;
    loadInstrumentBank(typ, state.soundIndex[typ]);
    updateSoundLabel();
    showMessage(`${typ.toUpperCase()}: ${bank[state.soundIndex[typ]].name}`);
    return;
  }

  // FILE OPERATIONS
  if (id === 'file-save') {
 flashButton(btn);
    saveToFile();
    return;
  }
  if (id === 'file-load') {
 flashButton(btn);
    document.getElementById('loadFile').click();
    return;
  }
  if (id === 'file-midi') {
 flashButton(btn);
    exportToMIDI();
    return;
  }

 
 
 
  window.testBass = function() {
 
  if (buffers.bass && buffers.bass[0]) {
    console.log('  ‚úÖ Bass buffer loaded!');
    console.log('  Duration:', buffers.bass[0].duration);
    console.log('  Sample rate:', buffers.bass[0].sampleRate);
    console.log('  Channels:', buffers.bass[0].numberOfChannels);
   
    // Try to play it
    console.log('  üîä Attempting playback...');
    playInstrument(0, 'C3');
  } else {
    console.log('  ‚ùå Bass buffer is NULL!');
    console.log('  Attempting to load bass[0]...');
    loadInstrumentBank('bass', 0).then(() => {
      console.log('  ‚úÖ Bass loaded! Try again.');
    });
  }
};
 
}

// Visual feedback helper for one-time button presses
// Visual feedback helper for one-time button presses
function flashButton(btn, duration = 100) {
  if (!btn) return;
 
  const originalColor = btn.getAttribute('color');
 
  // Flash bright yellow
  btn.setAttribute('color', '#FFFF00');
  btn.setAttribute('material', 'metalness:0.3;roughness:0.6;emissive:#FFFF00;emissiveIntensity:3.0');
  btn.setAttribute('scale', '1.1 1.1 1.1');
 
  // Return to normal after duration
  setTimeout(() => {
    btn.setAttribute('color', originalColor);
    btn.setAttribute('material', 'metalness:0.3;roughness:0.6;emissive:#000000;emissiveIntensity:0');
    btn.setAttribute('scale', '1 1 1');
  }, duration);
}
// ============================================================================
// SECTION 8: VR COMPONENTS, SEQUENCER LOOP & INITIALIZATION
// ============================================================================

// VR CONTROLLER HANDLER COMPONENT
// VR CONTROLLER HANDLER COMPONENT
// VR CONTROLLER HANDLER COMPONENT
// VR CONTROLLER HANDLER COMPONENT
AFRAME.registerComponent('vr-controller-handler', {
  schema: {
    hand: { default: 'right' }
  },
 
  init: function () {
    this.lastIntersected = null;
    this.triggerDown = false;
    this.thumbstickValue = { x: 0, y: 0 };

    // --- BUTTON MAPPING CHANGE ---
    // Changed from 'triggerdown' to 'abuttondown' (A Button)
    // This is for the Table Toggle
    this.el.addEventListener('abuttondown', () => {
      if (this.data.hand === 'right') {
        this.toggleTable();
      }
    });

    // Keep Trigger for clicking things only
    this.el.addEventListener('triggerdown', () => {
      this.triggerDown = true;
      this.tryClick();
    });

    this.el.addEventListener('triggerup', () => {
      this.triggerDown = false;
    });

    // Grip button - Demo Toggle
    this.el.addEventListener('gripdown', () => {
      if (this.data.hand === 'left') {
        this.toggleDemo();
      }
      this.tryClick();
    });

    // B button (right) or Y button (left) - Power Toggle
    this.el.addEventListener('bbuttondown', () => {
      if (this.data.hand === 'right') {
        this.togglePower();
      }
    });
   
    this.el.addEventListener('ybuttondown', () => {
      if (this.data.hand === 'left') {
        this.togglePower();
      }
    });

    // Thumbstick movement
    this.el.addEventListener('thumbstickmoved', (evt) => {
      this.thumbstickValue.x = evt.detail.x;
      this.thumbstickValue.y = evt.detail.y;
    });

    // Raycaster intersection tracking
    this.el.addEventListener('raycaster-intersection', (evt) => {
      if (evt.detail.els.length > 0) {
        this.lastIntersected = evt.detail.els[0];
      }
    });

    this.el.addEventListener('raycaster-intersection-cleared', (evt) => {
      this.lastIntersected = null;
    });
  },

  tick: function(time, delta) {
    const synth = document.getElementById('synthWorkstation');
    if (!synth) return;

    const moveSpeed = 0.002 * (delta / 16);
    const rotateSpeed = 0.1 * (delta / 16);

    // Right controller - X/Y movement + up/down
    if (this.data.hand === 'right' && (Math.abs(this.thumbstickValue.x) > 0.1 || Math.abs(this.thumbstickValue.y) > 0.1)) {
      const currentPos = synth.getAttribute('position');
     
      const deltaX = this.thumbstickValue.x * moveSpeed;
      const deltaY = this.thumbstickValue.y * moveSpeed;
     
      currentPos.x += deltaX;
      currentPos.y += deltaY;
     
      synth.setAttribute('position', currentPos);
     
      // Sync Table Position
      if (state.tableVisible) {
        const table = document.getElementById('glassTable');
        if (table) {
          const tablePos = table.getAttribute('position');
          tablePos.x += deltaX;
          tablePos.y += deltaY;
          table.setAttribute('position', tablePos);
        }
      }
    }

    // Left controller - Z movement + rotation
    if (this.data.hand === 'left') {
      const currentPos = synth.getAttribute('position');
      const currentRot = synth.getAttribute('rotation');
     
      // Forward/back (Y axis)
      if (Math.abs(this.thumbstickValue.y) > 0.1) {
        const deltaZ = this.thumbstickValue.y * moveSpeed;
        currentPos.z += deltaZ;
        synth.setAttribute('position', currentPos);
       
        // Sync Table Z-Position
        if (state.tableVisible) {
          const table = document.getElementById('glassTable');
          if (table) {
            const tablePos = table.getAttribute('position');
            tablePos.z += deltaZ;
            table.setAttribute('position', tablePos);
          }
        }
      }
     
      // Rotation (X axis)
      if (Math.abs(this.thumbstickValue.x) > 0.1) {
        const deltaRot = -this.thumbstickValue.x * rotateSpeed;
        currentRot.y += deltaRot;
        synth.setAttribute('rotation', currentRot);
       
        // --- ROTATION SYNC FIX ---
        // Instead of adding delta, we HARD COPY the synth rotation to the table.
        // This ensures they never drift apart.
        if (state.tableVisible) {
          const table = document.getElementById('glassTable');
          if (table) {
            const tableRot = table.getAttribute('rotation');
            tableRot.y = currentRot.y; // Exact copy of Synth Y-Rotation
            table.setAttribute('rotation', tableRot);
          }
        }
      }
    }
  },

  toggleTable: function() {
    state.tableVisible = !state.tableVisible;
   
    const table = document.getElementById('glassTable');
    let synthShadow = document.getElementById('synthShadow');
   
    if (table) {
      table.object3D.visible = state.tableVisible;
      table.setAttribute('visible', state.tableVisible ? 'true' : 'false');
    }
   
    if (!synthShadow) {
      this.createSynthShadow();
      synthShadow = document.getElementById('synthShadow');
    }
   
    // Toggle shadow visibility (opposite of table)
    if (synthShadow) {
      synthShadow.object3D.visible = !state.tableVisible;
      synthShadow.setAttribute('visible', state.tableVisible ? 'false' : 'true');
    }
   
    showMessage(state.tableVisible ? 'üì¶ TABLE ON' : 'üí® TABLE OFF');
    this.triggerHaptic();
  },

  createSynthShadow: function() {
    const synth = document.getElementById('synthWorkstation');
    if (!synth) return;
   
    // Remove old shadow if it exists
    const oldShadow = document.getElementById('synthShadow');
    if (oldShadow) {
      oldShadow.parentNode.removeChild(oldShadow);
    }
   
    const shadow = document.createElement('a-plane');
    shadow.setAttribute('id', 'synthShadow');
    shadow.setAttribute('width', '3.7');
    shadow.setAttribute('height', '1');
    shadow.setAttribute('position', '-0.2 -1.05 0.1');
    shadow.setAttribute('rotation', '-59 0 0');
    shadow.setAttribute('color', '#000000');
   
    // --- OPACITY FIX ---
    // Set to 0.9 for "more opaque" and ensure transparent is TRUE so it blends
    shadow.setAttribute('material', 'opacity:0.9;transparent:true;shader:flat;side:double');
   
    shadow.setAttribute('visible', 'true');
   
    // Attach to synth as child (this ensures it follows automatically)
    synth.appendChild(shadow);
  },

  toggleDemo: function() {
    if (state.isPlaying) {
      state.isPlaying = false;
      state.arrangementMode = false;
      stopAllSources();
      showMessage('‚èπ STOPPED');
    } else {
      showMessage('‚è≥ LOADING DEMO...');
      loadDemoFromJSON();
    }
    this.triggerHaptic();
  },

  togglePower: function() {
    if (!state.powered) {
      state.powered = true;
      const powerCap = document.getElementById('powerButtonCap');
      if (powerCap) {
        powerCap.classList.remove('power-button-pulse');
        powerCap.setAttribute('material', 'metalness:0.6;roughness:0.4;emissive:#00FF00;emissiveIntensity:2.0');
        powerCap.setAttribute('color', '#00FF00');
      }
      runStartupSequence();
      showMessage('‚ö° POWERING ON...');
    } else {
      state.powered = false;
      powerDown();
      showMessage('‚ö° POWERING OFF...');
    }
    this.triggerHaptic();
  },

  tryClick: function () {
    if (this.lastIntersected && this.lastIntersected.classList.contains('clickable')) {
      this.lastIntersected.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window
      }));
      this.triggerHaptic();
    }
  },

  triggerHaptic: function () {
    const gamepad = this.el.components['tracked-controls']?.controller?.gamepad;
    if (gamepad && gamepad.hapticActuators && gamepad.hapticActuators[0]) {
      gamepad.hapticActuators[0].pulse(0.5, 100);
    }
  }
});

// HAND TRACKING - FINGERTIP TOUCH COMPONENT
AFRAME.registerComponent('hand-fingertip-touch', {
  schema: {
    hand: { default: 'right' }
  },

  init: function () {
    this.indexTipPosition = new THREE.Vector3();
    this.lastTouchedEl = null;
    this.touchCooldown = false;
    this.handVisible = false;

    // Create visual indicator for fingertip
    const color = this.data.hand === 'left' ? '#ff69b4' : '#00ffff';
    this.tipSphere = document.createElement('a-sphere');
    this.tipSphere.setAttribute('radius', '0.012');
    this.tipSphere.setAttribute('color', color);
    this.tipSphere.setAttribute('material', 'shader: flat; opacity: 0');
    this.tipSphere.setAttribute('visible', 'true');
    this.el.sceneEl.appendChild(this.tipSphere);

    // Wait for hand model to load
    this.el.addEventListener('model-loaded', () => {
      this.handVisible = true;
      this.tipSphere.setAttribute('visible', 'true');
    });
  },

  tick: function () {
    if (!this.handVisible) return;

    const handObj = this.el.object3D;
    if (!handObj) return;

    // Find index fingertip bone
    let indexTip = null;
    handObj.traverse((child) => {
      if (child.name && (child.name.includes('index') && child.name.includes('tip'))) {
        indexTip = child;
      }
    });

    if (indexTip) {
      // Update fingertip position
      indexTip.getWorldPosition(this.indexTipPosition);
      this.tipSphere.object3D.position.copy(this.indexTipPosition);

      // Check for button touches
      this.checkButtonTouch();
    }
  },

  checkButtonTouch: function () {
    if (this.touchCooldown) return;

    const clickables = document.querySelectorAll('.clickable');
    if (!clickables.length) return;

    let closest = null;
    let minDist = 0.035; // Touch threshold distance
    const tmp = new THREE.Vector3();

    clickables.forEach(el => {
      if (!el.object3D || !el.object3D.visible) return;
     
      el.object3D.getWorldPosition(tmp);
      const d = tmp.distanceTo(this.indexTipPosition);
     
      if (d < minDist) {
        minDist = d;
        closest = el;
      }
    });

    if (closest && closest !== this.lastTouchedEl) {
      // Trigger click event
      closest.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window
      }));

      this.lastTouchedEl = closest;
      this.touchCooldown = true;

      // Reset cooldown after 300ms
      setTimeout(() => {
  this.touchCooldown = false;
  this.lastTouchedEl = null;
}, 500); // ‚Üê Changed from 300 to 500
    }
  },

  remove: function () {
    if (this.tipSphere && this.tipSphere.parentNode) {
      this.tipSphere.parentNode.removeChild(this.tipSphere);
    }
  }
});

// MAIN SEQUENCER LOOP COMPONENT
// MAIN SEQUENCER LOOP COMPONENT
AFRAME.registerComponent('sequencer-loop', {
  init: function () {
    console.log('üé¨ Sequencer-Loop: Initializing...');
    const sceneEl = this.el.sceneEl;

    // Wait for scene to be fully loaded
    sceneEl.addEventListener('loaded', () => {
      console.log('‚úÖ Scene Loaded: Building UI Elements...');
      try {
        buildUI();
       
        // Set initial page after UI is built
        setTimeout(() => {
          showPage('seq');
          console.log('üèÅ Initial Page Set: SEQ');
        }, 500);
      } catch (err) {
        console.error('‚ùå UI Build Error:', err);
      }
    });

    this.nextStepTime = 0;
  },

// Inside 'sequencer-loop' component...

tick: function (time, timeDelta) {
  if (!state.isPlaying) {
    this.nextStepTime = 0;
    return;
  }

  const currentTime = time / 1000;

  if (this.nextStepTime === 0) {
    this.nextStepTime = currentTime;
  }

  const stepInterval = 60.0 / state.tempo / 4.0;

  if (currentTime >= this.nextStepTime) {
    // === NEW: PRE-STEP CLEANUP ===
    // If we are on the mixer page, force clean the keys BEFORE playing the next step
    if (state.currentPage === 'mix') {
       if (ui.pianoKeys) {
         ui.pianoKeys.forEach(k => k.setAttribute('material', 'emissiveIntensity: 0'));
       }
    }
    // =============================

    playStep();

    this.nextStepTime += stepInterval;

    if (this.nextStepTime < currentTime - stepInterval) {
      this.nextStepTime = currentTime;
    }

    if (!state.playBlockMode) {
      const playheadView = Math.floor(state.currentStep / 16);
      if (playheadView !== state.currentStepView) {
        state.currentStepView = playheadView;
      }
    }

    updateSteps();
   
    // Ensure these update functions are called
    if (state.currentPage === 'mix') {
       updateMixSteps();
       // Force the piano key update here
       updateMixerPianoKeys();
    }
    if (state.currentPage === 'drum') updateDrumSeqSteps();
    if (state.currentPage === 'chord') updateChordSteps();
    if (state.currentPage === 'song') updateSongSlots();
  }

  if (Math.random() > 0.6) {
    updateOsc();
  }
}
});

// ============================================================================
// ============================================================================
// ============================================================================
// INITIALIZATION
// ============================================================================

// Wait for page to load
// Wait for page to load
window.addEventListener('load', () => {
  console.log('üåê Page loaded, setting random skybox...');
  setRandomSkyboxOnLoad();

  // Apply initial skybox state
  setTimeout(() => {
    applySkybox();
  }, 500);

  // **AUTOMATIC MIDI INPUT - No button needed**
  setTimeout(() => {
    console.log('üéπ Auto-initializing MIDI input...');
    initMIDI().then(() => {
      console.log('‚úÖ MIDI ready - connect your keyboard!');
    }).catch(err => {
      console.log('‚ö†Ô∏è MIDI not available (use Chrome/Edge)');
    });
  }, 1000);

  // Set up mode selection buttons
  setTimeout(() => {
    const desktopBtn = document.getElementById('desktopBtn');
    const vrBtn = document.getElementById('vrBtn');
    // ... rest of the code

    if (desktopBtn) {
      desktopBtn.addEventListener('click', () => {
        console.log('üñ•Ô∏è Desktop button clicked');
        startMode('desktop');
      });
      console.log('‚úÖ Desktop button listener attached');
    } else {
      console.error('‚ùå Desktop button not found');
    }

    if (vrBtn) {
      vrBtn.addEventListener('click', () => {
        console.log('ü•Ω VR button clicked');
        startMode('vr');
      });
      console.log('‚úÖ VR button listener attached');
    } else {
      console.error('‚ùå VR button not found');
    }
  }, 100);
});

// Initialize audio on first user interaction
// Initialize audio AND MIDI on first user interaction
document.addEventListener('click', async () => {
  if (!audioInitialized) {
    console.log('üéµ Click detected - attempting audio init...');
    try {
      await initAudio();
      console.log('‚úÖ Audio ready!');
    } catch (err) {
      console.error('‚ùå Audio init failed:', err);
    }
  }
 
  // Also try MIDI again on first click (in case it failed at load)
  if (!midiInitialized) {
    console.log('üéπ Retrying MIDI init on user click...');
    try {
      await initMIDI();
    } catch (err) {
      console.log('‚ö†Ô∏è MIDI still not available');
    }
  }
}, { once: true });

console.log('‚úÖ Mobile 5000 VR Sequencer v5.4 - Script loaded');
console.log('üìã All 12 issues addressed:');
console.log('   1. ‚úÖ Drum mode page builder');
console.log('   2. ‚úÖ Chord mode page builder');
console.log('   3. ‚úÖ Edit mode page builder');
console.log('   4. ‚úÖ Song mode page builder');
console.log('   5. ‚úÖ All pages accessible from navigation');
console.log('   6. ‚úÖ Demo loader with format converter');
console.log('   7. ‚úÖ Recording works during playback');
console.log('   8. ‚úÖ Piano keys light up with hand detection');
console.log('   9. ‚úÖ Desktop camera position fixed');
console.log('  10. ‚úÖ Song mode key lighting per track');
console.log('  11. ‚úÖ Chord buttons fit synth window');
console.log('  12. ‚úÖ Drum buttons repositioned');
console.log('');
console.log('üÜï v5.4 NEW FEATURES:');
console.log('  13. ‚úÖ HUD text moved down & font smaller');
console.log('  14. ‚úÖ Drum right buttons same size as mixer');
console.log('  15. ‚úÖ Drum steps moved right (startX: -0.70)');
console.log('  16. ‚úÖ Keyboard controls (SPACEBAR, arrows, QWERTY)');
console.log('  17. ‚úÖ Page button highlighting');
console.log('  18. ‚úÖ Transpose buttons (+12/-12, +1/-1)');
console.log('  19. ‚úÖ Decay controls (+/-)');
console.log('  20. ‚úÖ MIDI export button');
console.log('  21. ‚úÖ Double-click mixer sound cycling');
console.log('  22. ‚úÖ Enhanced context-sensitive HUD');
console.log('  23. ‚úÖ Version number display (top right)');

// ===========================================================================
// KEYBOARD CONTROLS
// ===========================================================================
// ===========================================================================
// ENHANCED KEYBOARD CONTROLS
// ===========================================================================
document.addEventListener('keydown', (e) => {
  // Don't intercept if typing in an input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
 
  const key = e.key.toLowerCase();
 
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // UNIVERSAL CONTROLS (ALL PAGES)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
 // SPACEBAR - Play/Stop (ALL PAGES)
if (key === ' ') {
  e.preventDefault();
  if (state.isPlaying) {
    state.isPlaying = false;
    state.arrangementMode = false;
    stopAllSources();
    showMessage('‚èπ STOPPED');
  } else {
    console.log('‚å®Ô∏è SPACEBAR PRESSED - Setting arrangementMode TRUE');  // ADD THIS
    state.isPlaying = true;
    state.arrangementMode = true;  // <-- IS THIS LINE THERE?
 state.currentArrangementIndex = ui.selectedSongSlot || 0;
    state.currentStep = 0;
    if (audioContext) nextNoteTime = audioContext.currentTime;
    showMessage('‚ñ∂ PLAYING SONG');
  }
  updateUI();
  return;
}
 
  // ARROW KEYS - Navigation (ALL PAGES)
  if (key === 'arrowleft') {
    e.preventDefault();
    state.highlightedStep = Math.max(0, state.highlightedStep - 1);
    const newView = Math.floor(state.highlightedStep / 16);
    if (newView !== state.currentStepView) state.currentStepView = newView;
    updateSteps();
    if (state.currentPage === 'chord') updateChordSteps();
    if (state.currentPage === 'mix') updateMixSteps();
    if (state.currentPage === 'drum') updateDrumSeqSteps();
    updateHUD();
    return;
  }
 
  if (key === 'arrowright') {
    e.preventDefault();
    state.highlightedStep = Math.min(patterns[state.currentPattern].length - 1, state.highlightedStep + 1);
    const newView = Math.floor(state.highlightedStep / 16);
    if (newView !== state.currentStepView) state.currentStepView = newView;
    updateSteps();
    if (state.currentPage === 'chord') updateChordSteps();
    if (state.currentPage === 'mix') updateMixSteps();
    if (state.currentPage === 'drum') updateDrumSeqSteps();
    updateHUD();
    return;
  }
 
  if (key === 'arrowup') {
    e.preventDefault();
    if (state.currentPage !== 'chord') {
      state.currentTrack = Math.max(0, state.currentTrack - 1);
      if (state.currentTrack === 0) state.selectedDrum = 'kick';
      updateUI();
      updateSteps();
      showMessage(`TRACK: ${trackNames[state.currentTrack]}`);
    }
    return;
  }
 
  if (key === 'arrowdown') {
    e.preventDefault();
    if (state.currentPage !== 'chord') {
      state.currentTrack = Math.min(4, state.currentTrack + 1);
      updateUI();
      updateSteps();
      showMessage(`TRACK: ${trackNames[state.currentTrack]}`);
    }
    return;
  }
 
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CHORD MODE - ROOT NOTE LETTERS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (state.currentPage === 'chord') {
    const chordKeyMap = {
      'c': 0,  // C
      'd': 2,  // D
      'e': 4,  // E
      'f': 5,  // F
      'g': 7,  // G
      'a': 9,  // A
      'b': 11  // B
    };
   
    if (chordKeyMap.hasOwnProperty(key)) {
      e.preventDefault();
      state.chordSelectionRoot = chordKeyMap[key];
     
      // Highlight the root button
      for (let i = 0; i < 12; i++) {
        const btn = document.getElementById(`chord-root-${i}`);
        if (btn) {
          if (i === state.chordSelectionRoot) {
            btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:#FFFFFF;emissiveIntensity:2.0`);
            btn.setAttribute('scale', '1.15 1.15 1.15');
          } else {
            btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
            btn.setAttribute('scale', '1 1 1');
          }
        }
      }
     
      updateChordSteps();
      updateHUD();
      showMessage(`ROOT: ${chordRoots[state.chordSelectionRoot]}`);
      return;
    }
  }
 
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // QWERTY PIANO INPUT (SEQ, EDIT, DRUM PAGES)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (state.currentPage === 'seq' || state.currentPage === 'edit' || state.currentPage === 'drum') {
    const noteMap = {
      'a': 'C', 'w': 'C#', 's': 'D', 'e': 'D#', 'd': 'E',
      'f': 'F', 't': 'F#', 'g': 'G', 'y': 'G#', 'h': 'A',
      'u': 'A#', 'j': 'B', 'k': 'C'  // Extra C for octave
    };
   
    if (noteMap[key] && state.currentTrack > 0) {
      e.preventDefault();
      let note = noteMap[key] + (state.octave + 3);
     
      // Record note if recording
      if (state.isRecording && !state.isPlaying) {
        saveUndoState();
        const trackKeys = ['', 'bass', 'lead', 'pad', 'arp'];
        const trackKey = trackKeys[state.currentTrack];
        const pat = patterns[state.currentPattern];
        pat[trackKey][state.highlightedStep] = note;
        state.highlightedStep = (state.highlightedStep + 1) % patterns[state.currentPattern].length;
        const newView = Math.floor(state.highlightedStep / 16);
        if (newView !== state.currentStepView) state.currentStepView = newView;
        updateSteps();
      }
     
      // Always play the note
      const trackIdx = state.currentTrack - 1;
      playInstrument(trackIdx, note);
      flashPianoKeyByNote(note, state.currentTrack);
      return;
    }
  }
 
  // Z/X - Octave down/up
  if (key === 'z') {
    e.preventDefault();
    state.octave = Math.max(-2, state.octave - 1);
    updateHUD();
    showMessage(`OCTAVE: ${state.octave}`);
    return;
  }
  if (key === 'x') {
    e.preventDefault();
    state.octave = Math.min(2, state.octave + 1);
    updateHUD();
    showMessage(`OCTAVE: ${state.octave}`);
    return;
  }
 
  // R - Toggle recording
  if (key === 'r') {
    e.preventDefault();
    state.isRecording = !state.isRecording;
    updateUI();
    showMessage(state.isRecording ? '‚è∫ RECORDING' : '‚èπ REC OFF');
    return;
  }
});

console.log('‚å®Ô∏è Enhanced keyboard controls initialized');
console.log('   SPACE = Play/Stop SONG (all pages)');
console.log('   ‚Üê ‚Üí = Navigate steps (all pages)');
console.log('   ‚Üë ‚Üì = Change tracks');
console.log('   AWSEDFTGYHUJ = Piano input');
console.log('   CDEFGAB = Chord root selection (chord page)');
console.log('   Z/X = Octave');
console.log('   R = Record');


function updateEditArpDisplay() {
  // Update ARP toggle button
  const arpToggle = document.getElementById('edit-arp-toggle');
  if (arpToggle) {
    if (state.arp.enabled) {
      arpToggle.setAttribute('color', '#00FF00');
      arpToggle.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.5');
    } else {
      arpToggle.setAttribute('color', '#9b5cff');
      arpToggle.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    }
  }
 
  // Update time subdivision label
  const timeLabel = document.getElementById('edit-arp-time-label');
  if (timeLabel) {
    timeLabel.setAttribute('value', arpTimeSubdivisions[state.arp.timeSubdivision]);
  }
 
  // Update pattern type label
  const typeLabel = document.getElementById('edit-arp-type-label');
  if (typeLabel) {
    typeLabel.setAttribute('value', arpPatterns[state.arp.pattern]);
  }
}

function createEmptyPattern() {
  return {
    drums: {
      kick: new Array(64).fill(false),
      snare: new Array(64).fill(false),
      hihat: new Array(64).fill(false),
      open: new Array(64).fill(false)
    },
    drumVelocity: {
      kick: new Array(64).fill(1.0),
      snare: new Array(64).fill(1.0),
      hihat: new Array(64).fill(1.0),
      open: new Array(64).fill(1.0)
    },
    bass: new Array(64).fill(''),
    lead: new Array(64).fill(''),
    pad: new Array(64).fill(''),
    arp: new Array(64).fill(''),
    arpChords: new Array(64).fill(null),
    mix: new Array(64).fill(null),
    velocity: {
      bass: new Array(64).fill(0.8),
      lead: new Array(64).fill(0.8),
      pad: new Array(64).fill(0.8),
      arp: new Array(64).fill(0.8)
    }
  };
}

console.log('‚å®Ô∏è Keyboard controls initialized');
console.log('   SPACE = Play/Stop');
console.log('   ‚Üê ‚Üí = Steps');
console.log('   ‚Üë ‚Üì = Tracks');
console.log('   AWSEDFTGYHUJ = Notes');
console.log('   Z/X = Octave');
console.log('   R = Record');
// Register multi-point line component for waveform
// Register multi-point line component for waveform
AFRAME.registerComponent('line__main', {
  schema: {
    path: {type: 'string'},
    color: {type: 'color', default: '#FFF'},
    opacity: {type: 'number', default: 1}
  },
 
  init: function() {
    this.geometry = new THREE.BufferGeometry();
    this.material = new THREE.LineBasicMaterial({
      color: new THREE.Color(this.data.color),
      opacity: this.data.opacity,
      transparent: true,
      linewidth: 2
    });
    this.line = new THREE.Line(this.geometry, this.material);
    this.el.setObject3D('mesh', this.line);
  },
 
  update: function() {
    if (!this.data.path) return;
   
    const points = this.data.path.split(', ').map(p => {
      const coords = p.trim().split(' ').map(Number);
      return new THREE.Vector3(coords[0], coords[1], coords[2] || 0);
    });
   
    this.geometry.setFromPoints(points);
    this.geometry.attributes.position.needsUpdate = true;
    this.material.color.set(this.data.color);
    this.material.opacity = this.data.opacity;
  }
});

// Same for trail lines
AFRAME.registerComponent('line__trail', {
  schema: {
    path: {type: 'string'},
    color: {type: 'color', default: '#FFF'},
    opacity: {type: 'number', default: 0.3}
  },
 
  init: function() {
    this.geometry = new THREE.BufferGeometry();
    this.material = new THREE.LineBasicMaterial({
      color: new THREE.Color(this.data.color),
      opacity: this.data.opacity,
      transparent: true,
      linewidth: 1
    });
    this.line = new THREE.Line(this.geometry, this.material);
    this.el.setObject3D('mesh', this.line);
  },
 
  update: function() {
    if (!this.data.path) return;
   
    const points = this.data.path.split(', ').map(p => {
      const coords = p.trim().split(' ').map(Number);
      return new THREE.Vector3(coords[0], coords[1], coords[2] || 0);
    });
   
    this.geometry.setFromPoints(points);
    this.geometry.attributes.position.needsUpdate = true;
    this.material.color.set(this.data.color);
    this.material.opacity = this.data.opacity;
  }
});
// Register multi-point line component for waveform
console.log('üìä Registering waveform components...');

// Register multi-point line component for waveform
// Register multi-point line component for waveform
// Replace both waveform component registrations with these simpler versions:

AFRAME.registerComponent('waveform-line', {
  schema: {
    points: {default: []},
    color: {type: 'color', default: '#00FFAA'},
    opacity: {type: 'number', default: 1}
  },
 
  init: function() {
    this.geometry = new THREE.BufferGeometry();
    this.material = new THREE.LineBasicMaterial({
      color: new THREE.Color(this.data.color),
      opacity: this.data.opacity,
      transparent: true,
      linewidth: 3
    });
    this.line = new THREE.Line(this.geometry, this.material);
    this.el.setObject3D('mesh', this.line);
  },
 
  update: function() {
    if (!this.data.points || this.data.points.length < 2) {
      this.line.visible = false;
      return;
    }
   
    try {
      const points = this.data.points.map(p => new THREE.Vector3(p.x, p.y, p.z || 0));
      this.geometry.setFromPoints(points);
      this.geometry.attributes.position.needsUpdate = true;
      this.material.color.set(this.data.color);
      this.material.opacity = this.data.opacity;
      this.line.visible = true;
    } catch (err) {
      console.error('Waveform line error:', err);
      this.line.visible = false;
    }
  },
 
  remove: function() {
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
  }
});

AFRAME.registerComponent('waveform-trail', {
  schema: {
    points: {default: []},
    color: {type: 'color', default: '#00FFAA'},
    opacity: {type: 'number', default: 0.3}
  },
 
  init: function() {
    this.geometry = new THREE.BufferGeometry();
    this.material = new THREE.LineBasicMaterial({
      color: new THREE.Color(this.data.color),
      opacity: this.data.opacity,
      transparent: true,
      linewidth: 2
    });
    this.line = new THREE.Line(this.geometry, this.material);
    this.el.setObject3D('mesh', this.line);
  },
 
  update: function() {
    if (!this.data.points || this.data.points.length < 2) {
      this.line.visible = false;
      return;
    }
   
    try {
      const points = this.data.points.map(p => new THREE.Vector3(p.x, p.y, p.z || 0));
      this.geometry.setFromPoints(points);
      this.geometry.attributes.position.needsUpdate = true;
      this.material.color.set(this.data.color);
      this.material.opacity = this.data.opacity;
      this.line.visible = true;
    } catch (err) {
      console.error('Waveform trail error:', err);
      this.line.visible = false;
    }
  },
 
  remove: function() {
    if (this.geometry) this.geometry.dispose();
    if (this.material) this.material.dispose();
  }
});

// ============================================================================
// BULLETPROOF LOAD FUNCTION
// ============================================================================
function loadFromFile(event) {
  const file = event.target.files[0];
  if (!file) return;

  showMessage('‚è≥ READING FILE...');

  const reader = new FileReader();
  reader.onload = async function(e) {
    try {
      const json = e.target.result;
      const data = JSON.parse(json);

      // 1. Stop Audio
      state.isPlaying = false;
      stopAllSources();

      // 2. FIRST - Create ALL 16 empty patterns to prevent undefined errors
      for (let i = 0; i < 16; i++) {
        patterns[i] = createEmptyPattern();
      }

      // 3. NOW load the saved patterns on top of the empty ones
      if (data.patterns && Array.isArray(data.patterns)) {
        for (let i = 0; i < Math.min(data.patterns.length, 16); i++) {
          if (data.patterns[i]) {
            const loadedPat = data.patterns[i];
           // Load trackDecay - THIS IS THE IMPORTANT PART
if (data.trackDecay && Array.isArray(data.trackDecay)) {
  state.trackDecay = [...data.trackDecay];
  console.log('‚úÖ Loaded trackDecay:', state.trackDecay);
} else {
  console.warn('‚ö†Ô∏è No trackDecay in file, using defaults');
  state.trackDecay = [1.0, 1.0, 1.0, 1.0, 1.0];
}
            // Copy all properties from loaded pattern
            // Copy all properties from loaded pattern
if (loadedPat.drums) patterns[i].drums = { ...patterns[i].drums, ...loadedPat.drums };
if (loadedPat.drumVelocity) patterns[i].drumVelocity = { ...patterns[i].drumVelocity, ...loadedPat.drumVelocity };
if (loadedPat.bass) patterns[i].bass = [...loadedPat.bass];
if (loadedPat.lead) patterns[i].lead = [...loadedPat.lead];
if (loadedPat.pad) patterns[i].pad = [...loadedPat.pad];
if (loadedPat.arp) patterns[i].arp = [...loadedPat.arp];
if (loadedPat.arpChords) patterns[i].arpChords = JSON.parse(JSON.stringify(loadedPat.arpChords));
if (loadedPat.mix) patterns[i].mix = JSON.parse(JSON.stringify(loadedPat.mix)); // ‚Üê VERIFY THIS LINE EXISTS
if (loadedPat.velocity) patterns[i].velocity = { ...patterns[i].velocity, ...loadedPat.velocity };
           
            // CRITICAL: Set the length property
            if (loadedPat.length) {
  patterns[i].length = loadedPat.length;
} else {
  patterns[i].length = 64; // Default if not specified
}
          }
        }
      }

     // 4. Load State
if (data.tempo) state.tempo = data.tempo;
if (data.arrangement) state.songArrangement = [...data.arrangement];
if (data.songArrangement) state.songArrangement = [...data.songArrangement];  // ‚Üê Handle both names
if (data.trackVolumes) state.trackVolumes = [...data.trackVolumes];
if (data.trackPans) state.trackPans = [...data.trackPans];
if (data.drumVolumes) state.drumVolumes = [...data.drumVolumes];
if (data.drumPans) state.drumPans = [...data.drumPans];
if (data.masterVolume) state.masterVolume = data.masterVolume;

// Load trackDecay - THIS IS THE IMPORTANT PART
if (data.trackDecay && Array.isArray(data.trackDecay)) {
  state.trackDecay = [...data.trackDecay];
  console.log('‚úÖ Loaded trackDecay:', state.trackDecay);
} else {
  console.warn('‚ö†Ô∏è No trackDecay in file, using defaults');
  state.trackDecay = [1.0, 1.0, 1.0, 1.0, 1.0];
}

if (data.arp) state.arp = { ...data.arp };
if (data.soundIndex) state.soundIndex = { ...data.soundIndex };
if (data.skin) state.skin = { ...data.skin };

      // 5. Reset View
      state.currentPattern = 0;
      state.currentStep = 0;
      state.currentStepView = 0;
      state.highlightedStep = 0;

      // 6. Update UI
      updateUI();
      updateSteps();
     
      if (typeof updateChordSteps === 'function') {
        setTimeout(() => updateChordSteps(), 50);
      }
     
      if (state.currentPage === 'song' && typeof updateSongSlots === 'function') {
        updateSongSlots();
      }

      showMessage('‚úÖ SONG LOADED');

    } catch (err) {
      console.error('Load Error:', err);
      showMessage('‚ùå LOAD ERROR');
    }
    event.target.value = '';
  };
  reader.readAsText(file);
}
function applySkybox() {
  console.log('üåå applySkybox() called');
 
  let skyEntity = document.getElementById('skybox');
 
  // Create sky entity if it doesn't exist
  if (!skyEntity) {
    const scene = document.getElementById('mainScene');
    skyEntity = document.createElement('a-sky');
    skyEntity.setAttribute('id', 'skybox');
    skyEntity.setAttribute('radius', '5000');
    scene.appendChild(skyEntity);
    console.log('‚úÖ Skybox entity created');
  }
 
  if (state.skyboxEnabled && skyboxUrls[state.currentSkyboxIndex]) {
    const skyboxUrl = skyboxUrls[state.currentSkyboxIndex];
    console.log('üåå Setting skybox to:', skyboxUrl);
   
    // Remove the src first to force reload
    skyEntity.removeAttribute('src');
   
    // Set new source after a tiny delay
    setTimeout(() => {
      skyEntity.setAttribute('src', skyboxUrl);
      skyEntity.setAttribute('visible', 'true');
      console.log('‚úÖ Skybox src set');
    }, 50);
   
    showMessage(`üåå SKYBOX ${state.currentSkyboxIndex + 1}/${skyboxUrls.length}`);
  } else {
    console.log('üåå Hiding skybox');
    skyEntity.setAttribute('visible', 'false');
    showMessage('üåå SKYBOX OFF');
  }
}

// Helper function to create assets element if it doesn't exist
function createAssetsElement() {
  const scene = document.getElementById('mainScene');
  let assets = document.querySelector('a-assets');
  if (!assets) {
    assets = document.createElement('a-assets');
    scene.insertBefore(assets, scene.firstChild);
  }
  return assets;
}

function randomizeLighting() {
  const scene = document.querySelector('a-scene');
  if (!scene) return;
 
  // Get existing lights
  const lights = scene.querySelectorAll('a-light[type="point"]');
 
  lights.forEach(light => {
    // Random color
    const hue = Math.random() * 360;
    const color = `hsl(${hue}, 100%, 50%)`;
   
    // Random position
    const x = (Math.random() - 0.5) * 4;
    const y = 2 + Math.random() * 2;
    const z = (Math.random() - 0.5) * 2;
   
    // Random intensity
    const intensity = 0.3 + Math.random() * 0.8;
   
    light.setAttribute('color', color);
    light.setAttribute('position', `${x} ${y} ${z}`);
    light.setAttribute('intensity', intensity);
  });
 
  showMessage('üí° LIGHTING RANDOMIZED');
}

function resetLighting() {
  const scene = document.querySelector('a-scene');
  if (!scene) return;
 
  // Reset to default lighting (restore original values)
  const lights = scene.querySelectorAll('a-light[type="point"]');
  const defaultConfigs = [
    { position: '-1.5 3 -0.5', color: '#FF00FF', intensity: 0.6 },
    { position: '1.5 3 -0.5', color: '#00FFFF', intensity: 0.6 }
  ];
 
  lights.forEach((light, i) => {
    if (defaultConfigs[i]) {
      light.setAttribute('position', defaultConfigs[i].position);
      light.setAttribute('color', defaultConfigs[i].color);
      light.setAttribute('intensity', defaultConfigs[i].intensity);
    }
  });
}


function randomizeLighting() {
  const scene = document.querySelector('a-scene');
  if (!scene) return;
 
  // Get existing lights
  const lights = scene.querySelectorAll('a-light[type="point"]');
 
  lights.forEach(light => {
    // Random color
    const hue = Math.random() * 360;
    const color = `hsl(${hue}, 100%, 50%)`;
   
    // Random position
    const x = (Math.random() - 0.5) * 4;
    const y = 2 + Math.random() * 2;
    const z = (Math.random() - 0.5) * 2;
   
    // Random intensity
    const intensity = 0.3 + Math.random() * 0.8;
   
    light.setAttribute('color', color);
    light.setAttribute('position', `${x} ${y} ${z}`);
    light.setAttribute('intensity', intensity);
  });
 
  showMessage('üí° LIGHTING RANDOMIZED');
}

function resetLighting() {
  const scene = document.querySelector('a-scene');
  if (!scene) return;
 
  // Reset to default lighting (restore original values)
  const lights = scene.querySelectorAll('a-light[type="point"]');
  const defaultConfigs = [
    { position: '-1.5 3 -0.5', color: '#FF00FF', intensity: 0.6 },
    { position: '1.5 3 -0.5', color: '#00FFFF', intensity: 0.6 }
  ];
 
  lights.forEach((light, i) => {
    if (defaultConfigs[i]) {
      light.setAttribute('position', defaultConfigs[i].position);
      light.setAttribute('color', defaultConfigs[i].color);
      light.setAttribute('intensity', defaultConfigs[i].intensity);
    }
  });
}
// BUILD MISC PAGE - UPDATED WITH MIDI OUT, SKYBOX, AND LIGHTING
// BUILD MISC PAGE - REDESIGNED WITH BETTER LAYOUT
// BUILD MISC PAGE - FIXED BUTTON HANDLERS
// BUILD MISC PAGE - REDESIGNED TO MATCH EDIT PAGE LAYOUT
function buildMiscPage() {
  console.log('‚öôÔ∏è Building Misc Page...');
  const workstation = document.getElementById('synthWorkstation');
  if (!workstation) return;

  let miscUI = document.getElementById('miscUI');
  if (miscUI && miscUI.parentNode) miscUI.parentNode.removeChild(miscUI);

  miscUI = document.createElement('a-entity');
  miscUI.setAttribute('id', 'miscUI');
  miscUI.setAttribute('position', '0 0 0');
  workstation.appendChild(miscUI);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // LEFT COLUMN: BPM + TRANSPORT (matches EDIT page)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
  // FM toggle button - moved down towards piano area
// FM toggle button - moved to right of BANK+
createButton(miscUI, 0.80, -0.1, 0.05, 0.22, 0.12, 0.08, '#9b5cff', 'misc-fm-toggle', 'FM', 'white', true);
 
  // BPM controls (left side TOP)
  createButton(miscUI, -1.75, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'misc-bpm-', 'BPM-', 'white', true);
  createButton(miscUI, -1.51, -0.25, 0.04, 0.22, 0.13, 0.08, '#557799', 'misc-bpm+', 'BPM+', 'white', true);
 
  // Transport controls (left side SECOND ROW)
  createButton(miscUI, -1.75, -0.42, 0.04, 0.22, 0.13, 0.08, '#33AA55', 'misc-play', 'PLAY', 'white', true);
  createButton(miscUI, -1.51, -0.42, 0.04, 0.22, 0.13, 0.08, '#DD3333', 'misc-stop', 'STOP', 'white', true);
 
  // Record + Play Block (left side THIRD ROW)
  createButton(miscUI, -1.75, -0.59, 0.04, 0.22, 0.13, 0.08, '#CC3333', 'misc-rec', 'REC', 'white', true);
  createButton(miscUI, -1.51, -0.59, 0.04, 0.22, 0.13, 0.08, '#AA55DD', 'misc-playblk', 'PLYBLK', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CENTER COLUMN: MIDI OUTPUT
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
  createButton(miscUI, -1.05, -0.25, 0.05, 0.30, 0.12, 0.08, '#AA55DD', 'misc-midi-out', 'MIDI OUT', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // SKYBOX SECTION (matches EDIT button size/spacing)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
  createButton(miscUI, -0.70, -0.25, 0.05, 0.30, 0.12, 0.08, '#88AACC', 'misc-skybox-toggle', 'SKYBOX', 'white', true);
  createButton(miscUI, -0.35, -0.25, 0.05, 0.22, 0.12, 0.08, '#5588AA', 'misc-skybox-prev', '<', 'white', true);
 
  // SKYBOX display
  const skyboxDisplayBox = document.createElement('a-box');
  skyboxDisplayBox.setAttribute('position', '-0.09 -0.25 0.04');
  skyboxDisplayBox.setAttribute('width', '0.25');
  skyboxDisplayBox.setAttribute('height', '0.12');
  skyboxDisplayBox.setAttribute('depth', '0.06');
  skyboxDisplayBox.setAttribute('color', '#2a2a4e');
  skyboxDisplayBox.setAttribute('material', 'metalness:0.4;roughness:0.5');
  miscUI.appendChild(skyboxDisplayBox);
 
  const skyboxDisplay = document.createElement('a-text');
  skyboxDisplay.setAttribute('id', 'skybox-display');
  skyboxDisplay.setAttribute('position', '-0.09 -0.25 0.08');
  skyboxDisplay.setAttribute('value', 'SKY 1');
  skyboxDisplay.setAttribute('align', 'center');
  skyboxDisplay.setAttribute('color', '#FFFFFF');
  skyboxDisplay.setAttribute('width', '3');
  skyboxDisplay.setAttribute('scale', '0.25 0.25 0.25');
  miscUI.appendChild(skyboxDisplay);
 
  createButton(miscUI, 0.20, -0.25, 0.05, 0.22, 0.12, 0.08, '#5588AA', 'misc-skybox-next', '>', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // LIGHTING SECTION (stacked vertically)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
  createButton(miscUI, -1.05, -0.39, 0.05, 0.30, 0.12, 0.08, '#FFAA55', 'misc-lighting-toggle', 'LIGHTING', 'white', true);
  createButton(miscUI, -1.05, -0.53, 0.05, 0.30, 0.12, 0.08, '#FF5588', 'misc-lighting-rand', 'RAND', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RIGHT COLUMN: VIEW BUTTONS (matches EDIT page)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
  ui.miscViewButtons = [];
  ui.miscViewButtons.push(createButton(miscUI, 1.20, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'misc-v1', '1-16', 'white', true));
  ui.miscViewButtons.push(createButton(miscUI, 1.42, -0.18, 0.05, 0.20, 0.12, 0.08, '#336688', 'misc-v2', '17-32', 'white', true));
  ui.miscViewButtons.push(createButton(miscUI, 1.20, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'misc-v3', '33-48', 'white', true));
  ui.miscViewButtons.push(createButton(miscUI, 1.42, -0.32, 0.05, 0.20, 0.12, 0.08, '#336688', 'misc-v4', '49-64', 'white', true));

  // PATTERN CONTROLS (matches EDIT page)
  createButton(miscUI, 1.20, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'misc-pat-', 'PAT-', 'white', true);
  createButton(miscUI, 1.42, -0.46, 0.05, 0.20, 0.12, 0.08, '#555577', 'misc-pat+', 'PAT+', 'white', true);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // BANK SELECTION (moved down and right)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  // Bank selection buttons
  createButton(miscUI, -0.50, -0.53, 0.05, 0.22, 0.12, 0.08, '#5588AA', 'misc-bank-prev', 'BANK-', 'white', true);

  // Bank display - WIDER
  const bankDisplayBox = document.createElement('a-box');
  bankDisplayBox.setAttribute('position', '-0.09 -0.53 0.04');
  bankDisplayBox.setAttribute('width', '0.45');  // ‚Üê WIDER (was 0.25)
  bankDisplayBox.setAttribute('height', '0.12');
  bankDisplayBox.setAttribute('depth', '0.06');
  bankDisplayBox.setAttribute('color', '#2a2a4e');
  bankDisplayBox.setAttribute('material', 'metalness:0.4;roughness:0.5');
  miscUI.appendChild(bankDisplayBox);

  const bankDisplay = document.createElement('a-text');
  bankDisplay.setAttribute('id', 'bank-display');
  bankDisplay.setAttribute('position', '-0.09 -0.53 0.08');
  bankDisplay.setAttribute('value', SOUNDSETS[state.currentBankNumber - 1].name);  // ‚Üê Use actual bank name
  bankDisplay.setAttribute('align', 'center');
  bankDisplay.setAttribute('color', '#FFFFFF');  // ‚Üê WHITE TEXT
  bankDisplay.setAttribute('width', '3');
  bankDisplay.setAttribute('scale', '0.30 0.30 0.30');  // ‚Üê BIGGER (was 0.25)
  miscUI.appendChild(bankDisplay);

  createButton(miscUI, 0.35, -0.53, 0.05, 0.22, 0.12, 0.08, '#5588AA', 'misc-bank-next', 'BANK+', 'white', true);

  const infoDisplay = document.getElementById('infoDisplay');
  if (infoDisplay) {
    infoDisplay.object3D.visible = true;
    infoDisplay.setAttribute('visible', 'true');
  }
 
  // Initialize state - DEFAULT SKYBOX OFF
  if (typeof state.midiOutEnabled === 'undefined') state.midiOutEnabled = false;
  if (typeof state.skyboxEnabled === 'undefined') state.skyboxEnabled = false; // ‚Üê CHANGED TO FALSE
  if (typeof state.currentSkyboxIndex === 'undefined') state.currentSkyboxIndex = 0;
  if (typeof state.lightingEnabled === 'undefined') state.lightingEnabled = true;

  updateMiscButtons();

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FM MODE VISIBILITY - ADD AT THE VERY END
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
 
  // If FM is enabled, hide the MISC UI we just built
  if (window.FM && window.FM.enabled) {
    console.log('   -> FM is enabled, hiding original MISC UI');
    miscUI.object3D.visible = false;
    // Save reference so FM can restore it later
    window.FM.originalMiscUI = miscUI;
  }
}
function updateMiscButtons() {
  // Update MIDI OUT button

 const bankDisplay = document.getElementById('bank-display');
if (bankDisplay) {
  const bankInfo = SOUNDSETS[state.currentBankNumber - 1];
  bankDisplay.setAttribute('value', bankInfo ? bankInfo.name : `BANK ${state.currentBankNumber}`);
}
  const midiBtn = document.getElementById('misc-midi-out');
  if (midiBtn) {
    const label = midiBtn.querySelector('a-text');
   
    if (state.midiOutEnabled) {
      midiBtn.setAttribute('color', '#00FF00');
      midiBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.5');
      midiBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000');
    } else {
      midiBtn.setAttribute('color', '#AA55DD');
      midiBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      midiBtn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white');
    }
// Update TAPE button
const tapeBtn = document.getElementById('misc-tape-toggle');
if (tapeBtn) {
  const label = tapeBtn.querySelector('a-text');
 
  if (state.tapeMode) {
    tapeBtn.setAttribute('color', '#00FF00');
    tapeBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.5');
    tapeBtn.setAttribute('scale', '1.1 1.1 1.1');
    if (label) label.setAttribute('color', '#000000');
  } else {
    tapeBtn.setAttribute('color', '#FF5588');
    tapeBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
    tapeBtn.setAttribute('scale', '1 1 1');
    if (label) label.setAttribute('color', 'white');
  }
}
  }
 
  // Update SKYBOX button
  const skyboxBtn = document.getElementById('misc-skybox-toggle');
  if (skyboxBtn) {
    const label = skyboxBtn.querySelector('a-text');
   
    if (state.skyboxEnabled) {
      skyboxBtn.setAttribute('color', '#00FF00');
      skyboxBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.5');
      skyboxBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000');
    } else {
      skyboxBtn.setAttribute('color', '#88AACC');
      skyboxBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      skyboxBtn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white');
    }
  }
 
  // Update skybox display
  const skyboxDisplay = document.getElementById('skybox-display');
  if (skyboxDisplay) {
    skyboxDisplay.setAttribute('value', `SKY ${state.currentSkyboxIndex + 1}`);
  }
 
  // Update LIGHTING button
  const lightBtn = document.getElementById('misc-lighting-toggle');
  if (lightBtn) {
    const label = lightBtn.querySelector('a-text');
   
    if (state.lightingEnabled) {
      lightBtn.setAttribute('color', '#00FF00');
      lightBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#00FF00;emissiveIntensity:1.5');
      lightBtn.setAttribute('scale', '1.1 1.1 1.1');
      if (label) label.setAttribute('color', '#000000');
    } else {
      lightBtn.setAttribute('color', '#FFAA55');
      lightBtn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      lightBtn.setAttribute('scale', '1 1 1');
      if (label) label.setAttribute('color', 'white');
    }
  }
 
  // Show/hide RAND button based on lighting state
  const randBtn = document.getElementById('misc-lighting-rand');
  if (randBtn) {
    randBtn.object3D.visible = state.lightingEnabled;
    randBtn.setAttribute('visible', state.lightingEnabled ? 'true' : 'false');
  }
 
  // Update view buttons
  if (ui.miscViewButtons) {
    ui.miscViewButtons.forEach((btn, i) => {
      if (i === state.currentStepView) {
        btn.setAttribute('color', purple);
        btn.setAttribute('material', `metalness:.3;roughness:.6;emissive:${purple};emissiveIntensity:1.2`);
      } else {
        btn.setAttribute('color', '#336688');
        btn.setAttribute('material', 'metalness:.3;roughness:.6;emissive:#000;emissiveIntensity:0');
      }
    });
  }
}

function randomizeLighting() {
  const scene = document.querySelector('a-scene');
  if (!scene) return;
 
  // Get existing lights
  const pointLights = scene.querySelectorAll('a-light[type="point"]');
  const directionalLight = scene.querySelector('a-light[type="directional"]');
  const ambientLight = scene.querySelector('a-light[type="ambient"]');
 
  // Choose a random lighting scheme
  const schemes = [
    // Scheme 1: Neon Club
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#FF00FF', '#00FFFF', '#FF0088', '#00FF88'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.8 + Math.random() * 0.4);
        light.setAttribute('position', `${(Math.random() - 0.5) * 4} ${2 + Math.random() * 2} ${(Math.random() - 0.5) * 3}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.1);
      showMessage('üíú NEON CLUB');
    },
   
    // Scheme 2: Sunset Warm
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#FF6600', '#FF9900', '#FFCC00', '#FF3300'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.6 + Math.random() * 0.3);
        light.setAttribute('position', `${(Math.random() - 0.5) * 3} ${3 + Math.random()} ${(Math.random() - 0.5) * 2}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.3);
      if (directionalLight) directionalLight.setAttribute('color', '#FFAA66');
      showMessage('üåÖ SUNSET WARM');
    },
   
    // Scheme 3: Deep Blue
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#0033FF', '#0066FF', '#0099FF', '#00CCFF'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.5 + Math.random() * 0.4);
        light.setAttribute('position', `${(Math.random() - 0.5) * 4} ${2.5 + Math.random() * 1.5} ${(Math.random() - 0.5) * 2.5}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.05);
      showMessage('üåä DEEP BLUE');
    },
   
    // Scheme 4: Strobe Rainbow
    () => {
      pointLights.forEach((light, i) => {
        const hue = (i * 90) % 360;
        light.setAttribute('color', `hsl(${hue}, 100%, 50%)`);
        light.setAttribute('intensity', 0.9 + Math.random() * 0.3);
        light.setAttribute('position', `${(Math.random() - 0.5) * 5} ${3 + Math.random()} ${(Math.random() - 0.5) * 3}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.15);
      showMessage('üåà STROBE RAINBOW');
    },
   
    // Scheme 5: Cyberpunk
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#FF00AA', '#00FFFF', '#FFFF00', '#FF0066'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.7 + Math.random() * 0.5);
        light.setAttribute('position', `${(Math.random() - 0.5) * 4} ${2 + Math.random() * 2} ${(Math.random() - 0.5) * 2}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.2);
      if (directionalLight) directionalLight.setAttribute('color', '#FF00FF');
      showMessage('‚ö° CYBERPUNK');
    },
   
    // Scheme 6: Forest Green
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#00FF00', '#33FF33', '#66FF66', '#00CC00'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.4 + Math.random() * 0.3);
        light.setAttribute('position', `${(Math.random() - 0.5) * 3} ${2.5 + Math.random()} ${(Math.random() - 0.5) * 2}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.25);
      showMessage('üå≤ FOREST GREEN');
    },
   
    // Scheme 7: Purple Haze
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#9900FF', '#CC00FF', '#FF00FF', '#6600CC'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.6 + Math.random() * 0.4);
        light.setAttribute('position', `${(Math.random() - 0.5) * 4} ${2 + Math.random() * 2} ${(Math.random() - 0.5) * 2.5}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.15);
      showMessage('üíú PURPLE HAZE');
    },
   
    // Scheme 8: Fire Red
    () => {
      pointLights.forEach((light, i) => {
        const colors = ['#FF0000', '#FF3300', '#FF6600', '#FF9900'];
        light.setAttribute('color', colors[i % colors.length]);
        light.setAttribute('intensity', 0.8 + Math.random() * 0.4);
        light.setAttribute('position', `${(Math.random() - 0.5) * 3} ${2 + Math.random() * 2} ${(Math.random() - 0.5) * 2}`);
      });
      if (ambientLight) ambientLight.setAttribute('intensity', 0.1);
      if (directionalLight) directionalLight.setAttribute('color', '#FF6600');
      showMessage('üî• FIRE RED');
    }
  ];
 
  // Pick and apply random scheme
  const scheme = schemes[Math.floor(Math.random() * schemes.length)];
  scheme();
}

async function switchBank(bankNum) {
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  console.log(`üéµ SWITCH BANK called: ${bankNum}`);
 
  if (!audioInitialized || !audioContext) {
    console.error('‚ùå Audio not initialized');
    try {
      await initAudio();
    } catch (err) {
      console.error('‚ùå Init failed:', err);
      return;
    }
  }
 
  if (bankNum < 1 || bankNum > SOUNDSETS.length) {
    console.error(`‚ùå Invalid bank number: ${bankNum}`);
    return;
  }
 
  const bankInfo = SOUNDSETS[bankNum - 1];
  const baseUrl = bankInfo.baseUrl;
 
  console.log(`üì¶ Bank: ${bankInfo.name}`);
  console.log(`üìç Base URL: ${baseUrl}`);
 
  // **TEST IF FILES EXIST FIRST**
  console.log('üîç Testing if bank files exist...');
  const testUrl = `${baseUrl}/kick.wav`;
  console.log(`   Testing: ${testUrl}`);
 
  try {
    const testResponse = await fetch(testUrl, { method: 'HEAD' });
    console.log(`   Response: ${testResponse.status} ${testResponse.statusText}`);
   
    if (!testResponse.ok) {
      console.error(`‚ùå Bank ${bankNum} files not found!`);
      console.error(`   Expected URL: ${testUrl}`);
      console.error(`   Got: ${testResponse.status}`);
      showMessage(`‚ùå BANK ${bankNum} NOT FOUND`);
      return;
    }
   
    console.log(`‚úÖ Bank ${bankNum} files exist!`);
   
  } catch (err) {
    console.error(`‚ùå Cannot reach bank ${bankNum}:`, err);
    showMessage(`‚ùå BANK ${bankNum} UNREACHABLE`);
    return;
  }
 
  // Stop all playing sounds
  stopAllSources();
 
  showMessage(`‚è≥ LOADING ${bankInfo.name}...`);
 
  // **LOAD DRUMS**
  console.log('‚îÅ‚îÅ‚îÅ LOADING DRUMS ‚îÅ‚îÅ‚îÅ');
  const drumNames = ['kick', 'snare', 'hihat', 'open'];
  const drumFiles = ['kick.wav', 'snare.wav', 'hihat.wav', 'openhi.wav'];
 
  for (let i = 0; i < drumNames.length; i++) {
    const drumName = drumNames[i];
    const fileName = drumFiles[i];
    const url = `${baseUrl}/${fileName}`;
   
    console.log(`üì• Loading ${drumName} from: ${url}`);
   
    try {
      const response = await fetch(url);
     
      if (!response.ok) {
        console.error(`   ‚ùå HTTP ${response.status} for ${drumName}`);
        showMessage(`‚ùå ${drumName.toUpperCase()} MISSING`);
        continue;
      }
     
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
     
      buffers.drums[drumName] = audioBuffer;
      SAMPLE_BANKS.drums[drumName] = url;
     
      console.log(`   ‚úÖ ${drumName} loaded (${audioBuffer.duration.toFixed(2)}s, ${arrayBuffer.byteLength} bytes)`);
     
    } catch (err) {
      console.error(`   ‚ùå ${drumName} failed:`, err);
    }
  }
 
  // **LOAD INSTRUMENTS**
  console.log('‚îÅ‚îÅ‚îÅ LOADING INSTRUMENTS ‚îÅ‚îÅ‚îÅ');
  const instruments = ['bass', 'lead', 'pad', 'arp'];
 
  for (const instrument of instruments) {
    const url = `${baseUrl}/${instrument}.wav`;
    console.log(`üì• Loading ${instrument} from: ${url}`);
   
    try {
      const response = await fetch(url);
     
      if (!response.ok) {
        console.error(`   ‚ùå HTTP ${response.status} for ${instrument}`);
        showMessage(`‚ùå ${instrument.toUpperCase()} MISSING`);
        continue;
      }
     
      const arrayBuffer = await response.arrayBuffer();
      const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
     
      for (let i = 0; i < 8; i++) {
        buffers[instrument][i] = audioBuffer;
        SAMPLE_BANKS[instrument][i] = {
          name: `${bankInfo.name} ${instrument} ${i + 1}`,
          url: url,
          base: 'C4'
        };
      }
     
      console.log(`   ‚úÖ ${instrument} loaded (${audioBuffer.duration.toFixed(2)}s, ${arrayBuffer.byteLength} bytes)`);
     
    } catch (err) {
      console.error(`   ‚ùå ${instrument} failed:`, err);
    }
  }
 
  // **VERIFY BUFFERS**
  console.log('‚îÅ‚îÅ‚îÅ VERIFYING BUFFERS ‚îÅ‚îÅ‚îÅ');
  console.log('ü•Å Drums:');
  drumNames.forEach(drum => {
    const buf = buffers.drums[drum];
    if (buf) {
      console.log(`   ${drum}: ‚úÖ ${buf.duration.toFixed(2)}s (${buf.length} samples)`);
    } else {
      console.log(`   ${drum}: ‚ùå NULL`);
    }
  });
 
  console.log('üéπ Instruments:');
  instruments.forEach(type => {
    const buf = buffers[type][0];
    if (buf) {
      console.log(`   ${type}: ‚úÖ ${buf.duration.toFixed(2)}s (${buf.length} samples)`);
    } else {
      console.log(`   ${type}: ‚ùå NULL`);
    }
  });
 
  // Update state
  state.currentBankNumber = bankNum;
 
  const bankDisplay = document.getElementById('bank-display');
  if (bankDisplay) {
    bankDisplay.setAttribute('value', bankInfo.name);
  }
 
  console.log(`‚úÖ Bank ${bankNum} switch complete!`);
  showMessage(`‚úÖ ${bankInfo.name}`);
 
  // **TEST PLAYBACK**
  setTimeout(() => {
    console.log('üîä Testing kick playback...');
    if (buffers.drums.kick) {
      playDrum('kick');
      console.log(`‚úÖ Played kick from bank ${bankNum}`);
    } else {
      console.error('‚ùå Kick buffer still null!');
    }
  }, 300);
 
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
}


</script>
</body>
</html>
